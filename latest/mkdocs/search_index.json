{
    "docs": [
        {
            "location": "/", 
            "text": "InstrumentControl.jl\n\n\nA \nJulia\n package for qubit measurement and analysis.\n\n\n\n\nInstallation\n\n\n\n\nInstall \nNational Instruments VISA libraries\n (tested with v15.0.1 on Windows 10)\n\n\nInstall \nAlazarTech\n digitizer drivers and shared libraries (may need to contact AlazarTech) if using Alazar digitizer\n\n\nInstall \nVISA.jl\n package\n\n\nInstall \nAlazar.jl\n package\n\n\nInstall \nKeysightInstruments.jl\n package\n\n\nInstall \nICCommon.jl\n package\n\n\nInstall \nICDataServer.jl\n package and follow it's \ninstallation procedure\n\n\nInstall \nInstrumentControl.jl\n package\n\n\n\n\n\n\nExample Notebooks\n\n\nInstrumentControl.jl relies on having physical instruments, communication with a database set up by ICDataServer.jl, and various files with machine specific configuration information in order to run. As such, we provide some example notebooks in order to showcase this package's functionality.\n\n\n# put example notebooks here\n\n\n\n\n\n\n\nNew to Julia\n\n\nThis documentation seeks to provide a higher-level description of the architecture and control-flow of the code, with references to the source code only to facilitate explanation. If the user seeks to understand the source code, while this documentation is a useful aid, aptitude and understanding of the Julia language will be necessary to fully understand it's implementation in a line by line level. For those who have a background in programming, but not in Julia, below is a list of Julia features used in the source code which might not be featured in other languages, along with links to the Julia docs explaining them. It is our hope that, with the reading listed below and this documentation, that any reader with some background in programming would be able to satisfactorily understand the source code:\n\n\n\n\n\n\nTypes\n\n\n\n\nJulia Types in general\n\n\nParametric Types\n\n\nSingleton Types\n\n\n\n\nFunctions and Methods\n\n\n\n\n\n\nOptional and Keyword Arguments\n\n\n\n\nAnonymous Functions\n\n\nParametric Methods\n\n\nVararg Functions\n\n\n\n\nMacros and Metaprogramming\n\n\n\n\n\n\nMetaprogramming in general\n (also describes the \nSymbol\n type and expressions)\n\n\n\n\nMacros\n\n\n\n\nTasks\n\n\n\n\n\n\nTasks\n\n\n\n\nDynamic Scheduling of Tasks\n\n\n\n\nMiscellaneous\n\n\n\n\n\n\nShort Circuit Evaluation", 
            "title": "Home"
        }, 
        {
            "location": "/#instrumentcontroljl", 
            "text": "A  Julia  package for qubit measurement and analysis.", 
            "title": "InstrumentControl.jl"
        }, 
        {
            "location": "/#installation", 
            "text": "Install  National Instruments VISA libraries  (tested with v15.0.1 on Windows 10)  Install  AlazarTech  digitizer drivers and shared libraries (may need to contact AlazarTech) if using Alazar digitizer  Install  VISA.jl  package  Install  Alazar.jl  package  Install  KeysightInstruments.jl  package  Install  ICCommon.jl  package  Install  ICDataServer.jl  package and follow it's  installation procedure  Install  InstrumentControl.jl  package", 
            "title": "Installation"
        }, 
        {
            "location": "/#example-notebooks", 
            "text": "InstrumentControl.jl relies on having physical instruments, communication with a database set up by ICDataServer.jl, and various files with machine specific configuration information in order to run. As such, we provide some example notebooks in order to showcase this package's functionality.  # put example notebooks here", 
            "title": "Example Notebooks"
        }, 
        {
            "location": "/#new-to-julia", 
            "text": "This documentation seeks to provide a higher-level description of the architecture and control-flow of the code, with references to the source code only to facilitate explanation. If the user seeks to understand the source code, while this documentation is a useful aid, aptitude and understanding of the Julia language will be necessary to fully understand it's implementation in a line by line level. For those who have a background in programming, but not in Julia, below is a list of Julia features used in the source code which might not be featured in other languages, along with links to the Julia docs explaining them. It is our hope that, with the reading listed below and this documentation, that any reader with some background in programming would be able to satisfactorily understand the source code:    Types   Julia Types in general  Parametric Types  Singleton Types   Functions and Methods    Optional and Keyword Arguments   Anonymous Functions  Parametric Methods  Vararg Functions   Macros and Metaprogramming    Metaprogramming in general  (also describes the  Symbol  type and expressions)   Macros   Tasks    Tasks   Dynamic Scheduling of Tasks   Miscellaneous    Short Circuit Evaluation", 
            "title": "New to Julia"
        }, 
        {
            "location": "/design/", 
            "text": "Design Summary\n\n\n\n\nWhat should good measurement code do?\n\n\nAnyone who has written code in MATLAB or something comparable (IGOR Pro, in the author's case) has undoubtedly seen spaghetti code. Often there are many copies of a measurement routine that differ only slightly, perhaps in the functionality of what happens inside some for loop, etc.\n\n\nWe would like to have clear, reusable code to avoid redundancy and accidental errors, both of which consume precious time on the part of the experimenters. Consider an archetypal measurement scheme wherein we measure a device's response to various stimuli (perhaps we measure current as a function of applied bias). We should be able to write just one sweep function to do this.\n\n\nThe idea of \nmultiple dispatch\n, natively supported in Julia, permits writing such convenient and abstract code. For example, one sweep function could encompass various sweep methods, where there is a unique method for any particular combination of stimuli to measure a response. Multiple dispatch would be able to discern which method to use based on the \ntypes\n of stimuli and response passed to the function. This is just one example where the advantages of multiple dispatch are obvious. We hope it will more broadly simplify the extension of measurement code while ensuring continued reliability.\n\n\n\n\nSummary of Functionality\n\n\nThis package approaches the problem of measurement in an object oriented manner. As such, Julia types are defined for instrument, instrument properties, independent variables to be swept over during measurement, and dependent variables to be measured. Interfacing with instruments, such as configuring their properties, sweeping through parameters such as voltage, frequency, etc, and actually recording measurement values coming from instruments, are all done through manipulation of instances of these types.\n\n\nA careful framework of abstract super types has been fleshed out in this package, along with sweeping and job scheduling/queueing functionality that expects subtypes of the aforementioned super types. However, each user will have their own unique instruments and measurements to perform. As such, users are expected to write their own type definitions and some methods for those types; but when properly written, they fit in seamlessly into the functionality written around the super types described in the rest of this documentation.\n\n\nNotably, this package implements queueing structure for measurement \"jobs\" , which affords automation of measurements and facilitates use of the same instruments by multiple users. The queue schedules jobs automatically in the background of the Julia interface that the user is using. We call these jobs \"sweep jobs\", in accordance with what one usually thinking of measurement: measuring some dependent variable with respect to some independent variable that is swept across a range of values. When the user executes the \nsweep\n function, job objects are automatically generated, passed to the queue, and scheduled according to their priority without any additional input from the user.\n\n\nFinally, InstrumentControl.jl communicates with a relational database server, set up by \nICDataServer.jl\n, which is used to maintain a log of information for each job. An entry in the database is automatically made for each job submitted to the queue", 
            "title": "Design Summary"
        }, 
        {
            "location": "/design/#design-summary", 
            "text": "", 
            "title": "Design Summary"
        }, 
        {
            "location": "/design/#what-should-good-measurement-code-do", 
            "text": "Anyone who has written code in MATLAB or something comparable (IGOR Pro, in the author's case) has undoubtedly seen spaghetti code. Often there are many copies of a measurement routine that differ only slightly, perhaps in the functionality of what happens inside some for loop, etc.  We would like to have clear, reusable code to avoid redundancy and accidental errors, both of which consume precious time on the part of the experimenters. Consider an archetypal measurement scheme wherein we measure a device's response to various stimuli (perhaps we measure current as a function of applied bias). We should be able to write just one sweep function to do this.  The idea of  multiple dispatch , natively supported in Julia, permits writing such convenient and abstract code. For example, one sweep function could encompass various sweep methods, where there is a unique method for any particular combination of stimuli to measure a response. Multiple dispatch would be able to discern which method to use based on the  types  of stimuli and response passed to the function. This is just one example where the advantages of multiple dispatch are obvious. We hope it will more broadly simplify the extension of measurement code while ensuring continued reliability.", 
            "title": "What should good measurement code do?"
        }, 
        {
            "location": "/design/#summary-of-functionality", 
            "text": "This package approaches the problem of measurement in an object oriented manner. As such, Julia types are defined for instrument, instrument properties, independent variables to be swept over during measurement, and dependent variables to be measured. Interfacing with instruments, such as configuring their properties, sweeping through parameters such as voltage, frequency, etc, and actually recording measurement values coming from instruments, are all done through manipulation of instances of these types.  A careful framework of abstract super types has been fleshed out in this package, along with sweeping and job scheduling/queueing functionality that expects subtypes of the aforementioned super types. However, each user will have their own unique instruments and measurements to perform. As such, users are expected to write their own type definitions and some methods for those types; but when properly written, they fit in seamlessly into the functionality written around the super types described in the rest of this documentation.  Notably, this package implements queueing structure for measurement \"jobs\" , which affords automation of measurements and facilitates use of the same instruments by multiple users. The queue schedules jobs automatically in the background of the Julia interface that the user is using. We call these jobs \"sweep jobs\", in accordance with what one usually thinking of measurement: measuring some dependent variable with respect to some independent variable that is swept across a range of values. When the user executes the  sweep  function, job objects are automatically generated, passed to the queue, and scheduled according to their priority without any additional input from the user.  Finally, InstrumentControl.jl communicates with a relational database server, set up by  ICDataServer.jl , which is used to maintain a log of information for each job. An entry in the database is automatically made for each job submitted to the queue", 
            "title": "Summary of Functionality"
        }, 
        {
            "location": "/ins_meas/", 
            "text": "Interfacing with Instruments and Making Measurements\n\n\n\n\nWhat is an instrument?\n\n\nFor the purposes of this package, an instrument is just something connected to the computer that we need to communicate with, and which can apply some stimulus or measure something. Every instrument may connect to the computer by different hardware, comms protocols, and command dialects.\n\n\nAll instruments are Julia objects, subtypes of the abstract type \nInstrument\n. The implementation of each subtype (it's fields, constructors, etc) depend on the specific instrument.\n\n\n\n\nVISA\n\n\nMany instruments are able to be addressed using the \nVISA\n standard (Virtual Instrument Software Architecture), currently maintained by the IVI Foundation.\n\n\nTo talk to VISA instruments will require the Julia package \nVISA.jl\n as well as the \nNational Instruments VISA libraries\n. Installation instructions are available at each link.\n\n\n\n\nAlazar digitizers\n\n\nDigitizers made by \nAlazarTech\n are notably \nnot\n compatible with the VISA standard. All Alazar digitizers are addressable by an API supplied by the company, which talks to the card through a shared library (a .dll on Windows or .so on Linux). \nInstrumentAlazar\n is an abstract subtype of \nInstrument\n.\n\n\nThe shared library files and API documentation are only available from AlazarTech.\n\n\n\n\nHow do we configure instruments?\n\n\n\n\nProperties\n\n\nInstrument properties are configured and inspected using two functions, \nsetindex!\n and \ngetindex\n, which are methods from the Base module that have been overloaded in this package to work with instrument objects. This results in a convenient and concise syntax (\ncredit due to Oliver Schulz\n for this idea).\n\n\nFor example:\n\n\nawg\n[\nTriggerSlope\n]\n \n=\n \n:\nRising\n\n\nawg\n[\nSampleRate\n]\n \n=\n \n10e6\n\n\n\n\n\n\n\n\nHow do we take measurements?\n\n\n\n\nSource and measure\n\n\nTwo functions are provided to abstract away many kinds of measurements: \nsource\n and \nmeasure\n. In an experiment you source  some stimulus and measure a response. Therefore \nsource\n takes as arguments: an instance of some subtype of the \nStimulus\n type (which can have different fields for different subtypes), as well as the numerical value(s) for the particular stimulus. \nmeasure\n takes as argument an instance of some subtype of type \nResponse\n. The idea is to write new subtypes of \nStimulus\n and \nResponse\n to describe what you are doing, as well as new methods for \nsource\n and \nmeasure\n that know how to communicate with the instrument(s) based on the Stimuli and Response arguments passed to them\n\n\n\n\nStimuli\n\n\nAll stimuli are objects, subtyped from the abstract \nStimulus\n type. Many stimuli, either general or associated with the capabilities of particular instruments, are already implemented. The implementation of each subtype depends on the specific goals of the user: demonstrations of different stimuli being used can be found in the example notebooks.\n\n\nAs a simple example, consider the \nPropertyStimulus\n type (defined in \nICCommon.jl\n) :\n\n\nmutable\n \nstruct\n \nPropertyStimulus\n{\nT\n:\nInstrumentProperty\n}\n \n:\n \nStimulus\n\n    \ntyp\n::\nType\n{\nT\n}\n\n    \nins\n::\nInstrument\n    \n    \ntuple\n::\nTuple\n\n    \naxisname\n::\nSymbol\n\n    \naxislabel\n::\nString\n\n\nend\n\n\n\n\n\n\nwith corresponding source method:\n\n\nfunction\n \nsource\n(\nch\n::\nPropertyStimulus\n,\n \nval\n)\n\n    \nch\n.\nins\n[\nch\n.\ntyp\n,\n \nch\n.\ntuple\n...\n]\n \n=\n \nval\n\n\nend\n\n\n\n\n\n\nNotable among the fields  of \nPropertyStimulus\n are the \ntyp\n and \nins\n fields: \ntyp\n is the instrument property the stimulus object is associated with, and \nins\n is the instrument which that property corresponds to (Type{T} is a special kind of abstract type whose only instance is the object T; visit the \ndocs\n for further discussion). \ntuple\n are essentially \"qualifiers\" or \"infixes\" for the instrument property. For example, if we wanted to change (source) the amplitude of a waveform in a waveform generator instrument with multiple channels, the instrument property at hand is \nSourceLevel\n while \ntuple\n would specify on \nwhat channel\n we are changing the amplitude.  \n\n\nThus, this \nStimulus\n object holds all the necessary information for a \nsource\n method to change the value of instrument property \nT\n to any value passed to it. And the corresponding source function in fact does just that: it calls a setindex! method to change property \nT\n (with qualifiers \ntuple\n) on instrument \nins\n to value \nval\n. Again, stimuli need not be tied to a particular property; rather, this is just one convenient and easily generalizable example.\n\n\nFor a concrete example on the use of \nPropertyStimulus\n, consider needing to source various frequencies in our E8257D signal generator, where the frequency of a signal generator is an instrument property called \nFrequency\n. We can accomplish this task using \nPropertyStimulus\n in the following way:\n\n\nstim\n \n=\n \nPropertyStimulus\n(\nsiggen\n::\nE8257D\n,\n \nFrequency\n)\n\n\nfor\n \nfreq\n \nin\n \n1e9\n:\n1e8\n:\n5e9\n     \n# 1 GHz to 5 GHz in steps of 100 MHz\n\n    \nsource\n(\nstim\n,\n \nfreq\n)\n\n    \n# measure(something)\n\n\nend\n\n\n\n\n\n\nEasy right?\n\n\nNote that one may assign whatever fields and constructor one wishes for a newly created \nStimulus\n subtype. Also, note that not all stimuli need to be associated with a physical instrument. For instance, sourcing a \nDelayStimulus\n will cause the script to block until a specified time after creation of the \nDelayStimulus\n object. Moreover, a Stimulus could also be associated with several instruments. Maybe a stimulus that makes sense for a particular experiment would be to change all gate voltages at once. These gate voltages could of course be sourced by several physical instruments.\n\n\n\n\nResponses\n\n\nAll responses are objects, subtyped from the abstract \nResponse\n type. Usually a response is associated with a particular instrument. The implementation of each subtype depends on the specific goals of the user: demonstrations of different response being used can be found in the example notebooks.\n\n\n(put example here)\n\n\nHowever, responses need not come from instruments. For test purposes, suppose we want to mimic a measurement by generating random numbers. \nRandomResponse\n produces a random number in the unit interval when it is measured. A \nTimerResponse\n will measure the time since creation of the \nTimerResponse\n object.\n\n\n\n\nDifference between stimuli and instrument properties\n\n\nBecause a stimulus is defined so broadly, the difference between a stimulus and an instrument property is not obvious. While in many cases there is an overlap between stimuli and properties, a stimulus is like a generalized instrument property: sourcing a stimulus may entail configuring zero or more instrument properties, on zero or more different instruments. As was mentioned earlier, a useful stimulus could be to change gate voltages on multiple different instruments all at once.\n\n\nIt is useful to think of a stimulus as something which has a chance to react to what you are measuring. For example, this could be applied voltage, sourced by one or more instruments. The applied voltages would be seen by the device under test, which would respond accordingly. The stimulus could also just be a time delay, provided by the measurement computer. It could even be the number of threads used by Julia for real-time processing.\n\n\nAn instrument property is any persistent setting of an instrument. Tweaking an instrument property could affect the device under test, but it might not. Averaging is a good example. With averaging a measurement may look less noisy, but your device under test doesn't know the difference.", 
            "title": "Instruments/Measurements"
        }, 
        {
            "location": "/ins_meas/#interfacing-with-instruments-and-making-measurements", 
            "text": "", 
            "title": "Interfacing with Instruments and Making Measurements"
        }, 
        {
            "location": "/ins_meas/#what-is-an-instrument", 
            "text": "For the purposes of this package, an instrument is just something connected to the computer that we need to communicate with, and which can apply some stimulus or measure something. Every instrument may connect to the computer by different hardware, comms protocols, and command dialects.  All instruments are Julia objects, subtypes of the abstract type  Instrument . The implementation of each subtype (it's fields, constructors, etc) depend on the specific instrument.", 
            "title": "What is an instrument?"
        }, 
        {
            "location": "/ins_meas/#visa", 
            "text": "Many instruments are able to be addressed using the  VISA  standard (Virtual Instrument Software Architecture), currently maintained by the IVI Foundation.  To talk to VISA instruments will require the Julia package  VISA.jl  as well as the  National Instruments VISA libraries . Installation instructions are available at each link.", 
            "title": "VISA"
        }, 
        {
            "location": "/ins_meas/#alazar-digitizers", 
            "text": "Digitizers made by  AlazarTech  are notably  not  compatible with the VISA standard. All Alazar digitizers are addressable by an API supplied by the company, which talks to the card through a shared library (a .dll on Windows or .so on Linux).  InstrumentAlazar  is an abstract subtype of  Instrument .  The shared library files and API documentation are only available from AlazarTech.", 
            "title": "Alazar digitizers"
        }, 
        {
            "location": "/ins_meas/#how-do-we-configure-instruments", 
            "text": "", 
            "title": "How do we configure instruments?"
        }, 
        {
            "location": "/ins_meas/#properties", 
            "text": "Instrument properties are configured and inspected using two functions,  setindex!  and  getindex , which are methods from the Base module that have been overloaded in this package to work with instrument objects. This results in a convenient and concise syntax ( credit due to Oliver Schulz  for this idea).  For example:  awg [ TriggerSlope ]   =   : Rising  awg [ SampleRate ]   =   10e6", 
            "title": "Properties"
        }, 
        {
            "location": "/ins_meas/#how-do-we-take-measurements", 
            "text": "", 
            "title": "How do we take measurements?"
        }, 
        {
            "location": "/ins_meas/#source-and-measure", 
            "text": "Two functions are provided to abstract away many kinds of measurements:  source  and  measure . In an experiment you source  some stimulus and measure a response. Therefore  source  takes as arguments: an instance of some subtype of the  Stimulus  type (which can have different fields for different subtypes), as well as the numerical value(s) for the particular stimulus.  measure  takes as argument an instance of some subtype of type  Response . The idea is to write new subtypes of  Stimulus  and  Response  to describe what you are doing, as well as new methods for  source  and  measure  that know how to communicate with the instrument(s) based on the Stimuli and Response arguments passed to them", 
            "title": "Source and measure"
        }, 
        {
            "location": "/ins_meas/#stimuli", 
            "text": "All stimuli are objects, subtyped from the abstract  Stimulus  type. Many stimuli, either general or associated with the capabilities of particular instruments, are already implemented. The implementation of each subtype depends on the specific goals of the user: demonstrations of different stimuli being used can be found in the example notebooks.  As a simple example, consider the  PropertyStimulus  type (defined in  ICCommon.jl ) :  mutable   struct   PropertyStimulus { T : InstrumentProperty }   :   Stimulus \n     typ :: Type { T } \n     ins :: Instrument     \n     tuple :: Tuple \n     axisname :: Symbol \n     axislabel :: String  end   with corresponding source method:  function   source ( ch :: PropertyStimulus ,   val ) \n     ch . ins [ ch . typ ,   ch . tuple ... ]   =   val  end   Notable among the fields  of  PropertyStimulus  are the  typ  and  ins  fields:  typ  is the instrument property the stimulus object is associated with, and  ins  is the instrument which that property corresponds to (Type{T} is a special kind of abstract type whose only instance is the object T; visit the  docs  for further discussion).  tuple  are essentially \"qualifiers\" or \"infixes\" for the instrument property. For example, if we wanted to change (source) the amplitude of a waveform in a waveform generator instrument with multiple channels, the instrument property at hand is  SourceLevel  while  tuple  would specify on  what channel  we are changing the amplitude.    Thus, this  Stimulus  object holds all the necessary information for a  source  method to change the value of instrument property  T  to any value passed to it. And the corresponding source function in fact does just that: it calls a setindex! method to change property  T  (with qualifiers  tuple ) on instrument  ins  to value  val . Again, stimuli need not be tied to a particular property; rather, this is just one convenient and easily generalizable example.  For a concrete example on the use of  PropertyStimulus , consider needing to source various frequencies in our E8257D signal generator, where the frequency of a signal generator is an instrument property called  Frequency . We can accomplish this task using  PropertyStimulus  in the following way:  stim   =   PropertyStimulus ( siggen :: E8257D ,   Frequency )  for   freq   in   1e9 : 1e8 : 5e9       # 1 GHz to 5 GHz in steps of 100 MHz \n     source ( stim ,   freq ) \n     # measure(something)  end   Easy right?  Note that one may assign whatever fields and constructor one wishes for a newly created  Stimulus  subtype. Also, note that not all stimuli need to be associated with a physical instrument. For instance, sourcing a  DelayStimulus  will cause the script to block until a specified time after creation of the  DelayStimulus  object. Moreover, a Stimulus could also be associated with several instruments. Maybe a stimulus that makes sense for a particular experiment would be to change all gate voltages at once. These gate voltages could of course be sourced by several physical instruments.", 
            "title": "Stimuli"
        }, 
        {
            "location": "/ins_meas/#responses", 
            "text": "All responses are objects, subtyped from the abstract  Response  type. Usually a response is associated with a particular instrument. The implementation of each subtype depends on the specific goals of the user: demonstrations of different response being used can be found in the example notebooks.  (put example here)  However, responses need not come from instruments. For test purposes, suppose we want to mimic a measurement by generating random numbers.  RandomResponse  produces a random number in the unit interval when it is measured. A  TimerResponse  will measure the time since creation of the  TimerResponse  object.", 
            "title": "Responses"
        }, 
        {
            "location": "/ins_meas/#difference-between-stimuli-and-instrument-properties", 
            "text": "Because a stimulus is defined so broadly, the difference between a stimulus and an instrument property is not obvious. While in many cases there is an overlap between stimuli and properties, a stimulus is like a generalized instrument property: sourcing a stimulus may entail configuring zero or more instrument properties, on zero or more different instruments. As was mentioned earlier, a useful stimulus could be to change gate voltages on multiple different instruments all at once.  It is useful to think of a stimulus as something which has a chance to react to what you are measuring. For example, this could be applied voltage, sourced by one or more instruments. The applied voltages would be seen by the device under test, which would respond accordingly. The stimulus could also just be a time delay, provided by the measurement computer. It could even be the number of threads used by Julia for real-time processing.  An instrument property is any persistent setting of an instrument. Tweaking an instrument property could affect the device under test, but it might not. Averaging is a good example. With averaging a measurement may look less noisy, but your device under test doesn't know the difference.", 
            "title": "Difference between stimuli and instrument properties"
        }, 
        {
            "location": "/sweep/", 
            "text": "Sweeps\n\n\nWhen thinking of measurement, one generally imagines measuring some dependent variable with respect to some independent variable that is swept across a range of values. While the devil is in the details of the measurement, with Julia's multiple dispatch functionality, it should be possible to abstract executing a \"sweep\" to just one function, thus affording a simple but general interface for the user to conduct his measurements.\n\n\nMoreover, the need to automate measurements and facilitate use of the same instruments by multiple users warrants some sort of queueing structure for \"sweeps\", which is maintained automatically in the background of the Julia interface that the user is using.\n\n\nWe have achieved precisely these goals in a object-oriented way with our \"Sweep\" portion of IntrumentControl.jl\" package. Below we describe the functionality meant for the user: how to use \nResponse\n and \nStimulus\n objects as well as \nsource\n and \nmeasure\n functions to submit a sweep, how to interact with the sweep job to see it's result, estimated time of completion, etc. In \nImplementation\n we describe how exactly sweep and queueing functionality is implemented\n\n\n\n\nPrerequisites for a Sweep\n\n\nA sweep is submitted by the user via the \nsweep\n function:\n\n\nsweep\n{\nN\n}(\ndep\n::\nResponse\n,\n \nindep\n::\nVararg\n{\nTuple\n{\nStimulus\n,\n \nAbstractVector\n},\n \nN\n};\n \npriority\n \n=\n \nNORMAL\n)\n\n\n\n\n\n\nsweep\n measures a response as a function of an arbitrary number of stimuli, sourced over the values given in the \nAbstractVector\n input, and returns a handle to the sweep job in the form of a \nSweepJob\n object, which will be discussed more in detail in \nImplementation\n. This can be used to access the results while the sweep is being measured. \npriority\n is an \nInt\n from 0 to \ntypemax(Int)\n, inclusive, and is used to prioritize the next sweep in a queue (with multiple sweeps) to be run. It is typically one of the following:\n\n\n\n\nHIGH == 10\n\n\nNORMAL == 5\n\n\nLOW == 0\n\n\n\n\nThus, the \npriority\n keyword argument may be \nLOW\n, \nNORMAL\n, or \nHIGH\n, or any integer greater than or equal to zero.\n\n\nThe \nsweep\n functions assumes that appropriate \nmeasure\n methods have been written for the \ndep\n object passed, and that appropriate \nsource\n methods have been written for all \nStimulus\n objects in the passed \nindep\n argument. Thus, to use the function the user must have defined \nResponse\n and \nStimulus\n subtypes, as well as \nsource\n and \nmeasure\n functions for those types.\n\n\nFor example, ... put example here with definition of \nStimulus\n, \nsource\n, \nresponse\n, \nmeasure\n, and \nsweep\n\n\n\n\nQueueing\n\n\nInstrumentControl employs a queueing structure for job handling through manipulation of \nSweepJob\n objects, which are instantiated when the \nsweep\n function is used. The actual \"queue\" is a \nSweepJobQueue\n object, described more in detail in \nImplementation\n. When the InstrumentControl package is imported by the user, a 'SweepJobQueue' object, as well as communication with the database set up by \nICDataServer.jl\n, is automatically initialized; in the documentation this object is referred to as the \"default sweep job queue object\".\n\n\nWhen \nsweep\n is used, a job ID is automatically obtained for the new sweep job (which exists in Julia as a \nSweepJob\n object) via communication with the database; the job is then put into the queue with the job ID as it's identifier. In essence, a \nSweepJobQueue\n object can be thought of as a \ncollection\n (in the Julia sense) of \nSweepJob\n objects, indexed by their job ID, along with other fields and helper functions for automatic scheduling of jobs in the background. The queue prioritizes jobs based on their priorities; for equal priority values, the job submitted earlier takes precedent.\n\n\n\n\nInteracting with a sweep job\n\n\nWhen \nsweep\n is called, the returned \nSweepJob\n object displays it's job ID as well as it's status (waiting, running, done, etc), priority, progress (percentage of job completed), and time of submission. Both the job ID and the returned \nSweepJob\n object itself can be used to interact with the job in the following ways:\n\n\n#\n\n\nBase.eta\n \n \nFunction\n.\n\n\neta(x::SweepJob)\n\n\n\n\n\nReturn the estimated time of completion for sweep job \nx\n. It estimates this time by first calculating the amount of time passed from when the job was submitted to the time the function is called, and then calculating the ETA based on the current progress of the job and this passed time\n\n\nsource\n\n\n#\n\n\nInstrumentControl.progress\n \n \nFunction\n.\n\n\nprogress(x::SweepJob)\n\n\n\n\n\nReturns the sweep job progress, a \nFloat64\n between 0 and 1 (inclusive).\n\n\nsource\n\n\n#\n\n\nInstrumentControl.jobs\n \n \nMethod\n.\n\n\njobs(job_id)\n\n\n\n\n\nReturn the \nSweepJob\n object associated with \njob_id\n scheduled in the default sweep job queue object.\n\n\nsource\n\n\n#\n\n\nInstrumentControl.result\n \n \nFunction\n.\n\n\nresult(sj::SweepJob)\n\n\n\n\n\nReturns the result array of a sweep job \nsj\n. Throws an error if the result array has not yet been initialized.\n\n\nsource\n\n\nresult(i::Integer)\n\n\n\n\n\nReturns a result array by job id in job scheduled in the default sweep job queue object.\n\n\nsource\n\n\nresult()\n\n\n\n\n\nReturns the result array from the last finished or aborted job scheduled in the default sweep job queue object.\n\n\nsource\n\n\n#\n\n\nInstrumentControl.abort!\n \n \nFunction\n.\n\n\nabort!(x::SweepJob)\n\n\n\n\n\nAbort a sweep job. Practically, the status of the job is changed to \"Aborted\", and the job is put into the update_channel of the default \nSweepJobQueue\n object. This automatically leads to: update of job metadata in the \nSweepJob\n object as well as in the ICDataServer, update of queue metadata, archiving of the job's result array, and start of the highest priority job in the default sweep job queue. Thus, aborting a job is guaranteed to bail out of the sweep in such a way that the data that has been measured for most recent sourcing of a stimulus, i.e. at the very start of a \"for loop\" in \nInstrumentControl._sweep!\n. You can also abort a sweep before it even begins.\n\n\nPresently this function does not interrupt \nmeasure\n, so if a single measurement takes a long time then the sweep is only aborted after that finishes.\n\n\nsource\n\n\nabort!()\n\n\n\n\n\nAbort the currently running job (if any). If no job is running, the method does not throw an error.\n\n\nsource\n\n\n#\n\n\nInstrumentControl.prune!\n \n \nFunction\n.\n\n\nprune!(q::SweepJobQueue)\n\n\n\n\n\nPrunes a \nSweepJobQueue\n of all \nInstrumentControl.SweepJob\ns with a status of \nDone\n or \nAborted\n. This will have the side effect of releasing old sweep results if there remain no references to them in julia, however they should still be saved to disk and can be recovered later.\n\n\nsource", 
            "title": "Sweep Jobs"
        }, 
        {
            "location": "/sweep/#sweeps", 
            "text": "When thinking of measurement, one generally imagines measuring some dependent variable with respect to some independent variable that is swept across a range of values. While the devil is in the details of the measurement, with Julia's multiple dispatch functionality, it should be possible to abstract executing a \"sweep\" to just one function, thus affording a simple but general interface for the user to conduct his measurements.  Moreover, the need to automate measurements and facilitate use of the same instruments by multiple users warrants some sort of queueing structure for \"sweeps\", which is maintained automatically in the background of the Julia interface that the user is using.  We have achieved precisely these goals in a object-oriented way with our \"Sweep\" portion of IntrumentControl.jl\" package. Below we describe the functionality meant for the user: how to use  Response  and  Stimulus  objects as well as  source  and  measure  functions to submit a sweep, how to interact with the sweep job to see it's result, estimated time of completion, etc. In  Implementation  we describe how exactly sweep and queueing functionality is implemented", 
            "title": "Sweeps"
        }, 
        {
            "location": "/sweep/#prerequisites-for-a-sweep", 
            "text": "A sweep is submitted by the user via the  sweep  function:  sweep { N }( dep :: Response ,   indep :: Vararg { Tuple { Stimulus ,   AbstractVector },   N };   priority   =   NORMAL )   sweep  measures a response as a function of an arbitrary number of stimuli, sourced over the values given in the  AbstractVector  input, and returns a handle to the sweep job in the form of a  SweepJob  object, which will be discussed more in detail in  Implementation . This can be used to access the results while the sweep is being measured.  priority  is an  Int  from 0 to  typemax(Int) , inclusive, and is used to prioritize the next sweep in a queue (with multiple sweeps) to be run. It is typically one of the following:   HIGH == 10  NORMAL == 5  LOW == 0   Thus, the  priority  keyword argument may be  LOW ,  NORMAL , or  HIGH , or any integer greater than or equal to zero.  The  sweep  functions assumes that appropriate  measure  methods have been written for the  dep  object passed, and that appropriate  source  methods have been written for all  Stimulus  objects in the passed  indep  argument. Thus, to use the function the user must have defined  Response  and  Stimulus  subtypes, as well as  source  and  measure  functions for those types.  For example, ... put example here with definition of  Stimulus ,  source ,  response ,  measure , and  sweep", 
            "title": "Prerequisites for a Sweep"
        }, 
        {
            "location": "/sweep/#queueing", 
            "text": "InstrumentControl employs a queueing structure for job handling through manipulation of  SweepJob  objects, which are instantiated when the  sweep  function is used. The actual \"queue\" is a  SweepJobQueue  object, described more in detail in  Implementation . When the InstrumentControl package is imported by the user, a 'SweepJobQueue' object, as well as communication with the database set up by  ICDataServer.jl , is automatically initialized; in the documentation this object is referred to as the \"default sweep job queue object\".  When  sweep  is used, a job ID is automatically obtained for the new sweep job (which exists in Julia as a  SweepJob  object) via communication with the database; the job is then put into the queue with the job ID as it's identifier. In essence, a  SweepJobQueue  object can be thought of as a  collection  (in the Julia sense) of  SweepJob  objects, indexed by their job ID, along with other fields and helper functions for automatic scheduling of jobs in the background. The queue prioritizes jobs based on their priorities; for equal priority values, the job submitted earlier takes precedent.", 
            "title": "Queueing"
        }, 
        {
            "location": "/sweep/#interacting-with-a-sweep-job", 
            "text": "When  sweep  is called, the returned  SweepJob  object displays it's job ID as well as it's status (waiting, running, done, etc), priority, progress (percentage of job completed), and time of submission. Both the job ID and the returned  SweepJob  object itself can be used to interact with the job in the following ways:  #  Base.eta     Function .  eta(x::SweepJob)  Return the estimated time of completion for sweep job  x . It estimates this time by first calculating the amount of time passed from when the job was submitted to the time the function is called, and then calculating the ETA based on the current progress of the job and this passed time  source  #  InstrumentControl.progress     Function .  progress(x::SweepJob)  Returns the sweep job progress, a  Float64  between 0 and 1 (inclusive).  source  #  InstrumentControl.jobs     Method .  jobs(job_id)  Return the  SweepJob  object associated with  job_id  scheduled in the default sweep job queue object.  source  #  InstrumentControl.result     Function .  result(sj::SweepJob)  Returns the result array of a sweep job  sj . Throws an error if the result array has not yet been initialized.  source  result(i::Integer)  Returns a result array by job id in job scheduled in the default sweep job queue object.  source  result()  Returns the result array from the last finished or aborted job scheduled in the default sweep job queue object.  source  #  InstrumentControl.abort!     Function .  abort!(x::SweepJob)  Abort a sweep job. Practically, the status of the job is changed to \"Aborted\", and the job is put into the update_channel of the default  SweepJobQueue  object. This automatically leads to: update of job metadata in the  SweepJob  object as well as in the ICDataServer, update of queue metadata, archiving of the job's result array, and start of the highest priority job in the default sweep job queue. Thus, aborting a job is guaranteed to bail out of the sweep in such a way that the data that has been measured for most recent sourcing of a stimulus, i.e. at the very start of a \"for loop\" in  InstrumentControl._sweep! . You can also abort a sweep before it even begins.  Presently this function does not interrupt  measure , so if a single measurement takes a long time then the sweep is only aborted after that finishes.  source  abort!()  Abort the currently running job (if any). If no job is running, the method does not throw an error.  source  #  InstrumentControl.prune!     Function .  prune!(q::SweepJobQueue)  Prunes a  SweepJobQueue  of all  InstrumentControl.SweepJob s with a status of  Done  or  Aborted . This will have the side effect of releasing old sweep results if there remain no references to them in julia, however they should still be saved to disk and can be recovered later.  source", 
            "title": "Interacting with a sweep job"
        }, 
        {
            "location": "/implementation/", 
            "text": "Implementation overview\n\n\n\n\nCode organization\n\n\n\n\nEach instrument is defined within its own module, a submodule of \nInstrumentControl\n.\n\n\n\n\nEach instrument is a subtype of \nInstrument\n. By convention, instrument model numbers are used for module definitions (e.g. \nAWG5014C\n), so type names have \"Ins\" prepended (e.g. \nInsAWG5014\n).\n\n\n\n\nLow-level wrappers for shared libraries are kept in their own packages (e.g. \nVISA\n, \nAlazar\n, and \nKeysightInstruments\n calls).\n\n\n\n\nThis way, at least some code can be reused if someone else does not want to use our codebase.\n\n\n\n\nAll sweep related type definitions and functions described in \nSweep Jobs\n\n\n\n\ncan be found in \nsrc/Sweep.jl\n\n\n\n\nAbstract type definitions like \nInstrument\n and \nStimulus\n, are defined in\n\n\n\n\nICCommon.jl\n  \n\n\n\n\nsrc/Definitions.jl\n contains some definitions of other commonly used functions\n\n\n\n\nand types. \nsrc/config.jl\n parses information in \ndeps/config.json\n for talking to the database set up by ICDataServer, such as username information, database server address, path for saving results of sweeps, and stores it in a dictionary for access to all other functions that need this information to communicate with the database\n\n\n\n\nCommunication with ICDataServer\n\n\nThe functionality of the InstrumentControl.jl package is intertwined with the \nICDataServer.jl\n package. ICDataServer sets up a relational database (RDBMS) with which it communicates with through SQL. InstrumentControl talks to that database; this database is used to maintain a log of information for each job: the job is identified by the job ID, and it mantains any metadata specified by the database creator. In its current implementation, the data saved to the database is the time of job submission, the time of job completion, and the latest job status, but we hope to add more logging functionality to the code over time.\n\n\nWhen \nsweep\n is executed, the function communicates with the ICDataServer to create a new entry in the database table; the identifier of the new entry is a new job ID that the RDMS itself creates. ICDataServer then communicates back to InstrumentControl with this particular job ID and the time of submission; this job metadata is immediately stored in the \nSweepJob\n object (created by the \nsweep\n function as a handle to the new job). The job is then queued with the provided job ID as it's identifier.\n\n\nThe actual communication between the two packages is mediated by the popular \nZeroMQ\n distributed messaging software; we utilize it's \nZMQ\n Julia interface. While the reader is encouraged to go to these links for in-depth information, what you essentially need to communicate between a client and a server with ZeroMQ is a \nContext\n and a \nsocket\n. In Julia, a \nZMQ.Context\n object provides the framework for communication via a TCP connection (or any analagous form of communication). The client and server respectively will connect to a TCP port to send/receive information. The point of entry/exit for information being passed along this TCP connection are the ZMQ.Socket objects; they \"bind\" to the TCP ports and are the objects that the user actually calls on the send and receive information.\n\n\nWhen InstrumentControl is imported, a \nZMQ.Context\n object is automatically initialized. \nZMQ.Socket\n objects are initialized in the first instance of communication with the ICDataServer, and the same object is used thereafter for communication within the same usage session. The socket objects are automatically bound to TCP ports that the user specifies in the \ndeps/config.json\n file. InstrumentControl and ICDataServer communicate by binding to the same TCP connection.\n\n\n\n\nMetaprogramming for VISA instruments\n\n\nMany commercial instruments support a common communications protocol and command syntax (VISA and SCPI respectively). For such instruments, methods for \nsetindex!\n and \ngetindex\n, as well as \nInstrument\n subtype and \nInstrumentProperty\n subtype definitions, can be generated with metaprogramming, rather than typing them out explicitly.\n\n\nThe file \nsrc/MetaprogrammingVISA.jl\n is used heavily for code generation based on JSON template files. Since much of the logic for talking to instruments is the same between VISA instruments, in some cases no code needs to be written to control a new instrument provided an appropriate template file is prepared. The metaprogramming functions are described below although they are not intended to be used interactively.\n\n\n#\n\n\nInstrumentControl.insjson\n \n \nFunction\n.\n\n\ninsjson(file::AbstractString)\n\n\n\n\n\nParses a JSON file with a standardized schema to describe how to control an instrument.\n\n\nHere is an example of a valid JSON file with valid schema for parsing:\n\n\n{\n\n    \ninstrument\n:{\n\n            \nmodule\n:\nE5071C\n,\n\n            \ntype\n:\nInsE5071C\n,\n\n            \nmake\n:\nKeysight\n,\n\n            \nmodel\n:\nE5071C\n,\n\n            \nwriteterminator\n:\n\\n\n\n    \n},\n\n    \nproperties\n:[\n\n        \n{\n\n            \ncmd\n:\n:CALCch:TRACtr:CORR:EDEL:TIME\n,\n\n            \ntype\n:\nVNA.ElectricalDelay\n,\n\n            \nvalues\n:[\n\n                \nv::Real\n\n            \n],\n\n            \ninfixes\n:[\n\n                \nch::Integer=1\n,\n\n                \ntr::Integer=1\n\n            \n],\n\n            \ndoc\n:\n \nMy documentation\n\n        \n}\n\n    \n]\n\n\n}\n\n\n\n\n\n\nJSON.parse\n takes such a file and makes an 'instrument' dictionary and a 'properties' array. The \ninstrument\n dictionary is described in the \n@generate_instruments\n documentation. The \nproperties\n array contains one or more dictionaries, each with keys:\n\n\n\n\ncmd\n: Specifies what must be sent to the instrument (it should be terminated\n\n\n\n\nwith \"?\" for query-only commands). The lower-case characters are replaced by \"infixes\", which are either numerical arguments or strings\n\n\n\n\ntype\n: Specifies the \nInstrumentProperty\n subtype to use \ncmd\n.\n\n\nvalues\n: Specifies the required argument for \nsetindex!\n, which will appear\n\n\n\n\nafter \ncmd\n in the string sent to the instrument.\n\n\n\n\ninfixes\n: Specifies the infix arguments to be put in \ncmd\n. This key is not\n\n\n\n\nrequired if there are no infixes.\n\n\n\n\ndoc\n: Specifies documentation for the generated Julia functions. This key\n\n\n\n\nis not required if there is no documentation. This is used not only for interactive help but also in generating the documentation you are reading.\n\n\nThe value of the \nproperties.type\n field and entries in the \nproperties.values\n and \nproperties.infixes\n arrays are parsed into expressions or symbols for further manipulation. All generated dictionary keys are also converted to symbols for further manipulation.\n\n\nsource\n\n\n#\n\n\nInstrumentControl.@generate_instruments\n \n \nMacro\n.\n\n\n@generate_instruments(metadata)\n\n\n\n\n\nThis macro takes a dictionary of metadata, typically obtained from a call to \ninsjson\n. It operates on the \n:instrument\n field of the dictionary which is expected to have the following structure:\n\n\n\n\nmodule\n: The module name. Can already exist but is created if it does not.\n\n\n\n\nThis field is converted from a string to a \nSymbol\n by \ninsjson\n.\n\n\n\n\ntype\n: The name of the type to create for the new instrument.\n\n\n\n\nThis field is converted from a string to a \nSymbol\n by \ninsjson\n.\n\n\n\n\nsuper\n: This field is optional. If provided it will be the supertype of\n\n\n\n\nthe new instrument type, otherwise the supertype will be \nInstrument\n. This field is converted from a string to a \nSymbol\n by \ninsjson\n.\n\n\n\n\nmake\n: The make of the instrument, e.g. Keysight, Tektronix, etc.\n\n\nmodel\n: The model of the instrument, e.g. E5071C, AWG5014C, etc.\n\n\nwriteterminator\n: Write termination string for sending SCPI commands.\n\n\n\n\nThe macro imports required modules and methods, defines and exports the \nInstrument\n subtype, and defines and exports and the \nmake\n and \nmodel\n methods if they do not exist already (note generic functions \nmake\n and \nmodel\n are defined in \nsrc/Definitions.jl\n).\n\n\nBy convention we typically have the module name be the same as the model name, and the type is just the model prefixed by \"Ins\", e.g. \nInsE5071C\n. This is not required.\n\n\nsource\n\n\n#\n\n\nInstrumentControl.@generate_properties\n \n \nMacro\n.\n\n\n@generate_properties(metadata)\n\n\n\n\n\nThis macro takes a dictionary of metadata, typically obtained from a call to \ninsjson\n. It operates on the \n:properties\n field of the dictionary, which is expected to be a list of dictionaries with information on each \"property\" of the instrument. This macro specifically operates on the \n:type\n field of each property dictionary; this field contains the name of the type we would like to assign to a given property of the instrument.\n\n\nFor every property dictionary, the macro first checks if a type with name corresponding to the dictionary's \n:type\n field  has already been defined. If not, it then defines an abstract type with that name, and makes it a subtype of the \nInstrumentProperty\n type defined in the ICCommon package. The macro then finally exports that type\n\n\nsource\n\n\n#\n\n\nInstrumentControl.@generate_handlers\n \n \nMacro\n.\n\n\n@generate_handlers(instype, p)\n\n\n\n\n\nThis macro takes a symbol \ninstype\n bound to an \nInstrument\n subtype (i.e. if the symbol was evaluated, it would return an \nInstrument\n subtype ), and a property dictionary \np\n located in the \n:properties\n field of the dictionary of metadata generated by a call to \ninsjson\n. with the auxiliary JSON file described above.\n\n\nThis macro is written to handle the cases where an instrument command does not accept numerical arguments, but rather a small set of options. Here is an example of the property dictionary (prior to parsing) for such a command, which sets/gets the format for a given channel and trace on the E5071C vector network analyzer:\n\n\n{\n\n    \ncmd\n:\n:CALCch:TRACtr:FORM\n,\n\n    \ntype\n:\nVNAFormat\n,\n\n    \nvalues\n:[\n\n        \nv::Symbol in symbols\n\n    \n],\n\n    \nsymbols\n:{\n\n        \nLogMagnitude\n:\nMLOG\n,\n\n        \nPhase\n:\nPHAS\n,\n\n        \nGroupDelay\n:\nGDEL\n,\n\n        \nSmithLinear\n:\nSLIN\n,\n\n        \nSmithLog\n:\nSLOG\n,\n\n        \nSmithComplex\n:\nSCOM\n,\n\n        \nSmith\n:\nSMIT\n,\n\n        \nSmithAdmittance\n:\nSADM\n,\n\n        \nPolarLinear\n:\nPLIN\n,\n\n        \nPolarLog\n:\nPLOG\n,\n\n        \nPolarComplex\n:\nPOL\n,\n\n        \nLinearMagnitude\n:\nMLIN\n,\n\n        \nSWR\n:\nSWR\n,\n\n        \nRealPart\n:\nREAL\n,\n\n        \nImagPart\n:\nIMAG\n,\n\n        \nExpandedPhase\n:\nUPH\n,\n\n        \nPositivePhase\n:\nPPH\n\n    \n},\n\n    \ninfixes\n:[\n\n        \nch::Integer=1\n,\n\n        \ntr::Integer=1\n\n    \n],\n\n    \ndoc\n:\nHey\n\n\n}\n\n\n\n\n\n\nWe see here that the \nvalues\n key is saying that we are only going to accept \nSymbol\n type for our \nsetindex!\n method and the symbol has to come out of \nsymbols\n, a dictionary that is defined on the next line. The keys of this dictionary are going to be interpreted as symbols (e.g. \n:LogMagnitude\n) and the values are just ASCII strings to be sent to the instrument. We want to associate these symbols with the specific ASCII strings because these strings are not very descriptive, so we would like a more descriptive handle for them, as well as a handle that could be potentially shared between different instruments which have different \"spellings\" for the same command. We make the handles symbols because they are a more flexible type (which can always be parsed into strings)\n\n\ngenerate_handlers\n makes a bidirectional mapping between the symbols and the strings. For the example above, the macro defines the following functions:\n\n\nfunction\n \nsymbols\n(\nins\n::\nInsE5071C\n,\n \n::\nType\n{\nVNAFormat\n},\n \nv\n::\nSymbol\n)\n\n    \nif\n \nv\n \n==\n \n:\nLogMagnitude\n\n      \nMLOG\n\n    \nelse\n\n      \nif\n \nv\n \n==\n \n:\nPhase\n\n        \nPHAS\n\n      \nelse\n...\n\n\n        \nelse\n\n          \nerror\n(\nunexpected input.\n)\n\n    \nend\n\n\nend\n\n\n\nfunction\n \nVNAFormat\n(\nins\n::\nInsE5071C\n,\n \ns\n::\nAbstractString\n)\n\n    \nif\n \ns\n \n==\n \nMLOG\n\n      \n:\nLogMagnitude\n\n    \nelse\n\n      \nif\n \ns\n \n==\n \nPHAS\n\n        \n:\nPhase\n\n      \nelse\n...\n\n\n\n        \nelse\n\n          \nerror\n(\nunexpected input.\n)\n\n    \nend\n\n\nend\n\n\n\n\n\n\nThe above functions will be defined in the module where the macro is run. Note that the function \nsymbols\n has its name chosen based on the dictionary name in the JSON file. Since this function is not exported from the instrument's module there should be few namespace worries and we maintain future flexibliity.\n\n\nsource\n\n\n#\n\n\nInstrumentControl.@generate_configure\n \n \nMacro\n.\n\n\n@generate_configure(instype, p)\n\n\n\n\n\nThis macro takes a symbol \ninstype\n bound to an \nInstrument\n subtype (i.e. if the symbol was evaluated, it would return an \nInstrument\n subtype ), and a property dictionary \np\n located in the \n:properties\n field of the dictionary of metadata generated by a call to \ninsjson\n. with the auxiliary JSON file described above.\n\n\nThis macro overloads the base method \nsetindex!\n. In this implementation of \nsetindex!\n, the instrument acts as the collection, the key is the InstrumentProperty type defined from the \n:type\n field of the \np\n dictionary, and the value is specified by the user. This method also takes infix arguments; infixes are currently implemented as keyword arguments, so the \nsetindex!\n method applies some standard infixes if none are specified by the user.\n\n\nThe method constructs a configuration command to send to the instrument to change the specific instrument property the dictionary \np\n corresponds to (with user specified infixes). The command has \"#\" in place of the (user specified) value the property will be set to. It then sends the command to the instrument with the \nwrite\n method (NOTE: currently only defined in the VISA module for VISA instruments) where the command and the user-specified property value are passed to it. The \nwrite\n method replaces \"#\" with the proper value, and sends the command to the instrument\n\n\nThe macro accomplishes this by constructing and evaluating (approximately) the following expression:\n\n\nfunction\n \nsetindex\n!\n(\nins\n::\ninstype\n,\n \nv\n::\nvalues_Type\n,\n \n::\nType\n{\np\n[\n:\ntype\n]},\n \ninfixes_keyword_args\n)\n\n  \ncommand\n=\np\n[\n:\ncmd\n]\n\n  \ncommand\n*\n #\n\n  \ncmd\n\u00a0\n=\n\u00a0\nreplace\n(\ncmd\n,\n\u00a0\ninfix_name\n,\n\u00a0\ninfix_keyword_arg1\n)\n\n  \ncmd\n\u00a0\n=\n\u00a0\nreplace\n(\ncmd\n,\n\u00a0\ninfix_name\n,\n\u00a0\ninfix_keyword_arg2\n)\n\n  \n...\n \n#\netc\n\n  \n...\nmanipulation\n \nof\n \ninput\n \nv\n \ninto\n \nformat\n \ninstrument\n \naccepts\n\n  \nwrite\n(\nins\n,\ncmd\n,\nv\n)\n\n\nend\n\n\n\n\n\n\nThe function should be defined in the module where the instrument type was defined.\n\n\nsource\n\n\n#\n\n\nInstrumentControl.@generate_inspect\n \n \nMacro\n.\n\n\n@generate_inspect(instype, p)\n\n\n\n\n\nThis macro takes a symbol \ninstype\n bound to an \nInstrument\n subtype (i.e. if the symbol was evaluated, it would return an \nInstrument\n subtype ), and a property dictionary \np\n located in the \n:properties\n field of the dictionary of metadata generated by a call to \ninsjson\n. with the auxiliary JSON file described above.\n\n\nThis macro overloads the base method \ngetindex\n. In this implementation of \ngetindex\n, the instrument acts as the collection, and the key is the InstrumentProperty type defined from the \n:type\n field of the \np\n dictionary. This method also takes infix arguments; infixes are currently implemented as keyword arguments, so the \ngetindex\n method applies some standard infixes if none are specified by the user.\n\n\nThe method constructs a query command to send to the instrument regarding the specific instrument property the dictionary \np\n corresponds to. It then sends the command to the instrument with the \nask\n method (NOTE: currently defined in the VISA module for VISA instruments). The \nask\n method returns the value or state of the instrument property being queried.\n\n\nThe macro accomplishes this by constructing and evaluating (approximately) the following expression:\n\n\nfunction\n \ngetindex\n(\nins\n::\ninstype\n,\n \n::\nType\n{\np\n[\n:\ntype\n]},\n \ninfixes_keyword_args\n)\n\n  \ncommand\n=\np\n[\n:\ncmd\n]\n\n  \ncommand\n[\nend\n]\n \n!=\n \n?\n \n \n(\ncommand\n \n*=\n \n?\n)\n\n  \ncmd\n\u00a0\n=\n\u00a0\nreplace\n(\ncmd\n,\n\u00a0\ninfix_name\n,\n\u00a0\ninfix_keyword_arg1\n)\n\n  \ncmd\n\u00a0\n=\n\u00a0\nreplace\n(\ncmd\n,\n\u00a0\ninfix_name\n,\n\u00a0\ninfix_keyword_arg2\n)\n\n  \n...\n \n#\netc\n\n  \nask\n(\nins\n,\ncmd\n)\n\n  \n...\nfurther\n \nmanipulation\n \nof\n \noutput\n \nfor\n \ndisplay\n\n\nend\n\n\n\n\n\n\nThe function should be defined in the module where the instrument type was defined.\n\n\nsource\n\n\n\n\nSweep, Sweep Jobs, and Sweep Queueing implementation\n\n\nWe stratify InstrumentControl \"sweeps\" functionality into different types, along with helper functions for each type, in order to achieve a object-oriented architecture with code modularity.\n\n\nMeasurement specific information, such as what independent variables will be swept and what response will be measured, are contained in a \nSweep\n type:\n\n\n#\n\n\nInstrumentControl.Sweep\n \n \nType\n.\n\n\nmutable struct Sweep\n    dep::Response\n    indep::Tuple{Tuple{Stimulus, AbstractVector}}\n    result::AxisArray\n    Sweep(a,b) = new(a,b)\n    Sweep(a,b,c) = new(a,b,c)\nend\n\n\n\n\n\nObject representing a sweep; which will contain information on stimuli sent to the instruments, information on what kind of response we will be measuring, and the numerical data obtained from the measurement. \ndep\n (short for dependent) is a \nResponse\n that will be measured. \nindep\n is a tuple of \nStimulus\n objects and the values they will be sourced over. \nresult\n is the result array of the sweep, which need not be provided at the time the \nSweep\n object is created.\n\n\nsource\n\n\nHowever, additional metadata is needed for scheduling and queueing of sweeps, as well as logging of job information on ICDataServer. We \"bundle\" that information, along with a \nSweep\n object, in a more comprehensive \nSweepJob\n type:\n\n\nInstrumentControl.SweepJob\nInstrumentControl.SweepJob()\n\n\n\n\n\nFinally, we require a \ncollection\n object that can hold \nSweepJob\n objects, and sort them by job priority, in addition to having  functionality for  automatic scheduling of jobs in the background. For this purpose we define the \nSweepJobQueue\n type, as well as a initialization inner constructor.\n\n\n#\n\n\nInstrumentControl.SweepJobQueue\n \n \nType\n.\n\n\nmutable struct SweepJobQueue\n    #PriorityQueue is essentially a glorified dictionary with built-in functionality\n    #for sorting of keys\n    q::PriorityQueue{Int,SweepJob,\n        Base.Order.ReverseOrdering{Base.Order.ForwardOrdering}}\n    running_id::Channel{Int}\n    last_finished_id::Channel{Int}\n    trystart::Condition #used to communicate with the job_starter function\n    update_taskref::Ref{Task} #used to communicate with the job_updater function\n    update_channel::Channel{SweepJob} #channel for communicating with the job_updater function\n    function SweepJobQueue()\n        sjq = new(PriorityQueue(Int[],SweepJob[],Base.Order.Reverse),\n            Channel{Int}(1), Channel{Int}(1), Condition())\n        put!(sjq.running_id, -1)\n        put!(sjq.last_finished_id,-1)\n        sjq.update_taskref = Ref{Task}() #initializing a pointer for a task\n        sjq.update_channel = Channel(t-\njob_updater(sjq, t);\n            ctype = SweepJob, taskref=sjq.update_taskref)\n        #the job_updater function is wrapped in a Task through this Channel constructor\n        @schedule job_starter(sjq) #the job_started function is wrapped in a Task here\n        sjq\n    end\nend\n\n\n\n\n\nA queue responsible for prioritizing sweeps and executing them accordingly. The queue holds \nSweepJob\n objects, and \"indexes\" them by their \njob_id\n. It prioritizes jobs based on their priorities; for equal priority values, the job submitted earlier takes precedent. The queue keeps track of which job is running (if any) by its \nrunning_id\n \nChannel\n. The queue keeps track of the last finished job by the \nlast_finished_id\n channel, for easy access to the data of the last finished job. Other fields are used for intertask communication. Note that a \nrunning_id of\n -1 signifies that no job is running.\n\n\nWhen a \nSweepJobQueue\n is created through it's argumentless inner constructor (made for initialization purposes), two tasks are initialized. One task manages job updates, the other task is responsible for starting jobs; the former task executes the \njob_updater\n function, the latter task executes the \njob_starter\n function. Both functions execute infinite while loops, therefore they never end.\n\n\nWhen the job starter task is notified with the \ntrystart::Condition\n object in the \nSweepJobQueue\n object, it will find the highest priority job in the queue. Then, if a job is not running, and the prioritized job is waiting, and if the prioritized job is runnable (the priority may be \"NEVER\"), then the job is started. The database is updated asynchronously to reflect the new job, the queue's \nrunning_id\n is changed to the job's id, and the job's status is changed to \"Running\".\n\n\nThe job updater task tries to take a \nSweepJob\n from \nupdate_channel\n, the unbuffered job \nChannel\n of the \nSweepJobQueue\n object. The task is blocked until a job is put into the channel. Once a job arrives, provided the job has finished or has been aborted, the database is asynchronously updated, the job is marked as no longer running (by updating the \nrunning_id\n and \nlast_finished_id\n channels), the sweep result is asynchronously saved to disk, and finally the job starter task is notified through the queue's \ntrystart\n \nCondition\n object. The job updater task loops around and waits for another job to arrive at its channel.\n\n\nsource\n\n\n#\n\n\nInstrumentControl.job_updater\n \n \nFunction\n.\n\n\njob_updater(sjq::SweepJobQueue, update_channel::Channel{SweepJob})\n\n\n\n\n\nUsed when a sweep job finishes; archieves the result of the finished sweep job, updates all job and queue metadata, asynchronously updates ICDataServer, and notifies the job_starter task to run through \nsjq\n's \ntrystart\n \nCondition\n object. This function continuously runs continuously without stopping once called. In its current implementation, this function is executed through a Task when a \nSweepJobQueue\n object is initialized; this allows the function to be stopped and recontinued asynchronously as is appropriate.\n\n\nThe function first waits until the update_channel is populated with a job. Once a job arrives, the function takes the job from the channel, and given that it's status is \"Done\" or \"Aborted\", it executes the items described above\n\n\nsource\n\n\n#\n\n\nInstrumentControl.job_starter\n \n \nFunction\n.\n\n\njob_starter(sjq::SweepJobQueue)\n\n\n\n\n\nUsed when starting a new sweep job. The function first obtains the highest priority job in \nsjq\n; and given that a job is not running, it's status is \"Waiting\", and if the prioritized job is runnable (the priority may be \"never\"), then the job is started. The function updates all job and queue metadata and asynchronously updates ICDataServer. This function continuously runs continuously without stopping once called. In its current implementation, this function is executed through a Task when a \nSweepJobQueue\n object is initialized; this allows the function to be stopped and recontinued asynchronously as is appropriate.\n\n\nThe last thing the function does is change the job status to \"Running\". When a job is scheduled with the sweep function, the sweep function waits for the status of the job to be changed from \"Waiting\" to start sourcing the instruments and performing measurements\n\n\nsource\n\n\nWhen InstrumentControl is imported, a default 'SweepJobQueue' object is instantiated via the \nSweepJobQueue()\n constructor, and associated with a pointer called \nsweepjobqueue\n. This is THE queue running in the background automatically scheduling jobs, and referred to as the \"default sweep job queue object\" in the documentation. This object can be returned by the following function:\n\n\n#\n\n\nInstrumentControl.jobs\n \n \nMethod\n.\n\n\njobs()\n\n\n\n\n\nReturns the default \nSweepJobQueue\n object, initialized when the InstrumentControl module is imported/used. All jobs are scheduled in this object. Typically you call this to see what jobs are waiting, aborted, or finished, and what job is running.\n\n\nsource\n\n\nSweeps are scheduled by a call to the \nsweep\n function:\n\n\n#\n\n\nInstrumentControl.sweep\n \n \nFunction\n.\n\n\nsweep\n{\nN\n}\n(\ndep\n::\nResponse\n,\n \nindep\n::\nVararg\n{\nTuple{Stimulus,\n \nAbstractVector\n}\n,\n \nN\n}\n;\n\n    \npriority\n \n=\n \nNORMAL\n)\n\n\n\n\n\n\nsweep\n measures a response as a function of an arbitrary number of stimuli, sourced over the values given in the \nAbstractVector\n input, and returns a handle to the sweep job. This can be used to access the results while the sweep is being measured.\n\n\nThis function is responsible for 1) initialzing sockets for communication with the ICDataServer, 2) initializing an appropriate array to hold the reults of the sweep,\n\n\n\n\npreparing a \nInstrumentControl.SweepJob\n object with an appropriate \njob_id\n\n\n\n\nobtained from the database, 4) adding the job to the default \nSweepJobQueue\n object (defined when the InstrumentControl module is used/imported), and 5) launching an asynchronous sweep job.\n\n\nThe \npriority\n keyword may be \nLOW\n, \nNORMAL\n, or \nHIGH\n, or any integer greater than or equal to zero.\n\n\nThe actual sweeping, i.e., the actual \nsource\n and \nmeasure\n loops to measure data are in a private function \nInstrumentControl._sweep!\n. Note that if \nInstrumentControl._sweep!\n is not defined yet, this function will also define the method in order to it to be used to schedule a sweep.\n\n\nsource\n\n\n#\n\n\nInstrumentControl._sweep!\n \n \nFunction\n.\n\n\n_sweep!(::Val{D}, ::Val{N}, sj, update_channel)\n\n\n\n\n\nThis is a private function which should not be called directly by the user. It is launched asynchronously by \nsweep\n. The implementation uses macros from \nBase.Cartesian\n. The stimuli are sourced only when they need to be, at the start of each \nfor\n loop level.\n\n\nD\n is the dimension of the output array of the measure function (if multiple things are measured for one Response type, the array will be multi-dimensional). \nN\n is the number of stimuli which the sweep sources over. sj is the handle to the \nSweepJob\n object, and update_channel is a channel of the queue used for intertask comunication.\n\n\nThe axis scaling of \nmeasure(sj.sweep.dep)\n, i.e., the dimensions of the output array of the function. is presumed to be fixed, as it is only looked at once, the first time \nmeasure\n is called.\n\n\nsource", 
            "title": "Implementation"
        }, 
        {
            "location": "/implementation/#implementation-overview", 
            "text": "", 
            "title": "Implementation overview"
        }, 
        {
            "location": "/implementation/#code-organization", 
            "text": "Each instrument is defined within its own module, a submodule of  InstrumentControl .   Each instrument is a subtype of  Instrument . By convention, instrument model numbers are used for module definitions (e.g.  AWG5014C ), so type names have \"Ins\" prepended (e.g.  InsAWG5014 ).   Low-level wrappers for shared libraries are kept in their own packages (e.g.  VISA ,  Alazar , and  KeysightInstruments  calls).   This way, at least some code can be reused if someone else does not want to use our codebase.   All sweep related type definitions and functions described in  Sweep Jobs   can be found in  src/Sweep.jl   Abstract type definitions like  Instrument  and  Stimulus , are defined in   ICCommon.jl      src/Definitions.jl  contains some definitions of other commonly used functions   and types.  src/config.jl  parses information in  deps/config.json  for talking to the database set up by ICDataServer, such as username information, database server address, path for saving results of sweeps, and stores it in a dictionary for access to all other functions that need this information to communicate with the database", 
            "title": "Code organization"
        }, 
        {
            "location": "/implementation/#communication-with-icdataserver", 
            "text": "The functionality of the InstrumentControl.jl package is intertwined with the  ICDataServer.jl  package. ICDataServer sets up a relational database (RDBMS) with which it communicates with through SQL. InstrumentControl talks to that database; this database is used to maintain a log of information for each job: the job is identified by the job ID, and it mantains any metadata specified by the database creator. In its current implementation, the data saved to the database is the time of job submission, the time of job completion, and the latest job status, but we hope to add more logging functionality to the code over time.  When  sweep  is executed, the function communicates with the ICDataServer to create a new entry in the database table; the identifier of the new entry is a new job ID that the RDMS itself creates. ICDataServer then communicates back to InstrumentControl with this particular job ID and the time of submission; this job metadata is immediately stored in the  SweepJob  object (created by the  sweep  function as a handle to the new job). The job is then queued with the provided job ID as it's identifier.  The actual communication between the two packages is mediated by the popular  ZeroMQ  distributed messaging software; we utilize it's  ZMQ  Julia interface. While the reader is encouraged to go to these links for in-depth information, what you essentially need to communicate between a client and a server with ZeroMQ is a  Context  and a  socket . In Julia, a  ZMQ.Context  object provides the framework for communication via a TCP connection (or any analagous form of communication). The client and server respectively will connect to a TCP port to send/receive information. The point of entry/exit for information being passed along this TCP connection are the ZMQ.Socket objects; they \"bind\" to the TCP ports and are the objects that the user actually calls on the send and receive information.  When InstrumentControl is imported, a  ZMQ.Context  object is automatically initialized.  ZMQ.Socket  objects are initialized in the first instance of communication with the ICDataServer, and the same object is used thereafter for communication within the same usage session. The socket objects are automatically bound to TCP ports that the user specifies in the  deps/config.json  file. InstrumentControl and ICDataServer communicate by binding to the same TCP connection.", 
            "title": "Communication with ICDataServer"
        }, 
        {
            "location": "/implementation/#metaprogramming-for-visa-instruments", 
            "text": "Many commercial instruments support a common communications protocol and command syntax (VISA and SCPI respectively). For such instruments, methods for  setindex!  and  getindex , as well as  Instrument  subtype and  InstrumentProperty  subtype definitions, can be generated with metaprogramming, rather than typing them out explicitly.  The file  src/MetaprogrammingVISA.jl  is used heavily for code generation based on JSON template files. Since much of the logic for talking to instruments is the same between VISA instruments, in some cases no code needs to be written to control a new instrument provided an appropriate template file is prepared. The metaprogramming functions are described below although they are not intended to be used interactively.  #  InstrumentControl.insjson     Function .  insjson(file::AbstractString)  Parses a JSON file with a standardized schema to describe how to control an instrument.  Here is an example of a valid JSON file with valid schema for parsing:  { \n     instrument :{ \n             module : E5071C , \n             type : InsE5071C , \n             make : Keysight , \n             model : E5071C , \n             writeterminator : \\n \n     }, \n     properties :[ \n         { \n             cmd : :CALCch:TRACtr:CORR:EDEL:TIME , \n             type : VNA.ElectricalDelay , \n             values :[ \n                 v::Real \n             ], \n             infixes :[ \n                 ch::Integer=1 , \n                 tr::Integer=1 \n             ], \n             doc :   My documentation \n         } \n     ]  }   JSON.parse  takes such a file and makes an 'instrument' dictionary and a 'properties' array. The  instrument  dictionary is described in the  @generate_instruments  documentation. The  properties  array contains one or more dictionaries, each with keys:   cmd : Specifies what must be sent to the instrument (it should be terminated   with \"?\" for query-only commands). The lower-case characters are replaced by \"infixes\", which are either numerical arguments or strings   type : Specifies the  InstrumentProperty  subtype to use  cmd .  values : Specifies the required argument for  setindex! , which will appear   after  cmd  in the string sent to the instrument.   infixes : Specifies the infix arguments to be put in  cmd . This key is not   required if there are no infixes.   doc : Specifies documentation for the generated Julia functions. This key   is not required if there is no documentation. This is used not only for interactive help but also in generating the documentation you are reading.  The value of the  properties.type  field and entries in the  properties.values  and  properties.infixes  arrays are parsed into expressions or symbols for further manipulation. All generated dictionary keys are also converted to symbols for further manipulation.  source  #  InstrumentControl.@generate_instruments     Macro .  @generate_instruments(metadata)  This macro takes a dictionary of metadata, typically obtained from a call to  insjson . It operates on the  :instrument  field of the dictionary which is expected to have the following structure:   module : The module name. Can already exist but is created if it does not.   This field is converted from a string to a  Symbol  by  insjson .   type : The name of the type to create for the new instrument.   This field is converted from a string to a  Symbol  by  insjson .   super : This field is optional. If provided it will be the supertype of   the new instrument type, otherwise the supertype will be  Instrument . This field is converted from a string to a  Symbol  by  insjson .   make : The make of the instrument, e.g. Keysight, Tektronix, etc.  model : The model of the instrument, e.g. E5071C, AWG5014C, etc.  writeterminator : Write termination string for sending SCPI commands.   The macro imports required modules and methods, defines and exports the  Instrument  subtype, and defines and exports and the  make  and  model  methods if they do not exist already (note generic functions  make  and  model  are defined in  src/Definitions.jl ).  By convention we typically have the module name be the same as the model name, and the type is just the model prefixed by \"Ins\", e.g.  InsE5071C . This is not required.  source  #  InstrumentControl.@generate_properties     Macro .  @generate_properties(metadata)  This macro takes a dictionary of metadata, typically obtained from a call to  insjson . It operates on the  :properties  field of the dictionary, which is expected to be a list of dictionaries with information on each \"property\" of the instrument. This macro specifically operates on the  :type  field of each property dictionary; this field contains the name of the type we would like to assign to a given property of the instrument.  For every property dictionary, the macro first checks if a type with name corresponding to the dictionary's  :type  field  has already been defined. If not, it then defines an abstract type with that name, and makes it a subtype of the  InstrumentProperty  type defined in the ICCommon package. The macro then finally exports that type  source  #  InstrumentControl.@generate_handlers     Macro .  @generate_handlers(instype, p)  This macro takes a symbol  instype  bound to an  Instrument  subtype (i.e. if the symbol was evaluated, it would return an  Instrument  subtype ), and a property dictionary  p  located in the  :properties  field of the dictionary of metadata generated by a call to  insjson . with the auxiliary JSON file described above.  This macro is written to handle the cases where an instrument command does not accept numerical arguments, but rather a small set of options. Here is an example of the property dictionary (prior to parsing) for such a command, which sets/gets the format for a given channel and trace on the E5071C vector network analyzer:  { \n     cmd : :CALCch:TRACtr:FORM , \n     type : VNAFormat , \n     values :[ \n         v::Symbol in symbols \n     ], \n     symbols :{ \n         LogMagnitude : MLOG , \n         Phase : PHAS , \n         GroupDelay : GDEL , \n         SmithLinear : SLIN , \n         SmithLog : SLOG , \n         SmithComplex : SCOM , \n         Smith : SMIT , \n         SmithAdmittance : SADM , \n         PolarLinear : PLIN , \n         PolarLog : PLOG , \n         PolarComplex : POL , \n         LinearMagnitude : MLIN , \n         SWR : SWR , \n         RealPart : REAL , \n         ImagPart : IMAG , \n         ExpandedPhase : UPH , \n         PositivePhase : PPH \n     }, \n     infixes :[ \n         ch::Integer=1 , \n         tr::Integer=1 \n     ], \n     doc : Hey  }   We see here that the  values  key is saying that we are only going to accept  Symbol  type for our  setindex!  method and the symbol has to come out of  symbols , a dictionary that is defined on the next line. The keys of this dictionary are going to be interpreted as symbols (e.g.  :LogMagnitude ) and the values are just ASCII strings to be sent to the instrument. We want to associate these symbols with the specific ASCII strings because these strings are not very descriptive, so we would like a more descriptive handle for them, as well as a handle that could be potentially shared between different instruments which have different \"spellings\" for the same command. We make the handles symbols because they are a more flexible type (which can always be parsed into strings)  generate_handlers  makes a bidirectional mapping between the symbols and the strings. For the example above, the macro defines the following functions:  function   symbols ( ins :: InsE5071C ,   :: Type { VNAFormat },   v :: Symbol ) \n     if   v   ==   : LogMagnitude \n       MLOG \n     else \n       if   v   ==   : Phase \n         PHAS \n       else ... \n\n         else \n           error ( unexpected input. ) \n     end  end  function   VNAFormat ( ins :: InsE5071C ,   s :: AbstractString ) \n     if   s   ==   MLOG \n       : LogMagnitude \n     else \n       if   s   ==   PHAS \n         : Phase \n       else ... \n\n\n         else \n           error ( unexpected input. ) \n     end  end   The above functions will be defined in the module where the macro is run. Note that the function  symbols  has its name chosen based on the dictionary name in the JSON file. Since this function is not exported from the instrument's module there should be few namespace worries and we maintain future flexibliity.  source  #  InstrumentControl.@generate_configure     Macro .  @generate_configure(instype, p)  This macro takes a symbol  instype  bound to an  Instrument  subtype (i.e. if the symbol was evaluated, it would return an  Instrument  subtype ), and a property dictionary  p  located in the  :properties  field of the dictionary of metadata generated by a call to  insjson . with the auxiliary JSON file described above.  This macro overloads the base method  setindex! . In this implementation of  setindex! , the instrument acts as the collection, the key is the InstrumentProperty type defined from the  :type  field of the  p  dictionary, and the value is specified by the user. This method also takes infix arguments; infixes are currently implemented as keyword arguments, so the  setindex!  method applies some standard infixes if none are specified by the user.  The method constructs a configuration command to send to the instrument to change the specific instrument property the dictionary  p  corresponds to (with user specified infixes). The command has \"#\" in place of the (user specified) value the property will be set to. It then sends the command to the instrument with the  write  method (NOTE: currently only defined in the VISA module for VISA instruments) where the command and the user-specified property value are passed to it. The  write  method replaces \"#\" with the proper value, and sends the command to the instrument  The macro accomplishes this by constructing and evaluating (approximately) the following expression:  function   setindex ! ( ins :: instype ,   v :: values_Type ,   :: Type { p [ : type ]},   infixes_keyword_args ) \n   command = p [ : cmd ] \n   command *  # \n   cmd \u00a0 = \u00a0 replace ( cmd , \u00a0 infix_name , \u00a0 infix_keyword_arg1 ) \n   cmd \u00a0 = \u00a0 replace ( cmd , \u00a0 infix_name , \u00a0 infix_keyword_arg2 ) \n   ...   # etc \n   ... manipulation   of   input   v   into   format   instrument   accepts \n   write ( ins , cmd , v )  end   The function should be defined in the module where the instrument type was defined.  source  #  InstrumentControl.@generate_inspect     Macro .  @generate_inspect(instype, p)  This macro takes a symbol  instype  bound to an  Instrument  subtype (i.e. if the symbol was evaluated, it would return an  Instrument  subtype ), and a property dictionary  p  located in the  :properties  field of the dictionary of metadata generated by a call to  insjson . with the auxiliary JSON file described above.  This macro overloads the base method  getindex . In this implementation of  getindex , the instrument acts as the collection, and the key is the InstrumentProperty type defined from the  :type  field of the  p  dictionary. This method also takes infix arguments; infixes are currently implemented as keyword arguments, so the  getindex  method applies some standard infixes if none are specified by the user.  The method constructs a query command to send to the instrument regarding the specific instrument property the dictionary  p  corresponds to. It then sends the command to the instrument with the  ask  method (NOTE: currently defined in the VISA module for VISA instruments). The  ask  method returns the value or state of the instrument property being queried.  The macro accomplishes this by constructing and evaluating (approximately) the following expression:  function   getindex ( ins :: instype ,   :: Type { p [ : type ]},   infixes_keyword_args ) \n   command = p [ : cmd ] \n   command [ end ]   !=   ?     ( command   *=   ? ) \n   cmd \u00a0 = \u00a0 replace ( cmd , \u00a0 infix_name , \u00a0 infix_keyword_arg1 ) \n   cmd \u00a0 = \u00a0 replace ( cmd , \u00a0 infix_name , \u00a0 infix_keyword_arg2 ) \n   ...   # etc \n   ask ( ins , cmd ) \n   ... further   manipulation   of   output   for   display  end   The function should be defined in the module where the instrument type was defined.  source", 
            "title": "Metaprogramming for VISA instruments"
        }, 
        {
            "location": "/implementation/#sweep-sweep-jobs-and-sweep-queueing-implementation", 
            "text": "We stratify InstrumentControl \"sweeps\" functionality into different types, along with helper functions for each type, in order to achieve a object-oriented architecture with code modularity.  Measurement specific information, such as what independent variables will be swept and what response will be measured, are contained in a  Sweep  type:  #  InstrumentControl.Sweep     Type .  mutable struct Sweep\n    dep::Response\n    indep::Tuple{Tuple{Stimulus, AbstractVector}}\n    result::AxisArray\n    Sweep(a,b) = new(a,b)\n    Sweep(a,b,c) = new(a,b,c)\nend  Object representing a sweep; which will contain information on stimuli sent to the instruments, information on what kind of response we will be measuring, and the numerical data obtained from the measurement.  dep  (short for dependent) is a  Response  that will be measured.  indep  is a tuple of  Stimulus  objects and the values they will be sourced over.  result  is the result array of the sweep, which need not be provided at the time the  Sweep  object is created.  source  However, additional metadata is needed for scheduling and queueing of sweeps, as well as logging of job information on ICDataServer. We \"bundle\" that information, along with a  Sweep  object, in a more comprehensive  SweepJob  type:  InstrumentControl.SweepJob\nInstrumentControl.SweepJob()  Finally, we require a  collection  object that can hold  SweepJob  objects, and sort them by job priority, in addition to having  functionality for  automatic scheduling of jobs in the background. For this purpose we define the  SweepJobQueue  type, as well as a initialization inner constructor.  #  InstrumentControl.SweepJobQueue     Type .  mutable struct SweepJobQueue\n    #PriorityQueue is essentially a glorified dictionary with built-in functionality\n    #for sorting of keys\n    q::PriorityQueue{Int,SweepJob,\n        Base.Order.ReverseOrdering{Base.Order.ForwardOrdering}}\n    running_id::Channel{Int}\n    last_finished_id::Channel{Int}\n    trystart::Condition #used to communicate with the job_starter function\n    update_taskref::Ref{Task} #used to communicate with the job_updater function\n    update_channel::Channel{SweepJob} #channel for communicating with the job_updater function\n    function SweepJobQueue()\n        sjq = new(PriorityQueue(Int[],SweepJob[],Base.Order.Reverse),\n            Channel{Int}(1), Channel{Int}(1), Condition())\n        put!(sjq.running_id, -1)\n        put!(sjq.last_finished_id,-1)\n        sjq.update_taskref = Ref{Task}() #initializing a pointer for a task\n        sjq.update_channel = Channel(t- job_updater(sjq, t);\n            ctype = SweepJob, taskref=sjq.update_taskref)\n        #the job_updater function is wrapped in a Task through this Channel constructor\n        @schedule job_starter(sjq) #the job_started function is wrapped in a Task here\n        sjq\n    end\nend  A queue responsible for prioritizing sweeps and executing them accordingly. The queue holds  SweepJob  objects, and \"indexes\" them by their  job_id . It prioritizes jobs based on their priorities; for equal priority values, the job submitted earlier takes precedent. The queue keeps track of which job is running (if any) by its  running_id   Channel . The queue keeps track of the last finished job by the  last_finished_id  channel, for easy access to the data of the last finished job. Other fields are used for intertask communication. Note that a  running_id of  -1 signifies that no job is running.  When a  SweepJobQueue  is created through it's argumentless inner constructor (made for initialization purposes), two tasks are initialized. One task manages job updates, the other task is responsible for starting jobs; the former task executes the  job_updater  function, the latter task executes the  job_starter  function. Both functions execute infinite while loops, therefore they never end.  When the job starter task is notified with the  trystart::Condition  object in the  SweepJobQueue  object, it will find the highest priority job in the queue. Then, if a job is not running, and the prioritized job is waiting, and if the prioritized job is runnable (the priority may be \"NEVER\"), then the job is started. The database is updated asynchronously to reflect the new job, the queue's  running_id  is changed to the job's id, and the job's status is changed to \"Running\".  The job updater task tries to take a  SweepJob  from  update_channel , the unbuffered job  Channel  of the  SweepJobQueue  object. The task is blocked until a job is put into the channel. Once a job arrives, provided the job has finished or has been aborted, the database is asynchronously updated, the job is marked as no longer running (by updating the  running_id  and  last_finished_id  channels), the sweep result is asynchronously saved to disk, and finally the job starter task is notified through the queue's  trystart   Condition  object. The job updater task loops around and waits for another job to arrive at its channel.  source  #  InstrumentControl.job_updater     Function .  job_updater(sjq::SweepJobQueue, update_channel::Channel{SweepJob})  Used when a sweep job finishes; archieves the result of the finished sweep job, updates all job and queue metadata, asynchronously updates ICDataServer, and notifies the job_starter task to run through  sjq 's  trystart   Condition  object. This function continuously runs continuously without stopping once called. In its current implementation, this function is executed through a Task when a  SweepJobQueue  object is initialized; this allows the function to be stopped and recontinued asynchronously as is appropriate.  The function first waits until the update_channel is populated with a job. Once a job arrives, the function takes the job from the channel, and given that it's status is \"Done\" or \"Aborted\", it executes the items described above  source  #  InstrumentControl.job_starter     Function .  job_starter(sjq::SweepJobQueue)  Used when starting a new sweep job. The function first obtains the highest priority job in  sjq ; and given that a job is not running, it's status is \"Waiting\", and if the prioritized job is runnable (the priority may be \"never\"), then the job is started. The function updates all job and queue metadata and asynchronously updates ICDataServer. This function continuously runs continuously without stopping once called. In its current implementation, this function is executed through a Task when a  SweepJobQueue  object is initialized; this allows the function to be stopped and recontinued asynchronously as is appropriate.  The last thing the function does is change the job status to \"Running\". When a job is scheduled with the sweep function, the sweep function waits for the status of the job to be changed from \"Waiting\" to start sourcing the instruments and performing measurements  source  When InstrumentControl is imported, a default 'SweepJobQueue' object is instantiated via the  SweepJobQueue()  constructor, and associated with a pointer called  sweepjobqueue . This is THE queue running in the background automatically scheduling jobs, and referred to as the \"default sweep job queue object\" in the documentation. This object can be returned by the following function:  #  InstrumentControl.jobs     Method .  jobs()  Returns the default  SweepJobQueue  object, initialized when the InstrumentControl module is imported/used. All jobs are scheduled in this object. Typically you call this to see what jobs are waiting, aborted, or finished, and what job is running.  source  Sweeps are scheduled by a call to the  sweep  function:  #  InstrumentControl.sweep     Function .  sweep { N } ( dep :: Response ,   indep :: Vararg { Tuple{Stimulus,   AbstractVector } ,   N } ; \n     priority   =   NORMAL )   sweep  measures a response as a function of an arbitrary number of stimuli, sourced over the values given in the  AbstractVector  input, and returns a handle to the sweep job. This can be used to access the results while the sweep is being measured.  This function is responsible for 1) initialzing sockets for communication with the ICDataServer, 2) initializing an appropriate array to hold the reults of the sweep,   preparing a  InstrumentControl.SweepJob  object with an appropriate  job_id   obtained from the database, 4) adding the job to the default  SweepJobQueue  object (defined when the InstrumentControl module is used/imported), and 5) launching an asynchronous sweep job.  The  priority  keyword may be  LOW ,  NORMAL , or  HIGH , or any integer greater than or equal to zero.  The actual sweeping, i.e., the actual  source  and  measure  loops to measure data are in a private function  InstrumentControl._sweep! . Note that if  InstrumentControl._sweep!  is not defined yet, this function will also define the method in order to it to be used to schedule a sweep.  source  #  InstrumentControl._sweep!     Function .  _sweep!(::Val{D}, ::Val{N}, sj, update_channel)  This is a private function which should not be called directly by the user. It is launched asynchronously by  sweep . The implementation uses macros from  Base.Cartesian . The stimuli are sourced only when they need to be, at the start of each  for  loop level.  D  is the dimension of the output array of the measure function (if multiple things are measured for one Response type, the array will be multi-dimensional).  N  is the number of stimuli which the sweep sources over. sj is the handle to the  SweepJob  object, and update_channel is a channel of the queue used for intertask comunication.  The axis scaling of  measure(sj.sweep.dep) , i.e., the dimensions of the output array of the function. is presumed to be fixed, as it is only looked at once, the first time  measure  is called.  source", 
            "title": "Sweep, Sweep Jobs, and Sweep Queueing implementation"
        }, 
        {
            "location": "/Alazar/", 
            "text": "Alazar digitizers\n\n\nWe put all Alazar digitizers in module \nAlazarModule\n; the feature set and API is so similar for the various models that just one module makes sense.\n\n\nAn \nAlazarResponse\n type is given for each measurement mode of the digitizer. (\"Traditional record mode\" has not been implemented yet for lack of immediate need.) Additionally, one can define custom \nAlazarResponse\n types so that some custom computations or data reductions can be performed during acquisition. \nIQSoftwareResponse\n is a good example of this.\n\n\nIn the following discussion, it is important to understand some Alazar terminology. Newer Alazar digitizers use direct memory access (DMA) to stream data into a computer's RAM. A single \nacquisition\n uses one or many \nbuffers\n, which constitute preallocated regions in the computer's physical memory. Each buffer contains one or many \nrecords\n. Each \nrecord\n contains many \nsamples\n, which are the voltages measured by the digitizer. In streaming mode, there is only one record per buffer, but in other modes there can be many records per buffer.\n\n\nLooking at the source code, it would seem that there is some redundancy in the types, for instance there is an \nNPTRecordMode\n and an \nNPTRecordResponse\n object. The former is used internally in the code to denote a particular method of configuring the instrument, mirroring the terminology used in the Alazar API documentation. The latter specifies what you actually want to do using that configuration of the instrument. Perhaps you want to measure in a given mode, but do some custom post-processing or processing during acquisition. \nIQSoftwareResponse\n is an example of this: it uses \nNPTRecordMode\n but reduces the data during measurement. Typically the user doesn't have to deal with the various mode objects, unless developing a new \nAlazarResponse\n type.\n\n\n\n\nUsage\n\n\nHere are the currently defined \nAlazarResponse\n types you can use:\n\n\n#\n\n\nInstrumentControl.AlazarModule.ContinuousStreamResponse\n \n \nType\n.\n\n\nmutable struct ContinuousStreamResponse{S,T} \n: StreamResponse{S,T}\n\n\n\n\n\nResponse type implementing the \"continuous streaming mode\" of the Alazar API.\n\n\nUsage example:\n\n\nats = AlazarATS9870()\nsamples_per_ch = 1024\nres = ContinuousStreamResponse(ats, samples_per_ch)\nmeasure(res)\n\n\n\n\n\nsource\n\n\n#\n\n\nInstrumentControl.AlazarModule.TriggeredStreamResponse\n \n \nType\n.\n\n\nmutable struct TriggeredStreamResponse{S,T} \n: StreamResponse{S,T}\n\n\n\n\n\nResponse type implementing the \"triggered streaming mode\" of the Alazar API.\n\n\nUsage example:\n\n\nats = AlazarATS9870()\nsamples_per_ch = 1024\nres = TriggeredStreamResponse(ats, samples_per_ch)\nmeasure(res)\n\n\n\n\n\nsource\n\n\n#\n\n\nInstrumentControl.AlazarModule.NPTRecordResponse\n \n \nType\n.\n\n\nmutable struct NPTRecordResponse{S,T} \n: RecordResponse{S,T}\n\n\n\n\n\nResponse type implementing the \"NPT record mode\" of the Alazar API.\n\n\nUsage example:\n\n\nats = AlazarATS9870()\nsamples_per_rec_per_ch = 1024\ntotal_recs = 10\nres = NPTRecordResponse(ats, sam_per_rec_per_ch, total_recs)\nmeasure(res)\n\n\n\n\n\nsource\n\n\n#\n\n\nInstrumentControl.AlazarModule.FFTHardwareResponse\n \n \nType\n.\n\n\nmutable struct FFTHardwareResponse{S,T,U} \n: FFTResponse{S,T}\n\n\n\n\n\nResponse type implementing the FPGA-based \"FFT record mode\" of the Alazar API. Not all Alazar digitizers support this mode.\n\n\nUsage example:\n\n\nats = AlazarATS9360()\nsamples_per_rec = 1024\nsam_per_fft = 512\ntotal_recs = 10\nres = FFTHardwareResponse(ats, sam_per_rec, sam_per_fft, total_recs, Alazar.S32Real)\nmeasure(res)\n\n\n\n\n\nsource\n\n\n#\n\n\nInstrumentControl.AlazarModule.IQSoftwareResponse\n \n \nType\n.\n\n\nmutable struct IQSoftwareResponse{S,T} \n: RecordResponse{S,T}\n\n\n\n\n\nResponse type for measuring with NPT record mode and mixing in software to find the phase and amplitude of a component at frequency \nf\n. Slower than doing it in an FPGA, but ultimately necessary if we want to use both channels as inputs to the FFT.\n\n\nUsage example:\n\n\nats = AlazarATS9870()\nsamples_per_rec_per_ch = 1024\ntotal_recs = 10\nf = 100e6\nres = IQSoftwareResponse(ats, samples_per_rec_per_ch, total_recs, f)\nmeasure(res)\n\n\n\n\n\nsource\n\n\nThese definitions referenced some abstract types, described here:\n\n\n#\n\n\nInstrumentControl.AlazarModule.AlazarResponse\n \n \nType\n.\n\n\nabstract type AlazarResponse{S,T} \n: Response\n\n\n\n\n\nAbstract \nResponse\n from an Alazar digitizer instrument. Subtypes should implement \nreturn_type\n to specify the output array type if they rely on the generic method \nmeasure(::AlazarResponse)\n.\n\n\nsource\n\n\n#\n\n\nInstrumentControl.AlazarModule.StreamResponse\n \n \nType\n.\n\n\nabstract type StreamResponse{S,T} \n: AlazarResponse{S,T}\n\n\n\n\n\nAbstract time-domain streaming \nResponse\n from an Alazar digitizer instrument.\n\n\nsource\n\n\n#\n\n\nInstrumentControl.AlazarModule.RecordResponse\n \n \nType\n.\n\n\nabstract type RecordResponse{S,T} \n: AlazarResponse{S,T}\n\n\n\n\n\nAbstract time-domain record \nResponse\n from an Alazar digitizer instrument.\n\n\nsource\n\n\n\n\nTechnical details\n\n\n\n\nDigitizer requirements\n\n\nThe Alazar digitizers expect buffers in physical memory which are page-aligned. The size of each buffer should also be chosen appropriately.\n\n\nThe behavior of the digitizer is not specified when the buffer is made larger than 64 MB. On our computer, it seems like an \nApiWaitTimeout\n error is thrown when the buffer is too large (for some unspecified definition of \"large\" greater than 64 MB). The digitizer will then throw \nApiInsufficientResources\n errors whenever another acquisition is attempted, until the computer is restarted. Just restarting the Julia kernel, forcing a reload of the Alazar DLLs, does not appear to be enough to reset the digitizer fully.\n\n\nFor performance reasons, a buffer should not be made much smaller than 1 MB if mulitple buffers are required. There is also a minimum record size for each model of digitizer. For the ATS9360, if a record has fewer than 256 samples (could be 128 from channel A + 128 from channel B) then the acquisition will proceed, but return garbage data. Allocating too small of a buffer is therefore still bad, but less fatal than allocating one that is too large.\n\n\n\n\nHow to allocate appropriate buffers in Julia\n\n\nIn Julia, just allocating an array will not necessarily return a page-aligned block in memory. The Alazar.jl package provides two array types to help with this. These arrays are not required to be created by the user.\n\n\n\n\nAlazar.PageAlignedVector\n is just like \nBase.Vector\n except that the memory backing the array is guaranteed to be page-aligned.\n\n\nThe elements of an \nAlazar.DMABufferVector\n are pointers to different locations in memory which are page-aligned and can act as DMA buffers. The array is iterable and indexable as usual. The \nAlazar.DMABufferVector\n must itself be backed by a page-aligned array type, like \nAlazar.PageAlignedVector\n or \nBase.SharedVector\n (although support for \nBase.SharedVector\n is absent in InstrumentControl).", 
            "title": "Alazar digitizers"
        }, 
        {
            "location": "/Alazar/#alazar-digitizers", 
            "text": "We put all Alazar digitizers in module  AlazarModule ; the feature set and API is so similar for the various models that just one module makes sense.  An  AlazarResponse  type is given for each measurement mode of the digitizer. (\"Traditional record mode\" has not been implemented yet for lack of immediate need.) Additionally, one can define custom  AlazarResponse  types so that some custom computations or data reductions can be performed during acquisition.  IQSoftwareResponse  is a good example of this.  In the following discussion, it is important to understand some Alazar terminology. Newer Alazar digitizers use direct memory access (DMA) to stream data into a computer's RAM. A single  acquisition  uses one or many  buffers , which constitute preallocated regions in the computer's physical memory. Each buffer contains one or many  records . Each  record  contains many  samples , which are the voltages measured by the digitizer. In streaming mode, there is only one record per buffer, but in other modes there can be many records per buffer.  Looking at the source code, it would seem that there is some redundancy in the types, for instance there is an  NPTRecordMode  and an  NPTRecordResponse  object. The former is used internally in the code to denote a particular method of configuring the instrument, mirroring the terminology used in the Alazar API documentation. The latter specifies what you actually want to do using that configuration of the instrument. Perhaps you want to measure in a given mode, but do some custom post-processing or processing during acquisition.  IQSoftwareResponse  is an example of this: it uses  NPTRecordMode  but reduces the data during measurement. Typically the user doesn't have to deal with the various mode objects, unless developing a new  AlazarResponse  type.", 
            "title": "Alazar digitizers"
        }, 
        {
            "location": "/Alazar/#usage", 
            "text": "Here are the currently defined  AlazarResponse  types you can use:  #  InstrumentControl.AlazarModule.ContinuousStreamResponse     Type .  mutable struct ContinuousStreamResponse{S,T}  : StreamResponse{S,T}  Response type implementing the \"continuous streaming mode\" of the Alazar API.  Usage example:  ats = AlazarATS9870()\nsamples_per_ch = 1024\nres = ContinuousStreamResponse(ats, samples_per_ch)\nmeasure(res)  source  #  InstrumentControl.AlazarModule.TriggeredStreamResponse     Type .  mutable struct TriggeredStreamResponse{S,T}  : StreamResponse{S,T}  Response type implementing the \"triggered streaming mode\" of the Alazar API.  Usage example:  ats = AlazarATS9870()\nsamples_per_ch = 1024\nres = TriggeredStreamResponse(ats, samples_per_ch)\nmeasure(res)  source  #  InstrumentControl.AlazarModule.NPTRecordResponse     Type .  mutable struct NPTRecordResponse{S,T}  : RecordResponse{S,T}  Response type implementing the \"NPT record mode\" of the Alazar API.  Usage example:  ats = AlazarATS9870()\nsamples_per_rec_per_ch = 1024\ntotal_recs = 10\nres = NPTRecordResponse(ats, sam_per_rec_per_ch, total_recs)\nmeasure(res)  source  #  InstrumentControl.AlazarModule.FFTHardwareResponse     Type .  mutable struct FFTHardwareResponse{S,T,U}  : FFTResponse{S,T}  Response type implementing the FPGA-based \"FFT record mode\" of the Alazar API. Not all Alazar digitizers support this mode.  Usage example:  ats = AlazarATS9360()\nsamples_per_rec = 1024\nsam_per_fft = 512\ntotal_recs = 10\nres = FFTHardwareResponse(ats, sam_per_rec, sam_per_fft, total_recs, Alazar.S32Real)\nmeasure(res)  source  #  InstrumentControl.AlazarModule.IQSoftwareResponse     Type .  mutable struct IQSoftwareResponse{S,T}  : RecordResponse{S,T}  Response type for measuring with NPT record mode and mixing in software to find the phase and amplitude of a component at frequency  f . Slower than doing it in an FPGA, but ultimately necessary if we want to use both channels as inputs to the FFT.  Usage example:  ats = AlazarATS9870()\nsamples_per_rec_per_ch = 1024\ntotal_recs = 10\nf = 100e6\nres = IQSoftwareResponse(ats, samples_per_rec_per_ch, total_recs, f)\nmeasure(res)  source  These definitions referenced some abstract types, described here:  #  InstrumentControl.AlazarModule.AlazarResponse     Type .  abstract type AlazarResponse{S,T}  : Response  Abstract  Response  from an Alazar digitizer instrument. Subtypes should implement  return_type  to specify the output array type if they rely on the generic method  measure(::AlazarResponse) .  source  #  InstrumentControl.AlazarModule.StreamResponse     Type .  abstract type StreamResponse{S,T}  : AlazarResponse{S,T}  Abstract time-domain streaming  Response  from an Alazar digitizer instrument.  source  #  InstrumentControl.AlazarModule.RecordResponse     Type .  abstract type RecordResponse{S,T}  : AlazarResponse{S,T}  Abstract time-domain record  Response  from an Alazar digitizer instrument.  source", 
            "title": "Usage"
        }, 
        {
            "location": "/Alazar/#technical-details", 
            "text": "", 
            "title": "Technical details"
        }, 
        {
            "location": "/Alazar/#digitizer-requirements", 
            "text": "The Alazar digitizers expect buffers in physical memory which are page-aligned. The size of each buffer should also be chosen appropriately.  The behavior of the digitizer is not specified when the buffer is made larger than 64 MB. On our computer, it seems like an  ApiWaitTimeout  error is thrown when the buffer is too large (for some unspecified definition of \"large\" greater than 64 MB). The digitizer will then throw  ApiInsufficientResources  errors whenever another acquisition is attempted, until the computer is restarted. Just restarting the Julia kernel, forcing a reload of the Alazar DLLs, does not appear to be enough to reset the digitizer fully.  For performance reasons, a buffer should not be made much smaller than 1 MB if mulitple buffers are required. There is also a minimum record size for each model of digitizer. For the ATS9360, if a record has fewer than 256 samples (could be 128 from channel A + 128 from channel B) then the acquisition will proceed, but return garbage data. Allocating too small of a buffer is therefore still bad, but less fatal than allocating one that is too large.", 
            "title": "Digitizer requirements"
        }, 
        {
            "location": "/Alazar/#how-to-allocate-appropriate-buffers-in-julia", 
            "text": "In Julia, just allocating an array will not necessarily return a page-aligned block in memory. The Alazar.jl package provides two array types to help with this. These arrays are not required to be created by the user.   Alazar.PageAlignedVector  is just like  Base.Vector  except that the memory backing the array is guaranteed to be page-aligned.  The elements of an  Alazar.DMABufferVector  are pointers to different locations in memory which are page-aligned and can act as DMA buffers. The array is iterable and indexable as usual. The  Alazar.DMABufferVector  must itself be backed by a page-aligned array type, like  Alazar.PageAlignedVector  or  Base.SharedVector  (although support for  Base.SharedVector  is absent in InstrumentControl).", 
            "title": "How to allocate appropriate buffers in Julia"
        }, 
        {
            "location": "/waveform_generator/awg5014c/", 
            "text": "Documentation forthcoming.", 
            "title": "AWG5014C"
        }, 
        {
            "location": "/vna/vna/", 
            "text": "Most of the time you will probably want \nVNA.stimdata\n, \nVNA.data\n, and \nVNA.FrequencySweep\n.\n\n\n\n\nStimuli and responses\n\n\n#\n\n\nInstrumentControl.VNA.FrequencySweep\n \n \nType\n.\n\n\nmutable struct FrequencySweep \n: Response\n    ins::InstrumentVNA\n    reject::Int\nend\n\n\n\n\n\nYour standard frequency sweep using a VNA. \nreject\n lets you reject a number of traces to reject before keeping measurements.\n\n\nsource\n\n\n\n\nInstrument properties\n\n\n#\n\n\nInstrumentControl.VNA.Format\n \n \nType\n.\n\n\nFormat of returned data. Search for \nVNA.Format\n in the instrument template files to find valid options; some examples include \n:LogMagnitude\n, \n:GroupDelay\n, \n:PolarComplex\n, etc.\n\n\nsource\n\n\n#\n\n\nInstrumentControl.VNA.Graphs\n \n \nType\n.\n\n\nGraph layout on the VNA display. Specify with a matrix of integers.\n\n\nThe following example will have graph 1 occupying the top half of the screen, graph 2 occupying the lower-left, and graph 3 the lower-right:\n\n\nins[Graphs] = [1 1; 2 3]\n\n\n\n\n\nsource\n\n\n#\n\n\nInstrumentControl.VNA.Marker\n \n \nType\n.\n\n\nMarker state for a given marker (on/off).\n\n\nsource\n\n\n#\n\n\nInstrumentControl.VNA.MarkerX\n \n \nType\n.\n\n\nX-axis value for a given marker.\n\n\nsource\n\n\n#\n\n\nInstrumentControl.VNA.MarkerY\n \n \nType\n.\n\n\nY-axis value for a marker.\n\n\nsource\n\n\n#\n\n\nInstrumentControl.VNA.Parameter\n \n \nType\n.\n\n\nScattering parameter. For two-port VNAs, you can specify \n:S11\n, \n:S12\n, \n:S21\n, or \n:S22\n.\n\n\nExample:\n\n\nchannel, trace = 1, 2\nins[Parameter, channel, trace] = :S21\n\n\n\n\n\nsource\n\n\n#\n\n\nInstrumentControl.VNA.SearchTracking\n \n \nType\n.\n\n\nDo a marker search with each trace update (yes/no).\n\n\nsource\n\n\n\n\nMethods\n\n\n#\n\n\nInstrumentControl.VNA.clearavg\n \n \nFunction\n.\n\n\nclearavg(ins::InstrumentVNA, ch::Integer=1)\n\n\n\n\n\nRestart averaging for a given channel \nch\n (defaults to 1).\n\n\nsource\n\n\n#\n\n\nInstrumentControl.VNA.data\n \n \nFunction\n.\n\n\ndata(ins::InstrumentVNA, fmt::Symbol, ch::Integer=1, tr::Integer=1)\ndata(ins::InstrumentVNA, ch::Integer=1, tr::Integer=1)\n\n\n\n\n\nRead the trace data from the VNA. If you provide \nfmt\n (which should be a symbol suitable for setting the \nVNA.Format\n property) the data will be returned in that format.\n\n\nsource\n\n\n#\n\n\nBase.search\n \n \nMethod\n.\n\n\nsearch(ins::InstrumentVNA, m1::MarkerSearch, m2::MarkerSearch, m3::MarkerSearch...)\n\n\n\n\n\nExecute marker searches defined by any number of \nMarkerSearch\n objects.\n\n\nsource\n\n\n#\n\n\nInstrumentControl.VNA.shotgun\n \n \nFunction\n.\n\n\nshotgun(ins::InstrumentVNA, m::AbstractArray=1:9, ch::Integer=1, tr::Integer=1)\n\n\n\n\n\nMarkers with numbers in the range \nm\n are spread across the frequency span. The first marker begins at the start frequency but the last marker is positioned before the stop frequency, such that each marker has the same frequency span to the right of it within the stimulus window.\n\n\nsource\n\n\n#\n\n\nInstrumentControl.VNA.stimdata\n \n \nFunction\n.\n\n\nstimdata(ins::InstrumentVNA, ch::Integer=1)\n\n\n\n\n\nShort for \"stimulus data,\" reads the frequency axis from the VNA.\n\n\nsource\n\n\n#\n\n\nInstrumentControl.VNA.sweeptime\n \n \nFunction\n.\n\n\nsweeptime(ins::InstrumentVNA)\n\n\n\n\n\nReturns the sweep time for a given VNA, including averaging.\n\n\nsource\n\n\n\n\nMiscellaneous\n\n\n#\n\n\nInstrumentControl.VNA.MarkerSearch\n \n \nType\n.\n\n\nstruct MarkerSearch{T}\n    ch::Int\n    tr::Int\n    m::Int\n    val::Float64\n    pol::Polarity\nend\n\n\n\n\n\nType encapsulating a marker search query. The type parameter should be a symbol specifying the search type. The available options may depend on VNA capabilities.\n\n\nThe E5071C supports:\n\n\n:\nMax\n\n\n:\nMin\n\n\n:\nPeak\n\n\n:\nLeftPeak\n\n\n:\nRightPeak\n\n\n:\nTarget\n\n\n:\nLeftTarget\n\n\n:\nRightTarget\n\n\n\n\n\n\nsource\n\n\n#\n\n\nInstrumentControl.VNA.MarkerSearch\n \n \nMethod\n.\n\n\nMarkerSearch(typ::Symbol, ch, tr, m, val=0.0, pol::Polarity=Both())\n\n\n\n\n\nYou are recommended to construct a \nMarkerSearch\n object using this function, which makes a suitable one given the type of search you want to do (specified by \ntyp::Symbol\n), the channel \nch\n, trace \ntr\n, marker number \nm\n, value \nval\n and polarity \npol::Polarity\n (\nPositive()\n, \nNegative()\n, or \nBoth()\n). The value will depend on what you're doing but is typically a peak excursion or transition threshold.\n\n\nsource", 
            "title": "VNAs"
        }, 
        {
            "location": "/vna/vna/#stimuli-and-responses", 
            "text": "#  InstrumentControl.VNA.FrequencySweep     Type .  mutable struct FrequencySweep  : Response\n    ins::InstrumentVNA\n    reject::Int\nend  Your standard frequency sweep using a VNA.  reject  lets you reject a number of traces to reject before keeping measurements.  source", 
            "title": "Stimuli and responses"
        }, 
        {
            "location": "/vna/vna/#instrument-properties", 
            "text": "#  InstrumentControl.VNA.Format     Type .  Format of returned data. Search for  VNA.Format  in the instrument template files to find valid options; some examples include  :LogMagnitude ,  :GroupDelay ,  :PolarComplex , etc.  source  #  InstrumentControl.VNA.Graphs     Type .  Graph layout on the VNA display. Specify with a matrix of integers.  The following example will have graph 1 occupying the top half of the screen, graph 2 occupying the lower-left, and graph 3 the lower-right:  ins[Graphs] = [1 1; 2 3]  source  #  InstrumentControl.VNA.Marker     Type .  Marker state for a given marker (on/off).  source  #  InstrumentControl.VNA.MarkerX     Type .  X-axis value for a given marker.  source  #  InstrumentControl.VNA.MarkerY     Type .  Y-axis value for a marker.  source  #  InstrumentControl.VNA.Parameter     Type .  Scattering parameter. For two-port VNAs, you can specify  :S11 ,  :S12 ,  :S21 , or  :S22 .  Example:  channel, trace = 1, 2\nins[Parameter, channel, trace] = :S21  source  #  InstrumentControl.VNA.SearchTracking     Type .  Do a marker search with each trace update (yes/no).  source", 
            "title": "Instrument properties"
        }, 
        {
            "location": "/vna/vna/#methods", 
            "text": "#  InstrumentControl.VNA.clearavg     Function .  clearavg(ins::InstrumentVNA, ch::Integer=1)  Restart averaging for a given channel  ch  (defaults to 1).  source  #  InstrumentControl.VNA.data     Function .  data(ins::InstrumentVNA, fmt::Symbol, ch::Integer=1, tr::Integer=1)\ndata(ins::InstrumentVNA, ch::Integer=1, tr::Integer=1)  Read the trace data from the VNA. If you provide  fmt  (which should be a symbol suitable for setting the  VNA.Format  property) the data will be returned in that format.  source  #  Base.search     Method .  search(ins::InstrumentVNA, m1::MarkerSearch, m2::MarkerSearch, m3::MarkerSearch...)  Execute marker searches defined by any number of  MarkerSearch  objects.  source  #  InstrumentControl.VNA.shotgun     Function .  shotgun(ins::InstrumentVNA, m::AbstractArray=1:9, ch::Integer=1, tr::Integer=1)  Markers with numbers in the range  m  are spread across the frequency span. The first marker begins at the start frequency but the last marker is positioned before the stop frequency, such that each marker has the same frequency span to the right of it within the stimulus window.  source  #  InstrumentControl.VNA.stimdata     Function .  stimdata(ins::InstrumentVNA, ch::Integer=1)  Short for \"stimulus data,\" reads the frequency axis from the VNA.  source  #  InstrumentControl.VNA.sweeptime     Function .  sweeptime(ins::InstrumentVNA)  Returns the sweep time for a given VNA, including averaging.  source", 
            "title": "Methods"
        }, 
        {
            "location": "/vna/vna/#miscellaneous", 
            "text": "#  InstrumentControl.VNA.MarkerSearch     Type .  struct MarkerSearch{T}\n    ch::Int\n    tr::Int\n    m::Int\n    val::Float64\n    pol::Polarity\nend  Type encapsulating a marker search query. The type parameter should be a symbol specifying the search type. The available options may depend on VNA capabilities.  The E5071C supports:  : Max  : Min  : Peak  : LeftPeak  : RightPeak  : Target  : LeftTarget  : RightTarget   source  #  InstrumentControl.VNA.MarkerSearch     Method .  MarkerSearch(typ::Symbol, ch, tr, m, val=0.0, pol::Polarity=Both())  You are recommended to construct a  MarkerSearch  object using this function, which makes a suitable one given the type of search you want to do (specified by  typ::Symbol ), the channel  ch , trace  tr , marker number  m , value  val  and polarity  pol::Polarity  ( Positive() ,  Negative() , or  Both() ). The value will depend on what you're doing but is typically a peak excursion or transition threshold.  source", 
            "title": "Miscellaneous"
        }, 
        {
            "location": "/vna/e5071c/", 
            "text": "Instrument properties\n\n\nWe support the following instrument properties for the E5071C:\n\n\nusing\n \nInstrumentControl\n\n\nmethods\n(\ngetindex\n,\n \n(\nInstrumentControl\n.\nE5071C\n.\nInsE5071C\n,\n \nVararg\n{\nAny\n}))\n\n\n\n\n\n\n# 101 methods for generic function \ngetindex\n:\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.AutoSweepTime}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.AutoSweepTime}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.SweepTime}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.SweepTime}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.ElectricalMedium}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.ElectricalMedium}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.ElectricalMedium}, ch::Integer, tr::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.VNA.Format}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.VNA.Format}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.VNA.Format}, ch::Integer, tr::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.VNA.Parameter}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.VNA.Parameter}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.VNA.Parameter}, ch::Integer, tr::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.TriggerOutputPolarity}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.TriggerOutputTiming}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.Averaging}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.Averaging}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.AveragingFactor}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.AveragingFactor}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.AveragingTrigger}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.ElectricalDelay}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.ElectricalDelay}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.ElectricalDelay}, ch::Integer, tr::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.ExtTriggerDelay}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.ExtTriggerLowLatency}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.FrequencyStart}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.FrequencyStart}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.FrequencyStop}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.FrequencyStop}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.FrequencyCenter}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.FrequencyCenter}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.FrequencySpan}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.FrequencySpan}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.IFBandwidth}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.IFBandwidth}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.NumTraces}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.NumTraces}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.NumPoints}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.NumPoints}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.Output}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.PhaseOffset}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.PhaseOffset}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.PhaseOffset}, ch::Integer, tr::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.PointTrigger}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.PowerCoupled}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.PowerCoupled}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.PowerLevel}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.PowerLevel}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.PowerPortLevel}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.PowerPortLevel}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.PowerPortLevel}, ch::Integer, port::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.PowerSlope}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.PowerSlope}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.PowerSlopeLevel}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.PowerSlopeLevel}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.PowerSweepFrequency}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.PowerSweepFrequency}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.TraceDisplay}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.TraceDisplay}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.TraceDisplay}, ch::Integer, tr::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.Smoothing}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.Smoothing}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.Smoothing}, ch::Integer, tr::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.SmoothingAperture}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.SmoothingAperture}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.SmoothingAperture}, ch::Integer, tr::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.TraceMaximized}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.TraceMaximized}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.WaveguideCutoff}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.WaveguideCutoff}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.WaveguideCutoff}, ch::Integer, tr::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.YDivisions}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.YDivisions}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.YScalePerDivision}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.YScalePerDivision}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.YScalePerDivision}, ch::Integer, tr::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.YReferenceLevel}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.YReferenceLevel}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.YReferenceLevel}, ch::Integer, tr::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.YReferencePosition}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.YReferencePosition}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.YReferencePosition}, ch::Integer, tr::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.TransferByteOrder}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.TransferFormat}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.TriggerSlope}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.TriggerSource}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.TriggerOutput}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.VNA.Marker}, m::Integer) in InstrumentControl.E5071C at /home/travis/.julia/v0.6/InstrumentControl/src/instruments/VNAs/E5071C.jl:67\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.VNA.Marker}, m::Integer, ch::Integer) in InstrumentControl.E5071C at /home/travis/.julia/v0.6/InstrumentControl/src/instruments/VNAs/E5071C.jl:67\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.VNA.Marker}, m::Integer, ch::Integer, tr::Integer) in InstrumentControl.E5071C at /home/travis/.julia/v0.6/InstrumentControl/src/instruments/VNAs/E5071C.jl:67\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.VNA.MarkerX}, m::Integer) in InstrumentControl.E5071C at /home/travis/.julia/v0.6/InstrumentControl/src/instruments/VNAs/E5071C.jl:72\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.VNA.MarkerX}, m::Integer, ch::Integer) in InstrumentControl.E5071C at /home/travis/.julia/v0.6/InstrumentControl/src/instruments/VNAs/E5071C.jl:72\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.VNA.MarkerX}, m::Integer, ch::Integer, tr::Integer) in InstrumentControl.E5071C at /home/travis/.julia/v0.6/InstrumentControl/src/instruments/VNAs/E5071C.jl:72\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.VNA.MarkerY}, m::Integer) in InstrumentControl.E5071C at /home/travis/.julia/v0.6/InstrumentControl/src/instruments/VNAs/E5071C.jl:77\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.VNA.MarkerY}, m::Integer, ch::Integer) in InstrumentControl.E5071C at /home/travis/.julia/v0.6/InstrumentControl/src/instruments/VNAs/E5071C.jl:77\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.VNA.MarkerY}, m::Integer, ch::Integer, tr::Integer) in InstrumentControl.E5071C at /home/travis/.julia/v0.6/InstrumentControl/src/instruments/VNAs/E5071C.jl:77\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.VNA.SearchTracking}, m::Integer) in InstrumentControl.E5071C at /home/travis/.julia/v0.6/InstrumentControl/src/instruments/VNAs/E5071C.jl:83\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.VNA.SearchTracking}, m::Integer, ch::Integer) in InstrumentControl.E5071C at /home/travis/.julia/v0.6/InstrumentControl/src/instruments/VNAs/E5071C.jl:83\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.VNA.SearchTracking}, m::Integer, ch::Integer, tr::Integer) in InstrumentControl.E5071C at /home/travis/.julia/v0.6/InstrumentControl/src/instruments/VNAs/E5071C.jl:83\ngetindex(ins::ICCommon.Instrument, ::Type{InstrumentControl.Timeout}) in InstrumentControl at /home/travis/.julia/v0.6/InstrumentControl/src/VISA.jl:192\ngetindex(ins::ICCommon.Instrument, ::Type{InstrumentControl.WriteTermCharEnable}) in InstrumentControl at /home/travis/.julia/v0.6/InstrumentControl/src/VISA.jl:200\n\n\n\n\n\n\n\nMethods\n\n\n#\n\n\nInstrumentControl.E5071C.screen\n \n \nFunction\n.\n\n\nscreen(ins::InsE5071C, filename::AbstractString=\nscreen.png\n, display::Bool=true)\n\n\n\n\n\nTake and retrieve a local copy of a screenshot. Display the screenshot if \ndisplay\n is true.\n\n\nWhatever is at \nfilename\n on the computer calling this method will be overwritten with the screenshot. The screenshot is also saved on the instrument.\n\n\nsource", 
            "title": "E5071C"
        }, 
        {
            "location": "/vna/e5071c/#instrument-properties", 
            "text": "We support the following instrument properties for the E5071C:  using   InstrumentControl  methods ( getindex ,   ( InstrumentControl . E5071C . InsE5071C ,   Vararg { Any }))   # 101 methods for generic function  getindex :\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.AutoSweepTime}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.AutoSweepTime}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.SweepTime}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.SweepTime}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.ElectricalMedium}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.ElectricalMedium}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.ElectricalMedium}, ch::Integer, tr::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.VNA.Format}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.VNA.Format}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.VNA.Format}, ch::Integer, tr::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.VNA.Parameter}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.VNA.Parameter}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.VNA.Parameter}, ch::Integer, tr::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.TriggerOutputPolarity}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.TriggerOutputTiming}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.Averaging}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.Averaging}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.AveragingFactor}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.AveragingFactor}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.AveragingTrigger}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.ElectricalDelay}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.ElectricalDelay}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.ElectricalDelay}, ch::Integer, tr::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.ExtTriggerDelay}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.ExtTriggerLowLatency}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.FrequencyStart}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.FrequencyStart}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.FrequencyStop}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.FrequencyStop}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.FrequencyCenter}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.FrequencyCenter}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.FrequencySpan}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.FrequencySpan}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.IFBandwidth}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.IFBandwidth}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.NumTraces}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.NumTraces}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.NumPoints}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.NumPoints}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.Output}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.PhaseOffset}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.PhaseOffset}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.PhaseOffset}, ch::Integer, tr::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.PointTrigger}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.PowerCoupled}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.PowerCoupled}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.PowerLevel}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.PowerLevel}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.PowerPortLevel}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.PowerPortLevel}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.PowerPortLevel}, ch::Integer, port::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.PowerSlope}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.PowerSlope}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.PowerSlopeLevel}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.PowerSlopeLevel}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.PowerSweepFrequency}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.PowerSweepFrequency}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.TraceDisplay}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.TraceDisplay}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.TraceDisplay}, ch::Integer, tr::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.Smoothing}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.Smoothing}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.Smoothing}, ch::Integer, tr::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.SmoothingAperture}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.SmoothingAperture}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.SmoothingAperture}, ch::Integer, tr::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.TraceMaximized}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.TraceMaximized}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.WaveguideCutoff}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.WaveguideCutoff}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.WaveguideCutoff}, ch::Integer, tr::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.YDivisions}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.YDivisions}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.YScalePerDivision}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.YScalePerDivision}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.YScalePerDivision}, ch::Integer, tr::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.YReferenceLevel}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.YReferenceLevel}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.YReferenceLevel}, ch::Integer, tr::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.YReferencePosition}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.YReferencePosition}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.YReferencePosition}, ch::Integer, tr::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.TransferByteOrder}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.TransferFormat}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.TriggerSlope}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.TriggerSource}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.TriggerOutput}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.VNA.Marker}, m::Integer) in InstrumentControl.E5071C at /home/travis/.julia/v0.6/InstrumentControl/src/instruments/VNAs/E5071C.jl:67\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.VNA.Marker}, m::Integer, ch::Integer) in InstrumentControl.E5071C at /home/travis/.julia/v0.6/InstrumentControl/src/instruments/VNAs/E5071C.jl:67\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.VNA.Marker}, m::Integer, ch::Integer, tr::Integer) in InstrumentControl.E5071C at /home/travis/.julia/v0.6/InstrumentControl/src/instruments/VNAs/E5071C.jl:67\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.VNA.MarkerX}, m::Integer) in InstrumentControl.E5071C at /home/travis/.julia/v0.6/InstrumentControl/src/instruments/VNAs/E5071C.jl:72\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.VNA.MarkerX}, m::Integer, ch::Integer) in InstrumentControl.E5071C at /home/travis/.julia/v0.6/InstrumentControl/src/instruments/VNAs/E5071C.jl:72\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.VNA.MarkerX}, m::Integer, ch::Integer, tr::Integer) in InstrumentControl.E5071C at /home/travis/.julia/v0.6/InstrumentControl/src/instruments/VNAs/E5071C.jl:72\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.VNA.MarkerY}, m::Integer) in InstrumentControl.E5071C at /home/travis/.julia/v0.6/InstrumentControl/src/instruments/VNAs/E5071C.jl:77\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.VNA.MarkerY}, m::Integer, ch::Integer) in InstrumentControl.E5071C at /home/travis/.julia/v0.6/InstrumentControl/src/instruments/VNAs/E5071C.jl:77\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.VNA.MarkerY}, m::Integer, ch::Integer, tr::Integer) in InstrumentControl.E5071C at /home/travis/.julia/v0.6/InstrumentControl/src/instruments/VNAs/E5071C.jl:77\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.VNA.SearchTracking}, m::Integer) in InstrumentControl.E5071C at /home/travis/.julia/v0.6/InstrumentControl/src/instruments/VNAs/E5071C.jl:83\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.VNA.SearchTracking}, m::Integer, ch::Integer) in InstrumentControl.E5071C at /home/travis/.julia/v0.6/InstrumentControl/src/instruments/VNAs/E5071C.jl:83\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.VNA.SearchTracking}, m::Integer, ch::Integer, tr::Integer) in InstrumentControl.E5071C at /home/travis/.julia/v0.6/InstrumentControl/src/instruments/VNAs/E5071C.jl:83\ngetindex(ins::ICCommon.Instrument, ::Type{InstrumentControl.Timeout}) in InstrumentControl at /home/travis/.julia/v0.6/InstrumentControl/src/VISA.jl:192\ngetindex(ins::ICCommon.Instrument, ::Type{InstrumentControl.WriteTermCharEnable}) in InstrumentControl at /home/travis/.julia/v0.6/InstrumentControl/src/VISA.jl:200", 
            "title": "Instrument properties"
        }, 
        {
            "location": "/vna/e5071c/#methods", 
            "text": "#  InstrumentControl.E5071C.screen     Function .  screen(ins::InsE5071C, filename::AbstractString= screen.png , display::Bool=true)  Take and retrieve a local copy of a screenshot. Display the screenshot if  display  is true.  Whatever is at  filename  on the computer calling this method will be overwritten with the screenshot. The screenshot is also saved on the instrument.  source", 
            "title": "Methods"
        }, 
        {
            "location": "/docbuild/", 
            "text": "Continuous integration testing\n\n\nTests are run on this package whenever an update is merged into the master branch. Two environment variables are required to be set on the testing server for tests to pass (they can be set to anything). These are \nICTESTMODE\n and \nVISA_JL_NO_LOAD\n. The former tells InstrumentControl.jl not to open a VISA resource manager as well as to skip loading the \nconfig.json\n file. The latter tells VISA.jl not to look for and load a VISA library. Together, these environment variables enable some basic testing and automatic docs building for InstrumentControl.jl.\n\n\n\n\nDocumentation build process\n\n\nDocumenter.jl\n is used to build these docs automatically whenever tests complete successfully.", 
            "title": "Documentation and testing"
        }, 
        {
            "location": "/docbuild/#continuous-integration-testing", 
            "text": "Tests are run on this package whenever an update is merged into the master branch. Two environment variables are required to be set on the testing server for tests to pass (they can be set to anything). These are  ICTESTMODE  and  VISA_JL_NO_LOAD . The former tells InstrumentControl.jl not to open a VISA resource manager as well as to skip loading the  config.json  file. The latter tells VISA.jl not to look for and load a VISA library. Together, these environment variables enable some basic testing and automatic docs building for InstrumentControl.jl.", 
            "title": "Continuous integration testing"
        }, 
        {
            "location": "/docbuild/#documentation-build-process", 
            "text": "Documenter.jl  is used to build these docs automatically whenever tests complete successfully.", 
            "title": "Documentation build process"
        }, 
        {
            "location": "/releases/", 
            "text": "Releases\n\n\nv0.0.1      Currently under development", 
            "title": "Release notes"
        }, 
        {
            "location": "/releases/#releases", 
            "text": "v0.0.1      Currently under development", 
            "title": "Releases"
        }, 
        {
            "location": "/LICENSE/", 
            "text": "License\n\n\nMost code:\n\n\n\n\nCopyright (c) 2015: Andrew Keller.\n\n\n\n\nRandom.jl, Time.jl, and a few other snippets here and there:\n\n\n\n\nCopyright (c) 2014: Menyoung Lee.\n\n\n\n\nLarge majority of code in VISA.jl package:\n\n\n\n\nCopyright (c) 2014: Colm Ryan.\n\n\n\n\nAll of the code is licensed under the MIT \"Expat\" License by the respective copyright holders:\n\n\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.", 
            "title": "License"
        }, 
        {
            "location": "/LICENSE/#license", 
            "text": "Most code:   Copyright (c) 2015: Andrew Keller.   Random.jl, Time.jl, and a few other snippets here and there:   Copyright (c) 2014: Menyoung Lee.   Large majority of code in VISA.jl package:   Copyright (c) 2014: Colm Ryan.   All of the code is licensed under the MIT \"Expat\" License by the respective copyright holders:   Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.", 
            "title": "License"
        }
    ]
}