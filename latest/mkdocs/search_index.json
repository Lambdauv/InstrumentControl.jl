{
    "docs": [
        {
            "location": "/", 
            "text": "InstrumentControl.jl\n\n\nA \nJulia\n package for qubit measurement and analysis.\n\n\n\n\nInstallation\n\n\n\n\nInstall \nNational Instruments VISA libraries\n (tested with v15.0.1 on Windows 10)\n\n\nInstall \nAlazarTech\n digitizer drivers and shared libraries (may need to contact AlazarTech) if using Alazar digitizer\n\n\nInstall \nVISA.jl\n package\n\n\nInstall \nAlazar.jl\n package\n\n\nInstall \nKeysightInstruments.jl\n package\n\n\nInstall \nICCommon.jl\n package\n\n\nInstall \nICDataServer.jl\n package and follow it's \ninstallation procedure\n\n\nInstall \nInstrumentControl.jl\n package\n\n\n\n\n\n\nExample Notebooks\n\n\nInstrumentControl.jl relies on having physical instruments, communication with a database set up by ICDataServer.jl, and various files with machine specific configuration information in order to run. As such, we provide some example notebooks in order to showcase this package's functionality.\n\n\n# put example notebooks here\n\n\n\n\n\n\n\nNew to Julia\n\n\nThis documentation seeks to provide a higher-level description of the architecture and control-flow of the code, with references to the source code only to facilitate explanation. If the user seeks to understand the source code, while this documentation is a useful aid, aptitude and understanding of the Julia language will be necessary to fully understand it's implementation in a line by line level. For those who have a background in programming, but not in Julia, below is a list of Julia features used in the source code which might not be featured in other languages, along with links to the Julia docs explaining them. It is our hope that, with the reading listed below and this documentation, that any reader with some background in programming would be able to satisfactorily understand the source code:\n\n\n\n\n\n\nTypes\n\n\n\n\nJulia Types in general\n\n\nParametric Types\n\n\nSingleton Types\n\n\n\n\nFunctions and Methods\n\n\n\n\n\n\nOptional and Keyword Arguments\n\n\n\n\nAnonymous Functions\n\n\nParametric Methods\n\n\nVararg Functions\n\n\n\n\nMacros and Metaprogramming\n\n\n\n\n\n\nMetaprogramming in general\n (also describes the \nSymbol\n type and expressions)\n\n\n\n\nMacros\n\n\n\n\nTasks\n\n\n\n\n\n\nTasks\n\n\n\n\nDynamic Scheduling of Tasks\n\n\n\n\nMiscellaneous\n\n\n\n\n\n\nShort Circuit Evaluation", 
            "title": "Home"
        }, 
        {
            "location": "/#instrumentcontroljl", 
            "text": "A  Julia  package for qubit measurement and analysis.", 
            "title": "InstrumentControl.jl"
        }, 
        {
            "location": "/#installation", 
            "text": "Install  National Instruments VISA libraries  (tested with v15.0.1 on Windows 10)  Install  AlazarTech  digitizer drivers and shared libraries (may need to contact AlazarTech) if using Alazar digitizer  Install  VISA.jl  package  Install  Alazar.jl  package  Install  KeysightInstruments.jl  package  Install  ICCommon.jl  package  Install  ICDataServer.jl  package and follow it's  installation procedure  Install  InstrumentControl.jl  package", 
            "title": "Installation"
        }, 
        {
            "location": "/#example-notebooks", 
            "text": "InstrumentControl.jl relies on having physical instruments, communication with a database set up by ICDataServer.jl, and various files with machine specific configuration information in order to run. As such, we provide some example notebooks in order to showcase this package's functionality.  # put example notebooks here", 
            "title": "Example Notebooks"
        }, 
        {
            "location": "/#new-to-julia", 
            "text": "This documentation seeks to provide a higher-level description of the architecture and control-flow of the code, with references to the source code only to facilitate explanation. If the user seeks to understand the source code, while this documentation is a useful aid, aptitude and understanding of the Julia language will be necessary to fully understand it's implementation in a line by line level. For those who have a background in programming, but not in Julia, below is a list of Julia features used in the source code which might not be featured in other languages, along with links to the Julia docs explaining them. It is our hope that, with the reading listed below and this documentation, that any reader with some background in programming would be able to satisfactorily understand the source code:    Types   Julia Types in general  Parametric Types  Singleton Types   Functions and Methods    Optional and Keyword Arguments   Anonymous Functions  Parametric Methods  Vararg Functions   Macros and Metaprogramming    Metaprogramming in general  (also describes the  Symbol  type and expressions)   Macros   Tasks    Tasks   Dynamic Scheduling of Tasks   Miscellaneous    Short Circuit Evaluation", 
            "title": "New to Julia"
        }, 
        {
            "location": "/design/", 
            "text": "Design Summary\n\n\n\n\nWhat should good measurement code do?\n\n\nAnyone who has written code in MATLAB or something comparable (IGOR Pro, in the author's case) has undoubtedly seen spaghetti code. Often there are many copies of a measurement routine that differ only slightly, perhaps in the functionality of what happens inside some for loop, etc.\n\n\nWe would like to have clear, reusable code to avoid redundancy and accidental errors, both of which consume precious time on the part of the experimenters. Consider an archetypal measurement scheme wherein we measure a device's response to various stimuli (perhaps we measure current as a function of applied bias). We should be able to write just one sweep function to do this.\n\n\nThe idea of \nmultiple dispatch\n, natively supported in Julia, permits writing such convenient and abstract code. For example, one sweep function could encompass various sweep methods, where there is a unique method for any particular combination of stimuli to measure a response. Multiple dispatch would be able to discern which method to use based on the \ntypes\n of stimuli and response passed to the function. This is just one example where the advantages of multiple dispatch are obvious. We hope it will more broadly simplify the extension of measurement code while ensuring continued reliability.\n\n\n\n\nSummary of Functionality\n\n\nThis package approaches the problem of measurement in an object oriented manner. As such, Julia types are defined for instrument, instrument properties, independent variables to be swept over during measurement, and dependent variables to be measured. Interfacing with instruments, such as configuring their properties, sweeping through parameters such as voltage, frequency, etc, and actually recording measurement values coming from instruments, are all done through manipulation of instances of these types.\n\n\nA careful framework of abstract super types has been fleshed out in this package, along with sweeping and job scheduling/queueing functionality that expects subtypes of the aforementioned super types. However, each user will have their own unique instruments and measurements to perform. As such, users are expected to write their own type definitions and some methods for those types; but when properly written, they fit in seamlessly into the functionality written around the super types described in the rest of this documentation.\n\n\nNotably, this package implements queueing structure for measurement \"jobs\" , which affords automation of measurements and facilitates use of the same instruments by multiple users. The queue schedules jobs automatically in the background of the Julia interface that the user is using. We call these jobs \"sweep jobs\", in accordance with what one usually thinking of measurement: measuring some dependent variable with respect to some independent variable that is swept across a range of values. When the user executes the \nsweep\n function, job objects are automatically generated, passed to the queue, and scheduled according to their priority without any additional input from the user.\n\n\nFinally, InstrumentControl.jl communicates with a relational database server, set up by \nICDataServer.jl\n, which is used to maintain a log of information for each job. An entry in the database is automatically made for each job submitted to the queue", 
            "title": "Design Summary"
        }, 
        {
            "location": "/design/#design-summary", 
            "text": "", 
            "title": "Design Summary"
        }, 
        {
            "location": "/design/#what-should-good-measurement-code-do", 
            "text": "Anyone who has written code in MATLAB or something comparable (IGOR Pro, in the author's case) has undoubtedly seen spaghetti code. Often there are many copies of a measurement routine that differ only slightly, perhaps in the functionality of what happens inside some for loop, etc.  We would like to have clear, reusable code to avoid redundancy and accidental errors, both of which consume precious time on the part of the experimenters. Consider an archetypal measurement scheme wherein we measure a device's response to various stimuli (perhaps we measure current as a function of applied bias). We should be able to write just one sweep function to do this.  The idea of  multiple dispatch , natively supported in Julia, permits writing such convenient and abstract code. For example, one sweep function could encompass various sweep methods, where there is a unique method for any particular combination of stimuli to measure a response. Multiple dispatch would be able to discern which method to use based on the  types  of stimuli and response passed to the function. This is just one example where the advantages of multiple dispatch are obvious. We hope it will more broadly simplify the extension of measurement code while ensuring continued reliability.", 
            "title": "What should good measurement code do?"
        }, 
        {
            "location": "/design/#summary-of-functionality", 
            "text": "This package approaches the problem of measurement in an object oriented manner. As such, Julia types are defined for instrument, instrument properties, independent variables to be swept over during measurement, and dependent variables to be measured. Interfacing with instruments, such as configuring their properties, sweeping through parameters such as voltage, frequency, etc, and actually recording measurement values coming from instruments, are all done through manipulation of instances of these types.  A careful framework of abstract super types has been fleshed out in this package, along with sweeping and job scheduling/queueing functionality that expects subtypes of the aforementioned super types. However, each user will have their own unique instruments and measurements to perform. As such, users are expected to write their own type definitions and some methods for those types; but when properly written, they fit in seamlessly into the functionality written around the super types described in the rest of this documentation.  Notably, this package implements queueing structure for measurement \"jobs\" , which affords automation of measurements and facilitates use of the same instruments by multiple users. The queue schedules jobs automatically in the background of the Julia interface that the user is using. We call these jobs \"sweep jobs\", in accordance with what one usually thinking of measurement: measuring some dependent variable with respect to some independent variable that is swept across a range of values. When the user executes the  sweep  function, job objects are automatically generated, passed to the queue, and scheduled according to their priority without any additional input from the user.  Finally, InstrumentControl.jl communicates with a relational database server, set up by  ICDataServer.jl , which is used to maintain a log of information for each job. An entry in the database is automatically made for each job submitted to the queue", 
            "title": "Summary of Functionality"
        }, 
        {
            "location": "/ins_meas/", 
            "text": "Interfacing with Instruments and Making Measurements\n\n\n\n\nWhat is an instrument?\n\n\nFor the purposes of this package, an instrument is just something connected to the computer that we need to communicate with, and which can apply some stimulus or measure something. Every instrument may connect to the computer by different hardware, comms protocols, and command dialects.\n\n\nAll instruments are Julia objects, subtypes of the abstract type \nInstrument\n. The implementation of each subtype (it's fields, constructors, etc) depend on the specific instrument.\n\n\n\n\nKeysight\n\n\nKeysight sells AWG and Digitizer module \"cards\", each of which can be connected to a PXI chassis which affords a single connection to the computer, as well as \"PXI backplane\" which can be used to synchronize actions of multiple module \"cards\". All cards are controlled by C libraries programmed by Keysight. We have wrapped these libraries in the \nKeysightInstruments.jl\n package, and InstrumentControl relies on this wrapper for instrument configuration/control.\n\n\n\n\nVISA\n\n\nMany instruments are able to be addressed using the \nVISA\n standard (Virtual Instrument Software Architecture), currently maintained by the IVI Foundation.\n\n\nTo talk to VISA instruments will require the Julia package \nVISA.jl\n as well as the \nNational Instruments VISA libraries\n. Installation instructions are available at each link.\n\n\n\n\nAlazar digitizers\n\n\nDigitizers made by \nAlazarTech\n are notably \nnot\n compatible with the VISA standard. All Alazar digitizers are addressable by an API supplied by the company, which talks to the card through a shared library (a .dll on Windows or .so on Linux). \nInstrumentAlazar\n is an abstract subtype of \nInstrument\n.\n\n\nThe shared library files and API documentation are only available from AlazarTech.\n\n\n\n\nHow do we configure instruments?\n\n\n\n\nProperties\n\n\nInstrument properties are configured and inspected using two functions, \nsetindex!\n and \ngetindex\n, which are methods from the Base module that have been overloaded in this package to work with instrument objects. This results in a convenient and concise syntax (\ncredit due to Oliver Schulz\n for this idea).\n\n\nFor example:\n\n\nawg\n[\nTriggerSlope\n]\n \n=\n \n:\nRising\n\n\nawg\n[\nSampleRate\n]\n \n=\n \n10e6\n\n\n\n\n\n\n\n\nHow do we take measurements?\n\n\n\n\nSource and measure\n\n\nTwo functions are provided to abstract away many kinds of measurements: \nsource\n and \nmeasure\n. In an experiment you source  some stimulus and measure a response. Therefore \nsource\n takes as arguments: an instance of some subtype of the \nStimulus\n type (which can have different fields for different subtypes), as well as the numerical value(s) for the particular stimulus. \nmeasure\n takes as argument an instance of some subtype of type \nResponse\n. The idea is to write new subtypes of \nStimulus\n and \nResponse\n to describe what you are doing, as well as new methods for \nsource\n and \nmeasure\n that know how to communicate with the instrument(s) based on the Stimuli and Response arguments passed to them\n\n\n\n\nStimuli\n\n\nAll stimuli are objects, subtyped from the abstract \nStimulus\n type. Many stimuli, either general or associated with the capabilities of particular instruments, are already implemented. The implementation of each subtype depends on the specific goals of the user: demonstrations of different stimuli being used can be found in the example notebooks.\n\n\nAs a simple example, consider the \nPropertyStimulus\n type (defined in \nICCommon.jl\n) :\n\n\nmutable\n \nstruct\n \nPropertyStimulus\n{\nT\n:\nInstrumentProperty\n}\n \n:\n \nStimulus\n\n    \ntyp\n::\nType\n{\nT\n}\n\n    \nins\n::\nInstrument\n    \n    \ntuple\n::\nTuple\n\n    \naxisname\n::\nSymbol\n\n    \naxislabel\n::\nString\n\n\nend\n\n\n\n\n\n\nwith corresponding source method:\n\n\nfunction\n \nsource\n(\nch\n::\nPropertyStimulus\n,\n \nval\n)\n\n    \nch\n.\nins\n[\nch\n.\ntyp\n,\n \nch\n.\ntuple\n...\n]\n \n=\n \nval\n\n\nend\n\n\n\n\n\n\nNotable among the fields  of \nPropertyStimulus\n are the \ntyp\n and \nins\n fields: \ntyp\n is the instrument property the stimulus object is associated with, and \nins\n is the instrument which that property corresponds to (Type{T} is a special kind of abstract type whose only instance is the object T; visit the \ndocs\n for further discussion). \ntuple\n are essentially \"qualifiers\" or \"infixes\" for the instrument property. For example, if we wanted to change (source) the amplitude of a waveform in a waveform generator instrument with multiple channels, the instrument property at hand is \nSourceLevel\n while \ntuple\n would specify on \nwhat channel\n we are changing the amplitude.  \n\n\nThus, this \nStimulus\n object holds all the necessary information for a \nsource\n method to change the value of instrument property \nT\n to any value passed to it. And the corresponding source function in fact does just that: it calls a setindex! method to change property \nT\n (with qualifiers \ntuple\n) on instrument \nins\n to value \nval\n. Again, stimuli need not be tied to a particular property; rather, this is just one convenient and easily generalizable example.\n\n\nFor a concrete example on the use of \nPropertyStimulus\n, consider needing to source various frequencies in our E8257D signal generator, where the frequency of a signal generator is an instrument property called \nFrequency\n. We can accomplish this task using \nPropertyStimulus\n in the following way:\n\n\nstim\n \n=\n \nPropertyStimulus\n(\nsiggen\n::\nE8257D\n,\n \nFrequency\n)\n\n\nfor\n \nfreq\n \nin\n \n1e9\n:\n1e8\n:\n5e9\n     \n# 1 GHz to 5 GHz in steps of 100 MHz\n\n    \nsource\n(\nstim\n,\n \nfreq\n)\n\n    \n# measure(something)\n\n\nend\n\n\n\n\n\n\nEasy right?\n\n\nNote that one may assign whatever fields and constructor one wishes for a newly created \nStimulus\n subtype. Also, note that not all stimuli need to be associated with a physical instrument. For instance, sourcing a \nDelayStimulus\n will cause the script to block until a specified time after creation of the \nDelayStimulus\n object. Moreover, a Stimulus could also be associated with several instruments. Maybe a stimulus that makes sense for a particular experiment would be to change all gate voltages at once. These gate voltages could of course be sourced by several physical instruments.\n\n\n\n\nResponses\n\n\nAll responses are objects, subtyped from the abstract \nResponse\n type. Usually a response is associated with a particular instrument. The implementation of each subtype depends on the specific goals of the user: demonstrations of different response being used can be found in the example notebooks.\n\n\nAs a simple example, consider the following M3102A Digitizer \nResponse\n type:\n\n\nmutable\n \nstruct\n \nSingleChStream\n \n:\n \nResponse\n\n    \ndig\n::\nInsDigitizerM3102A\n\n    \nch\n::\nInt\n \n#ch for channel\n\n    \ntimeout\n::\nFloat64\n\n\nend\n\n\n\n\n\n\nwith corresponding \nmeasure\n method:\n\n\nfunction\n \nmeasure\n(\nresp\n::\nSingleChStream\n)\n\n    \ndig\n \n=\n \nresp\n.\ndig\n\n    \nch\n \n=\n \nresp\n.\nch\n\n    \ntimeout\n  \n=\n \nceil\n(\nresp\n.\ntimeout\n \n*\n10e3\n)\n \n#timeout should be integer in units of milliseconds\n\n    \ndaq_points\n \n=\n \nInt\n(\nceil\n((\nresp\n.\ntimeout\n*\n \n(\n500e6\n))))\n \n#number of samples expected\n\n\n    \ndig\n[\nDAQTrigMode\n,\n \nch\n]\n \n=\n \n:\nAuto\n\n    \ndig\n[\nDAQCycles\n,\n \nch\n]\n \n=\n \n-\n1\n \n#infinite number of cycles\n\n    \ndig\n[\nDAQPointsPerCycle\n,\n \nch\n]\n \n=\n \ndaq_points\n\n\n    \n@KSerror_handler\n \nSD_AIN_DAQstart\n(\ndig\n.\nID\n,\n \nch\n)\n\n    \ndata\n \n=\n \n@KSerror_handler\n \nSD_AIN_DAQread\n(\ndig\n.\nID\n,\n \nch\n,\n \ndaq_points\n,\n \ntimeout\n)\n\n    \nreturn\n \ndata\n\n\nend\n\n\n\n\n\n\nThis response type would be used for measuring data on the M3102A digitizer, upon a call to it's corresponding \nmeasure\n function, on channel \nch\n continuously for a time equal to the \ntimeout\n field of the digitizer. The measure function properly configures the digitizer, starts the DAQ for trigger acquisition, and takes data for the computer through the \nSD_AIN_DAQread\n function. Thus, to perform this type of data acquisition, one would merely need to instantiate a \nSingleChStream\n object with desired digitizer object, channel, and timeout, and call \nmeasure\n with that object as input. Easy right?\n\n\nIt is good to keep in mind responses need not come from instruments. For test purposes, suppose we want to mimic a measurement by generating random numbers. \nRandomResponse\n produces a random number in the unit interval when it is measured. A \nTimerResponse\n will measure the time since creation of the \nTimerResponse\n object.\n\n\n\n\nDifference between stimuli and instrument properties\n\n\nBecause a stimulus is defined so broadly, the difference between a stimulus and an instrument property is not obvious. While in many cases there is an overlap between stimuli and properties, a stimulus is like a generalized instrument property: sourcing a stimulus may entail configuring zero or more instrument properties, on zero or more different instruments. As was mentioned earlier, a useful stimulus could be to change gate voltages on multiple different instruments all at once.\n\n\nIt is useful to think of a stimulus as something which has a chance to react to what you are measuring. For example, this could be applied voltage, sourced by one or more instruments. The applied voltages would be seen by the device under test, which would respond accordingly. The stimulus could also just be a time delay, provided by the measurement computer. It could even be the number of threads used by Julia for real-time processing.\n\n\nAn instrument property is any persistent setting of an instrument. Tweaking an instrument property could affect the device under test, but it might not. Averaging is a good example. With averaging a measurement may look less noisy, but your device under test doesn't know the difference.", 
            "title": "Instruments/Measurements"
        }, 
        {
            "location": "/ins_meas/#interfacing-with-instruments-and-making-measurements", 
            "text": "", 
            "title": "Interfacing with Instruments and Making Measurements"
        }, 
        {
            "location": "/ins_meas/#what-is-an-instrument", 
            "text": "For the purposes of this package, an instrument is just something connected to the computer that we need to communicate with, and which can apply some stimulus or measure something. Every instrument may connect to the computer by different hardware, comms protocols, and command dialects.  All instruments are Julia objects, subtypes of the abstract type  Instrument . The implementation of each subtype (it's fields, constructors, etc) depend on the specific instrument.", 
            "title": "What is an instrument?"
        }, 
        {
            "location": "/ins_meas/#keysight", 
            "text": "Keysight sells AWG and Digitizer module \"cards\", each of which can be connected to a PXI chassis which affords a single connection to the computer, as well as \"PXI backplane\" which can be used to synchronize actions of multiple module \"cards\". All cards are controlled by C libraries programmed by Keysight. We have wrapped these libraries in the  KeysightInstruments.jl  package, and InstrumentControl relies on this wrapper for instrument configuration/control.", 
            "title": "Keysight"
        }, 
        {
            "location": "/ins_meas/#visa", 
            "text": "Many instruments are able to be addressed using the  VISA  standard (Virtual Instrument Software Architecture), currently maintained by the IVI Foundation.  To talk to VISA instruments will require the Julia package  VISA.jl  as well as the  National Instruments VISA libraries . Installation instructions are available at each link.", 
            "title": "VISA"
        }, 
        {
            "location": "/ins_meas/#alazar-digitizers", 
            "text": "Digitizers made by  AlazarTech  are notably  not  compatible with the VISA standard. All Alazar digitizers are addressable by an API supplied by the company, which talks to the card through a shared library (a .dll on Windows or .so on Linux).  InstrumentAlazar  is an abstract subtype of  Instrument .  The shared library files and API documentation are only available from AlazarTech.", 
            "title": "Alazar digitizers"
        }, 
        {
            "location": "/ins_meas/#how-do-we-configure-instruments", 
            "text": "", 
            "title": "How do we configure instruments?"
        }, 
        {
            "location": "/ins_meas/#properties", 
            "text": "Instrument properties are configured and inspected using two functions,  setindex!  and  getindex , which are methods from the Base module that have been overloaded in this package to work with instrument objects. This results in a convenient and concise syntax ( credit due to Oliver Schulz  for this idea).  For example:  awg [ TriggerSlope ]   =   : Rising  awg [ SampleRate ]   =   10e6", 
            "title": "Properties"
        }, 
        {
            "location": "/ins_meas/#how-do-we-take-measurements", 
            "text": "", 
            "title": "How do we take measurements?"
        }, 
        {
            "location": "/ins_meas/#source-and-measure", 
            "text": "Two functions are provided to abstract away many kinds of measurements:  source  and  measure . In an experiment you source  some stimulus and measure a response. Therefore  source  takes as arguments: an instance of some subtype of the  Stimulus  type (which can have different fields for different subtypes), as well as the numerical value(s) for the particular stimulus.  measure  takes as argument an instance of some subtype of type  Response . The idea is to write new subtypes of  Stimulus  and  Response  to describe what you are doing, as well as new methods for  source  and  measure  that know how to communicate with the instrument(s) based on the Stimuli and Response arguments passed to them", 
            "title": "Source and measure"
        }, 
        {
            "location": "/ins_meas/#stimuli", 
            "text": "All stimuli are objects, subtyped from the abstract  Stimulus  type. Many stimuli, either general or associated with the capabilities of particular instruments, are already implemented. The implementation of each subtype depends on the specific goals of the user: demonstrations of different stimuli being used can be found in the example notebooks.  As a simple example, consider the  PropertyStimulus  type (defined in  ICCommon.jl ) :  mutable   struct   PropertyStimulus { T : InstrumentProperty }   :   Stimulus \n     typ :: Type { T } \n     ins :: Instrument     \n     tuple :: Tuple \n     axisname :: Symbol \n     axislabel :: String  end   with corresponding source method:  function   source ( ch :: PropertyStimulus ,   val ) \n     ch . ins [ ch . typ ,   ch . tuple ... ]   =   val  end   Notable among the fields  of  PropertyStimulus  are the  typ  and  ins  fields:  typ  is the instrument property the stimulus object is associated with, and  ins  is the instrument which that property corresponds to (Type{T} is a special kind of abstract type whose only instance is the object T; visit the  docs  for further discussion).  tuple  are essentially \"qualifiers\" or \"infixes\" for the instrument property. For example, if we wanted to change (source) the amplitude of a waveform in a waveform generator instrument with multiple channels, the instrument property at hand is  SourceLevel  while  tuple  would specify on  what channel  we are changing the amplitude.    Thus, this  Stimulus  object holds all the necessary information for a  source  method to change the value of instrument property  T  to any value passed to it. And the corresponding source function in fact does just that: it calls a setindex! method to change property  T  (with qualifiers  tuple ) on instrument  ins  to value  val . Again, stimuli need not be tied to a particular property; rather, this is just one convenient and easily generalizable example.  For a concrete example on the use of  PropertyStimulus , consider needing to source various frequencies in our E8257D signal generator, where the frequency of a signal generator is an instrument property called  Frequency . We can accomplish this task using  PropertyStimulus  in the following way:  stim   =   PropertyStimulus ( siggen :: E8257D ,   Frequency )  for   freq   in   1e9 : 1e8 : 5e9       # 1 GHz to 5 GHz in steps of 100 MHz \n     source ( stim ,   freq ) \n     # measure(something)  end   Easy right?  Note that one may assign whatever fields and constructor one wishes for a newly created  Stimulus  subtype. Also, note that not all stimuli need to be associated with a physical instrument. For instance, sourcing a  DelayStimulus  will cause the script to block until a specified time after creation of the  DelayStimulus  object. Moreover, a Stimulus could also be associated with several instruments. Maybe a stimulus that makes sense for a particular experiment would be to change all gate voltages at once. These gate voltages could of course be sourced by several physical instruments.", 
            "title": "Stimuli"
        }, 
        {
            "location": "/ins_meas/#responses", 
            "text": "All responses are objects, subtyped from the abstract  Response  type. Usually a response is associated with a particular instrument. The implementation of each subtype depends on the specific goals of the user: demonstrations of different response being used can be found in the example notebooks.  As a simple example, consider the following M3102A Digitizer  Response  type:  mutable   struct   SingleChStream   :   Response \n     dig :: InsDigitizerM3102A \n     ch :: Int   #ch for channel \n     timeout :: Float64  end   with corresponding  measure  method:  function   measure ( resp :: SingleChStream ) \n     dig   =   resp . dig \n     ch   =   resp . ch \n     timeout    =   ceil ( resp . timeout   * 10e3 )   #timeout should be integer in units of milliseconds \n     daq_points   =   Int ( ceil (( resp . timeout *   ( 500e6 ))))   #number of samples expected \n\n     dig [ DAQTrigMode ,   ch ]   =   : Auto \n     dig [ DAQCycles ,   ch ]   =   - 1   #infinite number of cycles \n     dig [ DAQPointsPerCycle ,   ch ]   =   daq_points \n\n     @KSerror_handler   SD_AIN_DAQstart ( dig . ID ,   ch ) \n     data   =   @KSerror_handler   SD_AIN_DAQread ( dig . ID ,   ch ,   daq_points ,   timeout ) \n     return   data  end   This response type would be used for measuring data on the M3102A digitizer, upon a call to it's corresponding  measure  function, on channel  ch  continuously for a time equal to the  timeout  field of the digitizer. The measure function properly configures the digitizer, starts the DAQ for trigger acquisition, and takes data for the computer through the  SD_AIN_DAQread  function. Thus, to perform this type of data acquisition, one would merely need to instantiate a  SingleChStream  object with desired digitizer object, channel, and timeout, and call  measure  with that object as input. Easy right?  It is good to keep in mind responses need not come from instruments. For test purposes, suppose we want to mimic a measurement by generating random numbers.  RandomResponse  produces a random number in the unit interval when it is measured. A  TimerResponse  will measure the time since creation of the  TimerResponse  object.", 
            "title": "Responses"
        }, 
        {
            "location": "/ins_meas/#difference-between-stimuli-and-instrument-properties", 
            "text": "Because a stimulus is defined so broadly, the difference between a stimulus and an instrument property is not obvious. While in many cases there is an overlap between stimuli and properties, a stimulus is like a generalized instrument property: sourcing a stimulus may entail configuring zero or more instrument properties, on zero or more different instruments. As was mentioned earlier, a useful stimulus could be to change gate voltages on multiple different instruments all at once.  It is useful to think of a stimulus as something which has a chance to react to what you are measuring. For example, this could be applied voltage, sourced by one or more instruments. The applied voltages would be seen by the device under test, which would respond accordingly. The stimulus could also just be a time delay, provided by the measurement computer. It could even be the number of threads used by Julia for real-time processing.  An instrument property is any persistent setting of an instrument. Tweaking an instrument property could affect the device under test, but it might not. Averaging is a good example. With averaging a measurement may look less noisy, but your device under test doesn't know the difference.", 
            "title": "Difference between stimuli and instrument properties"
        }, 
        {
            "location": "/sweep/", 
            "text": "Sweeps\n\n\nWhen thinking of measurement, one generally imagines measuring some dependent variable with respect to some independent variable that is swept across a range of values. While the devil is in the details of the measurement, with Julia's multiple dispatch functionality, it should be possible to abstract executing a \"sweep\" to just one function, thus affording a simple but general interface for the user to conduct his measurements.\n\n\nMoreover, the need to automate measurements and facilitate use of the same instruments by multiple users warrants some sort of queueing structure for \"sweeps\", which is maintained automatically in the background of the Julia interface that the user is using.\n\n\nWe have achieved precisely these goals in a object-oriented way with our \"Sweep\" portion of IntrumentControl.jl\" package. Below we describe the functionality meant for the user: how to use \nResponse\n and \nStimulus\n objects as well as \nsource\n and \nmeasure\n functions to submit a sweep, how to interact with the sweep job to see it's result, estimated time of completion, etc. In \nImplementation\n we describe how exactly sweep and queueing functionality is implemented\n\n\n\n\nPrerequisites for a Sweep\n\n\nA sweep is submitted by the user via the \nsweep\n function:\n\n\nsweep\n{\nN\n}(\ndep\n::\nResponse\n,\n \nindep\n::\nVararg\n{\nTuple\n{\nStimulus\n,\n \nAbstractVector\n},\n \nN\n};\n \npriority\n \n=\n \nNORMAL\n)\n\n\n\n\n\n\nsweep\n measures a response as a function of an arbitrary number of stimuli, sourced over the values given in the \nAbstractVector\n input, and returns a handle to the sweep job in the form of a \nSweepJob\n object, which will be discussed more in detail in \nImplementation\n. This can be used to access the results while the sweep is being measured. \npriority\n is an \nInt\n from 0 to \ntypemax(Int)\n, inclusive, and is used to prioritize the next sweep in a queue (with multiple sweeps) to be run. It is typically one of the following:\n\n\n\n\nHIGH == 10\n\n\nNORMAL == 5\n\n\nLOW == 0\n\n\n\n\nThus, the \npriority\n keyword argument may be \nLOW\n, \nNORMAL\n, or \nHIGH\n, or any integer greater than or equal to zero.\n\n\nThe \nsweep\n functions assumes that appropriate \nmeasure\n methods have been written for the \ndep\n object passed, and that appropriate \nsource\n methods have been written for all \nStimulus\n objects in the passed \nindep\n argument. Thus, to use the function the user must have defined \nResponse\n and \nStimulus\n subtypes, as well as \nsource\n and \nmeasure\n functions for those types.\n\n\nFor example, ... put example here with definition of \nStimulus\n, \nsource\n, \nresponse\n, \nmeasure\n, and \nsweep\n\n\n\n\nQueueing\n\n\nInstrumentControl employs a queueing structure for job handling through manipulation of \nSweepJob\n objects, which are instantiated when the \nsweep\n function is used. The actual \"queue\" is a \nSweepJobQueue\n object, described more in detail in \nImplementation\n. When the InstrumentControl package is imported by the user, a 'SweepJobQueue' object, as well as communication with the database set up by \nICDataServer.jl\n, is automatically initialized; in the documentation this object is referred to as the \"default sweep job queue object\".\n\n\nWhen \nsweep\n is used, a job ID is automatically obtained for the new sweep job (which exists in Julia as a \nSweepJob\n object) via communication with the database; the job is then put into the queue with the job ID as it's identifier. In essence, a \nSweepJobQueue\n object can be thought of as a \ncollection\n (in the Julia sense) of \nSweepJob\n objects, indexed by their job ID, along with other fields and helper functions for automatic scheduling of jobs in the background. The queue prioritizes jobs based on their priorities; for equal priority values, the job submitted earlier takes precedent.\n\n\n\n\nInteracting with a sweep job\n\n\nWhen \nsweep\n is called, the returned \nSweepJob\n object displays it's job ID as well as it's status (waiting, running, done, etc), priority, progress (percentage of job completed), and time of submission. Both the job ID and the returned \nSweepJob\n object itself can be used to interact with the job in the following ways:\n\n\n#\n\n\nBase.eta\n \n \nFunction\n.\n\n\neta(x)\n\n\n\n\n\nDirichlet eta function $\\eta(s) = \\sum^\\infty_{n=1}(-1)^{n-1}/n^{s}$.\n\n\nsource\n\n\neta(x::SweepJob)\n\n\n\n\n\nReturn the estimated time of completion for sweep job \nx\n. It estimates this time by first calculating the amount of time passed from when the job was submitted to the time the function is called, and then calculating the ETA based on the current progress of the job and this passed time\n\n\nsource\n\n\n#\n\n\nInstrumentControl.progress\n \n \nFunction\n.\n\n\nprogress(x::SweepJob)\n\n\n\n\n\nReturns the sweep job progress, a \nFloat64\n between 0 and 1 (inclusive).\n\n\nsource\n\n\n#\n\n\nInstrumentControl.jobs\n \n \nMethod\n.\n\n\njobs(job_id)\n\n\n\n\n\nReturn the \nSweepJob\n object associated with \njob_id\n scheduled in the default sweep job queue object.\n\n\nsource\n\n\n#\n\n\nInstrumentControl.result\n \n \nFunction\n.\n\n\nresult(sj::SweepJob)\n\n\n\n\n\nReturns the result array of a sweep job \nsj\n. Throws an error if the result array has not yet been initialized.\n\n\nsource\n\n\nresult(i::Integer)\n\n\n\n\n\nReturns a result array by job id in job scheduled in the default sweep job queue object.\n\n\nsource\n\n\nresult()\n\n\n\n\n\nReturns the result array from the last finished or aborted job scheduled in the default sweep job queue object.\n\n\nsource\n\n\n#\n\n\nInstrumentControl.abort!\n \n \nFunction\n.\n\n\nabort!(x::SweepJob)\n\n\n\n\n\nAbort a sweep job. Practically, the status of the job is changed to \"Aborted\", and the job is put into the update_channel of the default \nSweepJobQueue\n object. This automatically leads to: update of job metadata in the \nSweepJob\n object as well as in the ICDataServer, update of queue metadata, archiving of the job's result array, and start of the highest priority job in the default sweep job queue. Thus, aborting a job is guaranteed to bail out of the sweep in such a way that the data that has been measured for most recent sourcing of a stimulus, i.e. at the very start of a \"for loop\" in \nInstrumentControl._sweep!\n. You can also abort a sweep before it even begins.\n\n\nPresently this function does not interrupt \nmeasure\n, so if a single measurement takes a long time then the sweep is only aborted after that finishes.\n\n\nsource\n\n\nabort!()\n\n\n\n\n\nAbort the currently running job (if any). If no job is running, the method does not throw an error.\n\n\nsource\n\n\n#\n\n\nInstrumentControl.prune!\n \n \nFunction\n.\n\n\nprune!(q::SweepJobQueue)\n\n\n\n\n\nPrunes a \nSweepJobQueue\n of all \nInstrumentControl.SweepJob\ns with a status of \nDone\n or \nAborted\n. This will have the side effect of releasing old sweep results if there remain no references to them in julia, however they should still be saved to disk and can be recovered later.\n\n\nsource", 
            "title": "Sweep Jobs"
        }, 
        {
            "location": "/sweep/#sweeps", 
            "text": "When thinking of measurement, one generally imagines measuring some dependent variable with respect to some independent variable that is swept across a range of values. While the devil is in the details of the measurement, with Julia's multiple dispatch functionality, it should be possible to abstract executing a \"sweep\" to just one function, thus affording a simple but general interface for the user to conduct his measurements.  Moreover, the need to automate measurements and facilitate use of the same instruments by multiple users warrants some sort of queueing structure for \"sweeps\", which is maintained automatically in the background of the Julia interface that the user is using.  We have achieved precisely these goals in a object-oriented way with our \"Sweep\" portion of IntrumentControl.jl\" package. Below we describe the functionality meant for the user: how to use  Response  and  Stimulus  objects as well as  source  and  measure  functions to submit a sweep, how to interact with the sweep job to see it's result, estimated time of completion, etc. In  Implementation  we describe how exactly sweep and queueing functionality is implemented", 
            "title": "Sweeps"
        }, 
        {
            "location": "/sweep/#prerequisites-for-a-sweep", 
            "text": "A sweep is submitted by the user via the  sweep  function:  sweep { N }( dep :: Response ,   indep :: Vararg { Tuple { Stimulus ,   AbstractVector },   N };   priority   =   NORMAL )   sweep  measures a response as a function of an arbitrary number of stimuli, sourced over the values given in the  AbstractVector  input, and returns a handle to the sweep job in the form of a  SweepJob  object, which will be discussed more in detail in  Implementation . This can be used to access the results while the sweep is being measured.  priority  is an  Int  from 0 to  typemax(Int) , inclusive, and is used to prioritize the next sweep in a queue (with multiple sweeps) to be run. It is typically one of the following:   HIGH == 10  NORMAL == 5  LOW == 0   Thus, the  priority  keyword argument may be  LOW ,  NORMAL , or  HIGH , or any integer greater than or equal to zero.  The  sweep  functions assumes that appropriate  measure  methods have been written for the  dep  object passed, and that appropriate  source  methods have been written for all  Stimulus  objects in the passed  indep  argument. Thus, to use the function the user must have defined  Response  and  Stimulus  subtypes, as well as  source  and  measure  functions for those types.  For example, ... put example here with definition of  Stimulus ,  source ,  response ,  measure , and  sweep", 
            "title": "Prerequisites for a Sweep"
        }, 
        {
            "location": "/sweep/#queueing", 
            "text": "InstrumentControl employs a queueing structure for job handling through manipulation of  SweepJob  objects, which are instantiated when the  sweep  function is used. The actual \"queue\" is a  SweepJobQueue  object, described more in detail in  Implementation . When the InstrumentControl package is imported by the user, a 'SweepJobQueue' object, as well as communication with the database set up by  ICDataServer.jl , is automatically initialized; in the documentation this object is referred to as the \"default sweep job queue object\".  When  sweep  is used, a job ID is automatically obtained for the new sweep job (which exists in Julia as a  SweepJob  object) via communication with the database; the job is then put into the queue with the job ID as it's identifier. In essence, a  SweepJobQueue  object can be thought of as a  collection  (in the Julia sense) of  SweepJob  objects, indexed by their job ID, along with other fields and helper functions for automatic scheduling of jobs in the background. The queue prioritizes jobs based on their priorities; for equal priority values, the job submitted earlier takes precedent.", 
            "title": "Queueing"
        }, 
        {
            "location": "/sweep/#interacting-with-a-sweep-job", 
            "text": "When  sweep  is called, the returned  SweepJob  object displays it's job ID as well as it's status (waiting, running, done, etc), priority, progress (percentage of job completed), and time of submission. Both the job ID and the returned  SweepJob  object itself can be used to interact with the job in the following ways:  #  Base.eta     Function .  eta(x)  Dirichlet eta function $\\eta(s) = \\sum^\\infty_{n=1}(-1)^{n-1}/n^{s}$.  source  eta(x::SweepJob)  Return the estimated time of completion for sweep job  x . It estimates this time by first calculating the amount of time passed from when the job was submitted to the time the function is called, and then calculating the ETA based on the current progress of the job and this passed time  source  #  InstrumentControl.progress     Function .  progress(x::SweepJob)  Returns the sweep job progress, a  Float64  between 0 and 1 (inclusive).  source  #  InstrumentControl.jobs     Method .  jobs(job_id)  Return the  SweepJob  object associated with  job_id  scheduled in the default sweep job queue object.  source  #  InstrumentControl.result     Function .  result(sj::SweepJob)  Returns the result array of a sweep job  sj . Throws an error if the result array has not yet been initialized.  source  result(i::Integer)  Returns a result array by job id in job scheduled in the default sweep job queue object.  source  result()  Returns the result array from the last finished or aborted job scheduled in the default sweep job queue object.  source  #  InstrumentControl.abort!     Function .  abort!(x::SweepJob)  Abort a sweep job. Practically, the status of the job is changed to \"Aborted\", and the job is put into the update_channel of the default  SweepJobQueue  object. This automatically leads to: update of job metadata in the  SweepJob  object as well as in the ICDataServer, update of queue metadata, archiving of the job's result array, and start of the highest priority job in the default sweep job queue. Thus, aborting a job is guaranteed to bail out of the sweep in such a way that the data that has been measured for most recent sourcing of a stimulus, i.e. at the very start of a \"for loop\" in  InstrumentControl._sweep! . You can also abort a sweep before it even begins.  Presently this function does not interrupt  measure , so if a single measurement takes a long time then the sweep is only aborted after that finishes.  source  abort!()  Abort the currently running job (if any). If no job is running, the method does not throw an error.  source  #  InstrumentControl.prune!     Function .  prune!(q::SweepJobQueue)  Prunes a  SweepJobQueue  of all  InstrumentControl.SweepJob s with a status of  Done  or  Aborted . This will have the side effect of releasing old sweep results if there remain no references to them in julia, however they should still be saved to disk and can be recovered later.  source", 
            "title": "Interacting with a sweep job"
        }, 
        {
            "location": "/implementation/", 
            "text": "Implementation overview\n\n\n\n\nCode organization\n\n\n\n\nEach instrument is defined within its own module, a submodule of \nInstrumentControl\n.\n\n\n\n\nEach instrument is a subtype of \nInstrument\n. By convention, instrument model numbers are used for module definitions (e.g. \nAWG5014C\n), so type names have \"Ins\" prepended (e.g. \nInsAWG5014\n).\n\n\n\n\nLow-level wrappers for shared libraries are kept in their own packages (e.g. \nVISA\n, \nAlazar\n, and \nKeysightInstruments\n calls).\n\n\n\n\nThis way, at least some code can be reused if someone else does not want to use our codebase.\n\n\n\n\nAll sweep related type definitions and functions described in \nSweep Jobs\n\n\n\n\ncan be found in \nsrc/Sweep.jl\n\n\n\n\nAbstract type definitions like \nInstrument\n and \nStimulus\n, are defined in\n\n\n\n\nICCommon.jl\n  \n\n\n\n\nsrc/Definitions.jl\n contains some definitions of other commonly used functions\n\n\n\n\nand types. \nsrc/config.jl\n parses information in \ndeps/config.json\n for talking to the database set up by ICDataServer, such as username information, database server address, path for saving results of sweeps, and stores it in a dictionary for access to all other functions that need this information to communicate with the database\n\n\n\n\nCommunication with ICDataServer\n\n\nThe functionality of the InstrumentControl.jl package is intertwined with the \nICDataServer.jl\n package. ICDataServer sets up a relational database (RDBMS) with which it communicates with through SQL. InstrumentControl talks to that database; this database is used to maintain a log of information for each job: the job is identified by the job ID, and it mantains any metadata specified by the database creator. In its current implementation, the data saved to the database is the time of job submission, the time of job completion, and the latest job status, but we hope to add more logging functionality to the code over time.\n\n\nWhen \nsweep\n is executed, the function communicates with the ICDataServer to create a new entry in the database table; the identifier of the new entry is a new job ID that the RDMS itself creates. ICDataServer then communicates back to InstrumentControl with this particular job ID and the time of submission; this job metadata is immediately stored in the \nSweepJob\n object (created by the \nsweep\n function as a handle to the new job). The job is then queued with the provided job ID as it's identifier.\n\n\nThe actual communication between the two packages is mediated by the popular \nZeroMQ\n distributed messaging software; we utilize it's \nZMQ\n Julia interface. While the reader is encouraged to go to these links for in-depth information, what you essentially need to communicate between a client and a server with ZeroMQ is a \nContext\n and a \nsocket\n. In Julia, a \nZMQ.Context\n object provides the framework for communication via a TCP connection (or any analagous form of communication). The client and server respectively will connect to a TCP port to send/receive information. The point of entry/exit for information being passed along this TCP connection are the ZMQ.Socket objects; they \"bind\" to the TCP ports and are the objects that the user actually calls on the send and receive information.\n\n\nWhen InstrumentControl is imported, a \nZMQ.Context\n object is automatically initialized. \nZMQ.Socket\n objects are initialized in the first instance of communication with the ICDataServer, and the same object is used thereafter for communication within the same usage session. The socket objects are automatically bound to TCP ports that the user specifies in the \ndeps/config.json\n file. InstrumentControl and ICDataServer communicate by binding to the same TCP connection.\n\n\n\n\nMetaprogramming for VISA instruments\n\n\nMany commercial instruments support a common communications protocol and command syntax (VISA and SCPI respectively). For such instruments, methods for \nsetindex!\n and \ngetindex\n, as well as \nInstrument\n subtype and \nInstrumentProperty\n subtype definitions, can be generated with metaprogramming, rather than typing them out explicitly.\n\n\nThe file \nsrc/MetaprogrammingVISA.jl\n is used heavily for code generation based on JSON template files. Since much of the logic for talking to instruments is the same between VISA instruments, in some cases no code needs to be written to control a new instrument provided an appropriate template file is prepared. The metaprogramming functions are described below although they are not intended to be used interactively.\n\n\n#\n\n\nInstrumentControl.insjson\n \n \nFunction\n.\n\n\ninsjson(file::AbstractString)\n\n\n\n\n\nParses a JSON file with a standardized schema to describe how to control an instrument.\n\n\nHere is an example of a valid JSON file with valid schema for parsing:\n\n\n{\n\n    \ninstrument\n:{\n\n            \nmodule\n:\nE5071C\n,\n\n            \ntype\n:\nInsE5071C\n,\n\n            \nmake\n:\nKeysight\n,\n\n            \nmodel\n:\nE5071C\n,\n\n            \nwriteterminator\n:\n\\n\n\n    \n},\n\n    \nproperties\n:[\n\n        \n{\n\n            \ncmd\n:\n:CALCch:TRACtr:CORR:EDEL:TIME\n,\n\n            \ntype\n:\nVNA.ElectricalDelay\n,\n\n            \nvalues\n:[\n\n                \nv::Real\n\n            \n],\n\n            \ninfixes\n:[\n\n                \nch::Integer=1\n,\n\n                \ntr::Integer=1\n\n            \n],\n\n            \ndoc\n:\n \nMy documentation\n\n        \n}\n\n    \n]\n\n\n}\n\n\n\n\n\n\nJSON.parse\n takes such a file and makes an 'instrument' dictionary and a 'properties' array. The \ninstrument\n dictionary is described in the \n@generate_instruments\n documentation. The \nproperties\n array contains one or more dictionaries, each with keys:\n\n\n\n\ncmd\n: Specifies what must be sent to the instrument (it should be terminated\n\n\n\n\nwith \"?\" for query-only commands). The lower-case characters are replaced by \"infixes\", which are either numerical arguments or strings\n\n\n\n\ntype\n: Specifies the \nInstrumentProperty\n subtype to use \ncmd\n.\n\n\nvalues\n: Specifies the required argument for \nsetindex!\n, which will appear\n\n\n\n\nafter \ncmd\n in the string sent to the instrument.\n\n\n\n\ninfixes\n: Specifies the infix arguments to be put in \ncmd\n. This key is not\n\n\n\n\nrequired if there are no infixes.\n\n\n\n\ndoc\n: Specifies documentation for the generated Julia functions. This key\n\n\n\n\nis not required if there is no documentation. This is used not only for interactive help but also in generating the documentation you are reading.\n\n\nThe value of the \nproperties.type\n field and entries in the \nproperties.values\n and \nproperties.infixes\n arrays are parsed into expressions or symbols for further manipulation. All generated dictionary keys are also converted to symbols for further manipulation.\n\n\nsource\n\n\n#\n\n\nInstrumentControl.@generate_instruments\n \n \nMacro\n.\n\n\n@generate_instruments(metadata)\n\n\n\n\n\nThis macro takes a dictionary of metadata, typically obtained from a call to \ninsjson\n. It operates on the \n:instrument\n field of the dictionary which is expected to have the following structure:\n\n\n\n\nmodule\n: The module name. Can already exist but is created if it does not.\n\n\n\n\nThis field is converted from a string to a \nSymbol\n by \ninsjson\n.\n\n\n\n\ntype\n: The name of the type to create for the new instrument.\n\n\n\n\nThis field is converted from a string to a \nSymbol\n by \ninsjson\n.\n\n\n\n\nsuper\n: This field is optional. If provided it will be the supertype of\n\n\n\n\nthe new instrument type, otherwise the supertype will be \nInstrument\n. This field is converted from a string to a \nSymbol\n by \ninsjson\n.\n\n\n\n\nmake\n: The make of the instrument, e.g. Keysight, Tektronix, etc.\n\n\nmodel\n: The model of the instrument, e.g. E5071C, AWG5014C, etc.\n\n\nwriteterminator\n: Write termination string for sending SCPI commands.\n\n\n\n\nThe macro imports required modules and methods, defines and exports the \nInstrument\n subtype, and defines and exports and the \nmake\n and \nmodel\n methods if they do not exist already (note generic functions \nmake\n and \nmodel\n are defined in \nsrc/Definitions.jl\n).\n\n\nBy convention we typically have the module name be the same as the model name, and the type is just the model prefixed by \"Ins\", e.g. \nInsE5071C\n. This is not required.\n\n\nsource\n\n\n#\n\n\nInstrumentControl.@generate_properties\n \n \nMacro\n.\n\n\n@generate_properties(metadata)\n\n\n\n\n\nThis macro takes a dictionary of metadata, typically obtained from a call to \ninsjson\n. It operates on the \n:properties\n field of the dictionary, which is expected to be a list of dictionaries with information on each \"property\" of the instrument. This macro specifically operates on the \n:type\n field of each property dictionary; this field contains the name of the type we would like to assign to a given property of the instrument.\n\n\nFor every property dictionary, the macro first checks if a type with name corresponding to the dictionary's \n:type\n field  has already been defined. If not, it then defines an abstract type with that name, and makes it a subtype of the \nInstrumentProperty\n type defined in the ICCommon package. The macro then finally exports that type\n\n\nsource\n\n\n#\n\n\nInstrumentControl.@generate_handlers\n \n \nMacro\n.\n\n\n@generate_handlers(instype, p)\n\n\n\n\n\nThis macro takes a symbol \ninstype\n bound to an \nInstrument\n subtype (i.e. if the symbol was evaluated, it would return an \nInstrument\n subtype ), and a property dictionary \np\n located in the \n:properties\n field of the dictionary of metadata generated by a call to \ninsjson\n. with the auxiliary JSON file described above.\n\n\nThis macro is written to handle the cases where an instrument command does not accept numerical arguments, but rather a small set of options. Here is an example of the property dictionary (prior to parsing) for such a command, which sets/gets the format for a given channel and trace on the E5071C vector network analyzer:\n\n\n{\n\n    \ncmd\n:\n:CALCch:TRACtr:FORM\n,\n\n    \ntype\n:\nVNAFormat\n,\n\n    \nvalues\n:[\n\n        \nv::Symbol in symbols\n\n    \n],\n\n    \nsymbols\n:{\n\n        \nLogMagnitude\n:\nMLOG\n,\n\n        \nPhase\n:\nPHAS\n,\n\n        \nGroupDelay\n:\nGDEL\n,\n\n        \nSmithLinear\n:\nSLIN\n,\n\n        \nSmithLog\n:\nSLOG\n,\n\n        \nSmithComplex\n:\nSCOM\n,\n\n        \nSmith\n:\nSMIT\n,\n\n        \nSmithAdmittance\n:\nSADM\n,\n\n        \nPolarLinear\n:\nPLIN\n,\n\n        \nPolarLog\n:\nPLOG\n,\n\n        \nPolarComplex\n:\nPOL\n,\n\n        \nLinearMagnitude\n:\nMLIN\n,\n\n        \nSWR\n:\nSWR\n,\n\n        \nRealPart\n:\nREAL\n,\n\n        \nImagPart\n:\nIMAG\n,\n\n        \nExpandedPhase\n:\nUPH\n,\n\n        \nPositivePhase\n:\nPPH\n\n    \n},\n\n    \ninfixes\n:[\n\n        \nch::Integer=1\n,\n\n        \ntr::Integer=1\n\n    \n],\n\n    \ndoc\n:\nHey\n\n\n}\n\n\n\n\n\n\nWe see here that the \nvalues\n key is saying that we are only going to accept \nSymbol\n type for our \nsetindex!\n method and the symbol has to come out of \nsymbols\n, a dictionary that is defined on the next line. The keys of this dictionary are going to be interpreted as symbols (e.g. \n:LogMagnitude\n) and the values are just ASCII strings to be sent to the instrument. We want to associate these symbols with the specific ASCII strings because these strings are not very descriptive, so we would like a more descriptive handle for them, as well as a handle that could be potentially shared between different instruments which have different \"spellings\" for the same command. We make the handles symbols because they are a more flexible type (which can always be parsed into strings)\n\n\ngenerate_handlers\n makes a bidirectional mapping between the symbols and the strings. For the example above, the macro defines the following functions:\n\n\nfunction\n \nsymbols\n(\nins\n::\nInsE5071C\n,\n \n::\nType\n{\nVNAFormat\n},\n \nv\n::\nSymbol\n)\n\n    \nif\n \nv\n \n==\n \n:\nLogMagnitude\n\n      \nMLOG\n\n    \nelse\n\n      \nif\n \nv\n \n==\n \n:\nPhase\n\n        \nPHAS\n\n      \nelse\n...\n\n\n        \nelse\n\n          \nerror\n(\nunexpected input.\n)\n\n    \nend\n\n\nend\n\n\n\nfunction\n \nVNAFormat\n(\nins\n::\nInsE5071C\n,\n \ns\n::\nAbstractString\n)\n\n    \nif\n \ns\n \n==\n \nMLOG\n\n      \n:\nLogMagnitude\n\n    \nelse\n\n      \nif\n \ns\n \n==\n \nPHAS\n\n        \n:\nPhase\n\n      \nelse\n...\n\n\n\n        \nelse\n\n          \nerror\n(\nunexpected input.\n)\n\n    \nend\n\n\nend\n\n\n\n\n\n\nThe above functions will be defined in the module where the macro is run. Note that the function \nsymbols\n has its name chosen based on the dictionary name in the JSON file. Since this function is not exported from the instrument's module there should be few namespace worries and we maintain future flexibliity.\n\n\nsource\n\n\n#\n\n\nInstrumentControl.@generate_configure\n \n \nMacro\n.\n\n\n@generate_configure(instype, p)\n\n\n\n\n\nThis macro takes a symbol \ninstype\n bound to an \nInstrument\n subtype (i.e. if the symbol was evaluated, it would return an \nInstrument\n subtype ), and a property dictionary \np\n located in the \n:properties\n field of the dictionary of metadata generated by a call to \ninsjson\n. with the auxiliary JSON file described above.\n\n\nThis macro overloads the base method \nsetindex!\n. In this implementation of \nsetindex!\n, the instrument acts as the collection, the key is the InstrumentProperty type defined from the \n:type\n field of the \np\n dictionary, and the value is specified by the user. This method also takes infix arguments; infixes are currently implemented as keyword arguments, so the \nsetindex!\n method applies some standard infixes if none are specified by the user.\n\n\nThe method constructs a configuration command to send to the instrument to change the specific instrument property the dictionary \np\n corresponds to (with user specified infixes). The command has \"#\" in place of the (user specified) value the property will be set to. It then sends the command to the instrument with the \nwrite\n method (NOTE: currently only defined in the VISA module for VISA instruments) where the command and the user-specified property value are passed to it. The \nwrite\n method replaces \"#\" with the proper value, and sends the command to the instrument\n\n\nThe macro accomplishes this by constructing and evaluating (approximately) the following expression:\n\n\nfunction\n \nsetindex\n!\n(\nins\n::\ninstype\n,\n \nv\n::\nvalues_Type\n,\n \n::\nType\n{\np\n[\n:\ntype\n]},\n \ninfixes_keyword_args\n)\n\n  \ncommand\n=\np\n[\n:\ncmd\n]\n\n  \ncommand\n*\n #\n\n  \ncmd\n\u00a0\n=\n\u00a0\nreplace\n(\ncmd\n,\n\u00a0\ninfix_name\n,\n\u00a0\ninfix_keyword_arg1\n)\n\n  \ncmd\n\u00a0\n=\n\u00a0\nreplace\n(\ncmd\n,\n\u00a0\ninfix_name\n,\n\u00a0\ninfix_keyword_arg2\n)\n\n  \n...\n \n#\netc\n\n  \n...\nmanipulation\n \nof\n \ninput\n \nv\n \ninto\n \nformat\n \ninstrument\n \naccepts\n\n  \nwrite\n(\nins\n,\ncmd\n,\nv\n)\n\n\nend\n\n\n\n\n\n\nThe function should be defined in the module where the instrument type was defined.\n\n\nsource\n\n\n#\n\n\nInstrumentControl.@generate_inspect\n \n \nMacro\n.\n\n\n@generate_inspect(instype, p)\n\n\n\n\n\nThis macro takes a symbol \ninstype\n bound to an \nInstrument\n subtype (i.e. if the symbol was evaluated, it would return an \nInstrument\n subtype ), and a property dictionary \np\n located in the \n:properties\n field of the dictionary of metadata generated by a call to \ninsjson\n. with the auxiliary JSON file described above.\n\n\nThis macro overloads the base method \ngetindex\n. In this implementation of \ngetindex\n, the instrument acts as the collection, and the key is the InstrumentProperty type defined from the \n:type\n field of the \np\n dictionary. This method also takes infix arguments; infixes are currently implemented as keyword arguments, so the \ngetindex\n method applies some standard infixes if none are specified by the user.\n\n\nThe method constructs a query command to send to the instrument regarding the specific instrument property the dictionary \np\n corresponds to. It then sends the command to the instrument with the \nask\n method (NOTE: currently defined in the VISA module for VISA instruments). The \nask\n method returns the value or state of the instrument property being queried.\n\n\nThe macro accomplishes this by constructing and evaluating (approximately) the following expression:\n\n\nfunction\n \ngetindex\n(\nins\n::\ninstype\n,\n \n::\nType\n{\np\n[\n:\ntype\n]},\n \ninfixes_keyword_args\n)\n\n  \ncommand\n=\np\n[\n:\ncmd\n]\n\n  \ncommand\n[\nend\n]\n \n!=\n \n?\n \n \n(\ncommand\n \n*=\n \n?\n)\n\n  \ncmd\n\u00a0\n=\n\u00a0\nreplace\n(\ncmd\n,\n\u00a0\ninfix_name\n,\n\u00a0\ninfix_keyword_arg1\n)\n\n  \ncmd\n\u00a0\n=\n\u00a0\nreplace\n(\ncmd\n,\n\u00a0\ninfix_name\n,\n\u00a0\ninfix_keyword_arg2\n)\n\n  \n...\n \n#\netc\n\n  \nask\n(\nins\n,\ncmd\n)\n\n  \n...\nfurther\n \nmanipulation\n \nof\n \noutput\n \nfor\n \ndisplay\n\n\nend\n\n\n\n\n\n\nThe function should be defined in the module where the instrument type was defined.\n\n\nsource\n\n\n\n\nSweep, Sweep Jobs, and Sweep Queueing implementation\n\n\nWe stratify InstrumentControl \"sweeps\" functionality into different types, along with helper functions for each type, in order to achieve a object-oriented architecture with code modularity.\n\n\nMeasurement specific information, such as what independent variables will be swept and what response will be measured, are contained in a \nSweep\n type:\n\n\n#\n\n\nInstrumentControl.Sweep\n \n \nType\n.\n\n\nmutable struct Sweep\n    dep::Response\n    indep::Tuple{Tuple{Stimulus, AbstractVector}}\n    result::AxisArray\n    Sweep(a,b) = new(a,b)\n    Sweep(a,b,c) = new(a,b,c)\nend\n\n\n\n\n\nObject representing a sweep; which will contain information on stimuli sent to the instruments, information on what kind of response we will be measuring, and the numerical data obtained from the measurement. \ndep\n (short for dependent) is a \nResponse\n that will be measured. \nindep\n is a tuple of \nStimulus\n objects and the values they will be sourced over. \nresult\n is the result array of the sweep, which need not be provided at the time the \nSweep\n object is created.\n\n\nsource\n\n\nHowever, additional metadata is needed for scheduling and queueing of sweeps, as well as logging of job information on ICDataServer. We \"bundle\" that information, along with a \nSweep\n object, in a more comprehensive \nSweepJob\n type:\n\n\nInstrumentControl.SweepJob\nInstrumentControl.SweepJob()\n\n\n\n\n\nFinally, we require a \ncollection\n object that can hold \nSweepJob\n objects, and sort them by job priority, in addition to having  functionality for  automatic scheduling of jobs in the background. For this purpose we define the \nSweepJobQueue\n type, as well as a initialization inner constructor.\n\n\n#\n\n\nInstrumentControl.SweepJobQueue\n \n \nType\n.\n\n\nmutable struct SweepJobQueue\n    #PriorityQueue is essentially a glorified dictionary with built-in functionality\n    #for sorting of keys\n    q::PriorityQueue{Int,SweepJob,\n        Base.Order.ReverseOrdering{Base.Order.ForwardOrdering}}\n    running_id::Channel{Int}\n    last_finished_id::Channel{Int}\n    trystart::Condition #used to communicate with the job_starter function\n    update_taskref::Ref{Task} #used to communicate with the job_updater function\n    update_channel::Channel{SweepJob} #channel for communicating with the job_updater function\n    function SweepJobQueue()\n        sjq = new(PriorityQueue(Int[],SweepJob[],Base.Order.Reverse),\n            Channel{Int}(1), Channel{Int}(1), Condition())\n        put!(sjq.running_id, -1)\n        put!(sjq.last_finished_id,-1)\n        sjq.update_taskref = Ref{Task}() #initializing a pointer for a task\n        sjq.update_channel = Channel(t-\njob_updater(sjq, t);\n            ctype = SweepJob, taskref=sjq.update_taskref)\n        #the job_updater function is wrapped in a Task through this Channel constructor\n        @schedule job_starter(sjq) #the job_started function is wrapped in a Task here\n        sjq\n    end\nend\n\n\n\n\n\nA queue responsible for prioritizing sweeps and executing them accordingly. The queue holds \nSweepJob\n objects, and \"indexes\" them by their \njob_id\n. It prioritizes jobs based on their priorities; for equal priority values, the job submitted earlier takes precedent. The queue keeps track of which job is running (if any) by its \nrunning_id\n \nChannel\n. The queue keeps track of the last finished job by the \nlast_finished_id\n channel, for easy access to the data of the last finished job. Other fields are used for intertask communication. Note that a \nrunning_id of\n -1 signifies that no job is running.\n\n\nWhen a \nSweepJobQueue\n is created through it's argumentless inner constructor (made for initialization purposes), two tasks are initialized. One task manages job updates, the other task is responsible for starting jobs; the former task executes the \njob_updater\n function, the latter task executes the \njob_starter\n function. Both functions execute infinite while loops, therefore they never end.\n\n\nWhen the job starter task is notified with the \ntrystart::Condition\n object in the \nSweepJobQueue\n object, it will find the highest priority job in the queue. Then, if a job is not running, and the prioritized job is waiting, and if the prioritized job is runnable (the priority may be \"NEVER\"), then the job is started. The database is updated asynchronously to reflect the new job, the queue's \nrunning_id\n is changed to the job's id, and the job's status is changed to \"Running\".\n\n\nThe job updater task tries to take a \nSweepJob\n from \nupdate_channel\n, the unbuffered job \nChannel\n of the \nSweepJobQueue\n object. The task is blocked until a job is put into the channel. Once a job arrives, provided the job has finished or has been aborted, the database is asynchronously updated, the job is marked as no longer running (by updating the \nrunning_id\n and \nlast_finished_id\n channels), the sweep result is asynchronously saved to disk, and finally the job starter task is notified through the queue's \ntrystart\n \nCondition\n object. The job updater task loops around and waits for another job to arrive at its channel.\n\n\nsource\n\n\n#\n\n\nInstrumentControl.job_updater\n \n \nFunction\n.\n\n\njob_updater(sjq::SweepJobQueue, update_channel::Channel{SweepJob})\n\n\n\n\n\nUsed when a sweep job finishes; archieves the result of the finished sweep job, updates all job and queue metadata, asynchronously updates ICDataServer, and notifies the job_starter task to run through \nsjq\n's \ntrystart\n \nCondition\n object. This function continuously runs continuously without stopping once called. In its current implementation, this function is executed through a Task when a \nSweepJobQueue\n object is initialized; this allows the function to be stopped and recontinued asynchronously as is appropriate.\n\n\nThe function first waits until the update_channel is populated with a job. Once a job arrives, the function takes the job from the channel, and given that it's status is \"Done\" or \"Aborted\", it executes the items described above\n\n\nsource\n\n\n#\n\n\nInstrumentControl.job_starter\n \n \nFunction\n.\n\n\njob_starter(sjq::SweepJobQueue)\n\n\n\n\n\nUsed when starting a new sweep job. The function first obtains the highest priority job in \nsjq\n; and given that a job is not running, it's status is \"Waiting\", and if the prioritized job is runnable (the priority may be \"never\"), then the job is started. The function updates all job and queue metadata and asynchronously updates ICDataServer. This function continuously runs continuously without stopping once called. In its current implementation, this function is executed through a Task when a \nSweepJobQueue\n object is initialized; this allows the function to be stopped and recontinued asynchronously as is appropriate.\n\n\nThe last thing the function does is change the job status to \"Running\". When a job is scheduled with the sweep function, the sweep function waits for the status of the job to be changed from \"Waiting\" to start sourcing the instruments and performing measurements\n\n\nsource\n\n\nWhen InstrumentControl is imported, a default 'SweepJobQueue' object is instantiated via the \nSweepJobQueue()\n constructor, and associated with a pointer called \nsweepjobqueue\n. This is THE queue running in the background automatically scheduling jobs, and referred to as the \"default sweep job queue object\" in the documentation. This object can be returned by the following function:\n\n\n#\n\n\nInstrumentControl.jobs\n \n \nMethod\n.\n\n\njobs()\n\n\n\n\n\nReturns the default \nSweepJobQueue\n object, initialized when the InstrumentControl module is imported/used. All jobs are scheduled in this object. Typically you call this to see what jobs are waiting, aborted, or finished, and what job is running.\n\n\nsource\n\n\nSweeps are scheduled by a call to the \nsweep\n function:\n\n\n#\n\n\nInstrumentControl.sweep\n \n \nFunction\n.\n\n\nsweep\n{\nN\n}\n(\ndep\n::\nResponse\n,\n \nindep\n::\nVararg\n{\nTuple{Stimulus,\n \nAbstractVector\n}\n,\n \nN\n}\n;\n\n    \npriority\n \n=\n \nNORMAL\n)\n\n\n\n\n\n\nsweep\n measures a response as a function of an arbitrary number of stimuli, sourced over the values given in the \nAbstractVector\n input, and returns a handle to the sweep job. This can be used to access the results while the sweep is being measured.\n\n\nThis function is responsible for 1) initialzing sockets for communication with the ICDataServer, 2) initializing an appropriate array to hold the reults of the sweep,\n\n\n\n\npreparing a \nInstrumentControl.SweepJob\n object with an appropriate \njob_id\n\n\n\n\nobtained from the database, 4) adding the job to the default \nSweepJobQueue\n object (defined when the InstrumentControl module is used/imported), and 5) launching an asynchronous sweep job.\n\n\nThe \npriority\n keyword may be \nLOW\n, \nNORMAL\n, or \nHIGH\n, or any integer greater than or equal to zero.\n\n\nThe actual sweeping, i.e., the actual \nsource\n and \nmeasure\n loops to measure data are in a private function \nInstrumentControl._sweep!\n. Note that if \nInstrumentControl._sweep!\n is not defined yet, this function will also define the method in order to it to be used to schedule a sweep.\n\n\nsource\n\n\n#\n\n\nInstrumentControl._sweep!\n \n \nFunction\n.\n\n\n_sweep!(::Val{D}, ::Val{N}, sj, update_channel)\n\n\n\n\n\nThis is a private function which should not be called directly by the user. It is launched asynchronously by \nsweep\n. The implementation uses macros from \nBase.Cartesian\n. The stimuli are sourced only when they need to be, at the start of each \nfor\n loop level.\n\n\nD\n is the dimension of the output array of the measure function (if multiple things are measured for one Response type, the array will be multi-dimensional). \nN\n is the number of stimuli which the sweep sources over. sj is the handle to the \nSweepJob\n object, and update_channel is a channel of the queue used for intertask comunication.\n\n\nThe axis scaling of \nmeasure(sj.sweep.dep)\n, i.e., the dimensions of the output array of the function. is presumed to be fixed, as it is only looked at once, the first time \nmeasure\n is called.\n\n\nsource", 
            "title": "Implementation"
        }, 
        {
            "location": "/implementation/#implementation-overview", 
            "text": "", 
            "title": "Implementation overview"
        }, 
        {
            "location": "/implementation/#code-organization", 
            "text": "Each instrument is defined within its own module, a submodule of  InstrumentControl .   Each instrument is a subtype of  Instrument . By convention, instrument model numbers are used for module definitions (e.g.  AWG5014C ), so type names have \"Ins\" prepended (e.g.  InsAWG5014 ).   Low-level wrappers for shared libraries are kept in their own packages (e.g.  VISA ,  Alazar , and  KeysightInstruments  calls).   This way, at least some code can be reused if someone else does not want to use our codebase.   All sweep related type definitions and functions described in  Sweep Jobs   can be found in  src/Sweep.jl   Abstract type definitions like  Instrument  and  Stimulus , are defined in   ICCommon.jl      src/Definitions.jl  contains some definitions of other commonly used functions   and types.  src/config.jl  parses information in  deps/config.json  for talking to the database set up by ICDataServer, such as username information, database server address, path for saving results of sweeps, and stores it in a dictionary for access to all other functions that need this information to communicate with the database", 
            "title": "Code organization"
        }, 
        {
            "location": "/implementation/#communication-with-icdataserver", 
            "text": "The functionality of the InstrumentControl.jl package is intertwined with the  ICDataServer.jl  package. ICDataServer sets up a relational database (RDBMS) with which it communicates with through SQL. InstrumentControl talks to that database; this database is used to maintain a log of information for each job: the job is identified by the job ID, and it mantains any metadata specified by the database creator. In its current implementation, the data saved to the database is the time of job submission, the time of job completion, and the latest job status, but we hope to add more logging functionality to the code over time.  When  sweep  is executed, the function communicates with the ICDataServer to create a new entry in the database table; the identifier of the new entry is a new job ID that the RDMS itself creates. ICDataServer then communicates back to InstrumentControl with this particular job ID and the time of submission; this job metadata is immediately stored in the  SweepJob  object (created by the  sweep  function as a handle to the new job). The job is then queued with the provided job ID as it's identifier.  The actual communication between the two packages is mediated by the popular  ZeroMQ  distributed messaging software; we utilize it's  ZMQ  Julia interface. While the reader is encouraged to go to these links for in-depth information, what you essentially need to communicate between a client and a server with ZeroMQ is a  Context  and a  socket . In Julia, a  ZMQ.Context  object provides the framework for communication via a TCP connection (or any analagous form of communication). The client and server respectively will connect to a TCP port to send/receive information. The point of entry/exit for information being passed along this TCP connection are the ZMQ.Socket objects; they \"bind\" to the TCP ports and are the objects that the user actually calls on the send and receive information.  When InstrumentControl is imported, a  ZMQ.Context  object is automatically initialized.  ZMQ.Socket  objects are initialized in the first instance of communication with the ICDataServer, and the same object is used thereafter for communication within the same usage session. The socket objects are automatically bound to TCP ports that the user specifies in the  deps/config.json  file. InstrumentControl and ICDataServer communicate by binding to the same TCP connection.", 
            "title": "Communication with ICDataServer"
        }, 
        {
            "location": "/implementation/#metaprogramming-for-visa-instruments", 
            "text": "Many commercial instruments support a common communications protocol and command syntax (VISA and SCPI respectively). For such instruments, methods for  setindex!  and  getindex , as well as  Instrument  subtype and  InstrumentProperty  subtype definitions, can be generated with metaprogramming, rather than typing them out explicitly.  The file  src/MetaprogrammingVISA.jl  is used heavily for code generation based on JSON template files. Since much of the logic for talking to instruments is the same between VISA instruments, in some cases no code needs to be written to control a new instrument provided an appropriate template file is prepared. The metaprogramming functions are described below although they are not intended to be used interactively.  #  InstrumentControl.insjson     Function .  insjson(file::AbstractString)  Parses a JSON file with a standardized schema to describe how to control an instrument.  Here is an example of a valid JSON file with valid schema for parsing:  { \n     instrument :{ \n             module : E5071C , \n             type : InsE5071C , \n             make : Keysight , \n             model : E5071C , \n             writeterminator : \\n \n     }, \n     properties :[ \n         { \n             cmd : :CALCch:TRACtr:CORR:EDEL:TIME , \n             type : VNA.ElectricalDelay , \n             values :[ \n                 v::Real \n             ], \n             infixes :[ \n                 ch::Integer=1 , \n                 tr::Integer=1 \n             ], \n             doc :   My documentation \n         } \n     ]  }   JSON.parse  takes such a file and makes an 'instrument' dictionary and a 'properties' array. The  instrument  dictionary is described in the  @generate_instruments  documentation. The  properties  array contains one or more dictionaries, each with keys:   cmd : Specifies what must be sent to the instrument (it should be terminated   with \"?\" for query-only commands). The lower-case characters are replaced by \"infixes\", which are either numerical arguments or strings   type : Specifies the  InstrumentProperty  subtype to use  cmd .  values : Specifies the required argument for  setindex! , which will appear   after  cmd  in the string sent to the instrument.   infixes : Specifies the infix arguments to be put in  cmd . This key is not   required if there are no infixes.   doc : Specifies documentation for the generated Julia functions. This key   is not required if there is no documentation. This is used not only for interactive help but also in generating the documentation you are reading.  The value of the  properties.type  field and entries in the  properties.values  and  properties.infixes  arrays are parsed into expressions or symbols for further manipulation. All generated dictionary keys are also converted to symbols for further manipulation.  source  #  InstrumentControl.@generate_instruments     Macro .  @generate_instruments(metadata)  This macro takes a dictionary of metadata, typically obtained from a call to  insjson . It operates on the  :instrument  field of the dictionary which is expected to have the following structure:   module : The module name. Can already exist but is created if it does not.   This field is converted from a string to a  Symbol  by  insjson .   type : The name of the type to create for the new instrument.   This field is converted from a string to a  Symbol  by  insjson .   super : This field is optional. If provided it will be the supertype of   the new instrument type, otherwise the supertype will be  Instrument . This field is converted from a string to a  Symbol  by  insjson .   make : The make of the instrument, e.g. Keysight, Tektronix, etc.  model : The model of the instrument, e.g. E5071C, AWG5014C, etc.  writeterminator : Write termination string for sending SCPI commands.   The macro imports required modules and methods, defines and exports the  Instrument  subtype, and defines and exports and the  make  and  model  methods if they do not exist already (note generic functions  make  and  model  are defined in  src/Definitions.jl ).  By convention we typically have the module name be the same as the model name, and the type is just the model prefixed by \"Ins\", e.g.  InsE5071C . This is not required.  source  #  InstrumentControl.@generate_properties     Macro .  @generate_properties(metadata)  This macro takes a dictionary of metadata, typically obtained from a call to  insjson . It operates on the  :properties  field of the dictionary, which is expected to be a list of dictionaries with information on each \"property\" of the instrument. This macro specifically operates on the  :type  field of each property dictionary; this field contains the name of the type we would like to assign to a given property of the instrument.  For every property dictionary, the macro first checks if a type with name corresponding to the dictionary's  :type  field  has already been defined. If not, it then defines an abstract type with that name, and makes it a subtype of the  InstrumentProperty  type defined in the ICCommon package. The macro then finally exports that type  source  #  InstrumentControl.@generate_handlers     Macro .  @generate_handlers(instype, p)  This macro takes a symbol  instype  bound to an  Instrument  subtype (i.e. if the symbol was evaluated, it would return an  Instrument  subtype ), and a property dictionary  p  located in the  :properties  field of the dictionary of metadata generated by a call to  insjson . with the auxiliary JSON file described above.  This macro is written to handle the cases where an instrument command does not accept numerical arguments, but rather a small set of options. Here is an example of the property dictionary (prior to parsing) for such a command, which sets/gets the format for a given channel and trace on the E5071C vector network analyzer:  { \n     cmd : :CALCch:TRACtr:FORM , \n     type : VNAFormat , \n     values :[ \n         v::Symbol in symbols \n     ], \n     symbols :{ \n         LogMagnitude : MLOG , \n         Phase : PHAS , \n         GroupDelay : GDEL , \n         SmithLinear : SLIN , \n         SmithLog : SLOG , \n         SmithComplex : SCOM , \n         Smith : SMIT , \n         SmithAdmittance : SADM , \n         PolarLinear : PLIN , \n         PolarLog : PLOG , \n         PolarComplex : POL , \n         LinearMagnitude : MLIN , \n         SWR : SWR , \n         RealPart : REAL , \n         ImagPart : IMAG , \n         ExpandedPhase : UPH , \n         PositivePhase : PPH \n     }, \n     infixes :[ \n         ch::Integer=1 , \n         tr::Integer=1 \n     ], \n     doc : Hey  }   We see here that the  values  key is saying that we are only going to accept  Symbol  type for our  setindex!  method and the symbol has to come out of  symbols , a dictionary that is defined on the next line. The keys of this dictionary are going to be interpreted as symbols (e.g.  :LogMagnitude ) and the values are just ASCII strings to be sent to the instrument. We want to associate these symbols with the specific ASCII strings because these strings are not very descriptive, so we would like a more descriptive handle for them, as well as a handle that could be potentially shared between different instruments which have different \"spellings\" for the same command. We make the handles symbols because they are a more flexible type (which can always be parsed into strings)  generate_handlers  makes a bidirectional mapping between the symbols and the strings. For the example above, the macro defines the following functions:  function   symbols ( ins :: InsE5071C ,   :: Type { VNAFormat },   v :: Symbol ) \n     if   v   ==   : LogMagnitude \n       MLOG \n     else \n       if   v   ==   : Phase \n         PHAS \n       else ... \n\n         else \n           error ( unexpected input. ) \n     end  end  function   VNAFormat ( ins :: InsE5071C ,   s :: AbstractString ) \n     if   s   ==   MLOG \n       : LogMagnitude \n     else \n       if   s   ==   PHAS \n         : Phase \n       else ... \n\n\n         else \n           error ( unexpected input. ) \n     end  end   The above functions will be defined in the module where the macro is run. Note that the function  symbols  has its name chosen based on the dictionary name in the JSON file. Since this function is not exported from the instrument's module there should be few namespace worries and we maintain future flexibliity.  source  #  InstrumentControl.@generate_configure     Macro .  @generate_configure(instype, p)  This macro takes a symbol  instype  bound to an  Instrument  subtype (i.e. if the symbol was evaluated, it would return an  Instrument  subtype ), and a property dictionary  p  located in the  :properties  field of the dictionary of metadata generated by a call to  insjson . with the auxiliary JSON file described above.  This macro overloads the base method  setindex! . In this implementation of  setindex! , the instrument acts as the collection, the key is the InstrumentProperty type defined from the  :type  field of the  p  dictionary, and the value is specified by the user. This method also takes infix arguments; infixes are currently implemented as keyword arguments, so the  setindex!  method applies some standard infixes if none are specified by the user.  The method constructs a configuration command to send to the instrument to change the specific instrument property the dictionary  p  corresponds to (with user specified infixes). The command has \"#\" in place of the (user specified) value the property will be set to. It then sends the command to the instrument with the  write  method (NOTE: currently only defined in the VISA module for VISA instruments) where the command and the user-specified property value are passed to it. The  write  method replaces \"#\" with the proper value, and sends the command to the instrument  The macro accomplishes this by constructing and evaluating (approximately) the following expression:  function   setindex ! ( ins :: instype ,   v :: values_Type ,   :: Type { p [ : type ]},   infixes_keyword_args ) \n   command = p [ : cmd ] \n   command *  # \n   cmd \u00a0 = \u00a0 replace ( cmd , \u00a0 infix_name , \u00a0 infix_keyword_arg1 ) \n   cmd \u00a0 = \u00a0 replace ( cmd , \u00a0 infix_name , \u00a0 infix_keyword_arg2 ) \n   ...   # etc \n   ... manipulation   of   input   v   into   format   instrument   accepts \n   write ( ins , cmd , v )  end   The function should be defined in the module where the instrument type was defined.  source  #  InstrumentControl.@generate_inspect     Macro .  @generate_inspect(instype, p)  This macro takes a symbol  instype  bound to an  Instrument  subtype (i.e. if the symbol was evaluated, it would return an  Instrument  subtype ), and a property dictionary  p  located in the  :properties  field of the dictionary of metadata generated by a call to  insjson . with the auxiliary JSON file described above.  This macro overloads the base method  getindex . In this implementation of  getindex , the instrument acts as the collection, and the key is the InstrumentProperty type defined from the  :type  field of the  p  dictionary. This method also takes infix arguments; infixes are currently implemented as keyword arguments, so the  getindex  method applies some standard infixes if none are specified by the user.  The method constructs a query command to send to the instrument regarding the specific instrument property the dictionary  p  corresponds to. It then sends the command to the instrument with the  ask  method (NOTE: currently defined in the VISA module for VISA instruments). The  ask  method returns the value or state of the instrument property being queried.  The macro accomplishes this by constructing and evaluating (approximately) the following expression:  function   getindex ( ins :: instype ,   :: Type { p [ : type ]},   infixes_keyword_args ) \n   command = p [ : cmd ] \n   command [ end ]   !=   ?     ( command   *=   ? ) \n   cmd \u00a0 = \u00a0 replace ( cmd , \u00a0 infix_name , \u00a0 infix_keyword_arg1 ) \n   cmd \u00a0 = \u00a0 replace ( cmd , \u00a0 infix_name , \u00a0 infix_keyword_arg2 ) \n   ...   # etc \n   ask ( ins , cmd ) \n   ... further   manipulation   of   output   for   display  end   The function should be defined in the module where the instrument type was defined.  source", 
            "title": "Metaprogramming for VISA instruments"
        }, 
        {
            "location": "/implementation/#sweep-sweep-jobs-and-sweep-queueing-implementation", 
            "text": "We stratify InstrumentControl \"sweeps\" functionality into different types, along with helper functions for each type, in order to achieve a object-oriented architecture with code modularity.  Measurement specific information, such as what independent variables will be swept and what response will be measured, are contained in a  Sweep  type:  #  InstrumentControl.Sweep     Type .  mutable struct Sweep\n    dep::Response\n    indep::Tuple{Tuple{Stimulus, AbstractVector}}\n    result::AxisArray\n    Sweep(a,b) = new(a,b)\n    Sweep(a,b,c) = new(a,b,c)\nend  Object representing a sweep; which will contain information on stimuli sent to the instruments, information on what kind of response we will be measuring, and the numerical data obtained from the measurement.  dep  (short for dependent) is a  Response  that will be measured.  indep  is a tuple of  Stimulus  objects and the values they will be sourced over.  result  is the result array of the sweep, which need not be provided at the time the  Sweep  object is created.  source  However, additional metadata is needed for scheduling and queueing of sweeps, as well as logging of job information on ICDataServer. We \"bundle\" that information, along with a  Sweep  object, in a more comprehensive  SweepJob  type:  InstrumentControl.SweepJob\nInstrumentControl.SweepJob()  Finally, we require a  collection  object that can hold  SweepJob  objects, and sort them by job priority, in addition to having  functionality for  automatic scheduling of jobs in the background. For this purpose we define the  SweepJobQueue  type, as well as a initialization inner constructor.  #  InstrumentControl.SweepJobQueue     Type .  mutable struct SweepJobQueue\n    #PriorityQueue is essentially a glorified dictionary with built-in functionality\n    #for sorting of keys\n    q::PriorityQueue{Int,SweepJob,\n        Base.Order.ReverseOrdering{Base.Order.ForwardOrdering}}\n    running_id::Channel{Int}\n    last_finished_id::Channel{Int}\n    trystart::Condition #used to communicate with the job_starter function\n    update_taskref::Ref{Task} #used to communicate with the job_updater function\n    update_channel::Channel{SweepJob} #channel for communicating with the job_updater function\n    function SweepJobQueue()\n        sjq = new(PriorityQueue(Int[],SweepJob[],Base.Order.Reverse),\n            Channel{Int}(1), Channel{Int}(1), Condition())\n        put!(sjq.running_id, -1)\n        put!(sjq.last_finished_id,-1)\n        sjq.update_taskref = Ref{Task}() #initializing a pointer for a task\n        sjq.update_channel = Channel(t- job_updater(sjq, t);\n            ctype = SweepJob, taskref=sjq.update_taskref)\n        #the job_updater function is wrapped in a Task through this Channel constructor\n        @schedule job_starter(sjq) #the job_started function is wrapped in a Task here\n        sjq\n    end\nend  A queue responsible for prioritizing sweeps and executing them accordingly. The queue holds  SweepJob  objects, and \"indexes\" them by their  job_id . It prioritizes jobs based on their priorities; for equal priority values, the job submitted earlier takes precedent. The queue keeps track of which job is running (if any) by its  running_id   Channel . The queue keeps track of the last finished job by the  last_finished_id  channel, for easy access to the data of the last finished job. Other fields are used for intertask communication. Note that a  running_id of  -1 signifies that no job is running.  When a  SweepJobQueue  is created through it's argumentless inner constructor (made for initialization purposes), two tasks are initialized. One task manages job updates, the other task is responsible for starting jobs; the former task executes the  job_updater  function, the latter task executes the  job_starter  function. Both functions execute infinite while loops, therefore they never end.  When the job starter task is notified with the  trystart::Condition  object in the  SweepJobQueue  object, it will find the highest priority job in the queue. Then, if a job is not running, and the prioritized job is waiting, and if the prioritized job is runnable (the priority may be \"NEVER\"), then the job is started. The database is updated asynchronously to reflect the new job, the queue's  running_id  is changed to the job's id, and the job's status is changed to \"Running\".  The job updater task tries to take a  SweepJob  from  update_channel , the unbuffered job  Channel  of the  SweepJobQueue  object. The task is blocked until a job is put into the channel. Once a job arrives, provided the job has finished or has been aborted, the database is asynchronously updated, the job is marked as no longer running (by updating the  running_id  and  last_finished_id  channels), the sweep result is asynchronously saved to disk, and finally the job starter task is notified through the queue's  trystart   Condition  object. The job updater task loops around and waits for another job to arrive at its channel.  source  #  InstrumentControl.job_updater     Function .  job_updater(sjq::SweepJobQueue, update_channel::Channel{SweepJob})  Used when a sweep job finishes; archieves the result of the finished sweep job, updates all job and queue metadata, asynchronously updates ICDataServer, and notifies the job_starter task to run through  sjq 's  trystart   Condition  object. This function continuously runs continuously without stopping once called. In its current implementation, this function is executed through a Task when a  SweepJobQueue  object is initialized; this allows the function to be stopped and recontinued asynchronously as is appropriate.  The function first waits until the update_channel is populated with a job. Once a job arrives, the function takes the job from the channel, and given that it's status is \"Done\" or \"Aborted\", it executes the items described above  source  #  InstrumentControl.job_starter     Function .  job_starter(sjq::SweepJobQueue)  Used when starting a new sweep job. The function first obtains the highest priority job in  sjq ; and given that a job is not running, it's status is \"Waiting\", and if the prioritized job is runnable (the priority may be \"never\"), then the job is started. The function updates all job and queue metadata and asynchronously updates ICDataServer. This function continuously runs continuously without stopping once called. In its current implementation, this function is executed through a Task when a  SweepJobQueue  object is initialized; this allows the function to be stopped and recontinued asynchronously as is appropriate.  The last thing the function does is change the job status to \"Running\". When a job is scheduled with the sweep function, the sweep function waits for the status of the job to be changed from \"Waiting\" to start sourcing the instruments and performing measurements  source  When InstrumentControl is imported, a default 'SweepJobQueue' object is instantiated via the  SweepJobQueue()  constructor, and associated with a pointer called  sweepjobqueue . This is THE queue running in the background automatically scheduling jobs, and referred to as the \"default sweep job queue object\" in the documentation. This object can be returned by the following function:  #  InstrumentControl.jobs     Method .  jobs()  Returns the default  SweepJobQueue  object, initialized when the InstrumentControl module is imported/used. All jobs are scheduled in this object. Typically you call this to see what jobs are waiting, aborted, or finished, and what job is running.  source  Sweeps are scheduled by a call to the  sweep  function:  #  InstrumentControl.sweep     Function .  sweep { N } ( dep :: Response ,   indep :: Vararg { Tuple{Stimulus,   AbstractVector } ,   N } ; \n     priority   =   NORMAL )   sweep  measures a response as a function of an arbitrary number of stimuli, sourced over the values given in the  AbstractVector  input, and returns a handle to the sweep job. This can be used to access the results while the sweep is being measured.  This function is responsible for 1) initialzing sockets for communication with the ICDataServer, 2) initializing an appropriate array to hold the reults of the sweep,   preparing a  InstrumentControl.SweepJob  object with an appropriate  job_id   obtained from the database, 4) adding the job to the default  SweepJobQueue  object (defined when the InstrumentControl module is used/imported), and 5) launching an asynchronous sweep job.  The  priority  keyword may be  LOW ,  NORMAL , or  HIGH , or any integer greater than or equal to zero.  The actual sweeping, i.e., the actual  source  and  measure  loops to measure data are in a private function  InstrumentControl._sweep! . Note that if  InstrumentControl._sweep!  is not defined yet, this function will also define the method in order to it to be used to schedule a sweep.  source  #  InstrumentControl._sweep!     Function .  _sweep!(::Val{D}, ::Val{N}, sj, update_channel)  This is a private function which should not be called directly by the user. It is launched asynchronously by  sweep . The implementation uses macros from  Base.Cartesian . The stimuli are sourced only when they need to be, at the start of each  for  loop level.  D  is the dimension of the output array of the measure function (if multiple things are measured for one Response type, the array will be multi-dimensional).  N  is the number of stimuli which the sweep sources over. sj is the handle to the  SweepJob  object, and update_channel is a channel of the queue used for intertask comunication.  The axis scaling of  measure(sj.sweep.dep) , i.e., the dimensions of the output array of the function. is presumed to be fixed, as it is only looked at once, the first time  measure  is called.  source", 
            "title": "Sweep, Sweep Jobs, and Sweep Queueing implementation"
        }, 
        {
            "location": "/waveform_generators/awgM320XA/", 
            "text": "Keysight M320XA AWGs\n\n\nThis module contains the many methods and types necessary to control and configure the Keysight M3202A/M3201A AWGs. In essence, it wraps the \nKeysightInstruments.jl\n package, which in itself is a bare-bones wrapper to the native C library which controls the Keysight instruments, in a way which affords compatibility with the rest of the InstrumentControl package, as well as consistency between the control code of this instrument and other instruments represented in this package.\n\n\n\n\nUsage/Configuration\n\n\nInstrument Overview\n\n\nEach M320XA AWG card has several channels; each channel has it's own \nFunction Generator\n as well as it's own \nArbitary Waveform Generator\n. The function generator outputs sinusoids, triangular waves, and square waves. The user can select the output of the channel to either come from the arbitrary waveform generator, or from the function generator.\n\n\nMoreover, the arbitrary waveform generator can be used to \nmodulate\n the function generator output: it can be used for amplitude modulation, phase modulation, frequency modulation, or DC offset modulation\n\n\nWhen used for amplitude modulation, the output signal is given by: \nOutput(t) = (A + G*AWG(t))* cos(\u03c9t + \u03d5) + DC\n\n\nWhen used for phase modulation, the output signal is given by: \nOutput(t) = A*cos(\u03c9t + \u03d5 + G*AWG(t)) + DC\n\n\nWhen used for frequency modulation, the output signal is given by: \nOutput(t) = A*cos((\u03c9+G*AWG(t))* t + \u03d5) + DC\n\n\nWhen used for DC offset modulation, the output signal is given by: \nOutput(t) = A*cos(\u03c9t + \u03d5) + DC + G*AWG(t)\n  \n\n\nWhen using the AWG for direct output (not modulation): \nOutput(t) = A*AWG(t) + DC\n\n\n\n\nA is the channel amplitude configured by the user\n\n\nAWG(t) is the \nnormalized\n waveform which is loaded and queued by the user and generated by the AWG\n\n\nf = \u03c9/2\u03c0 is the channel's function generator's frequency set by the user\n\n\n\u03d5 is the channel's function generator's relative phase configured by the user\n\n\nG is the \"amplitude\" of the AWG signal, which is configured by the user\n\n\nDC is the channel's DC offset, configured by the user.\n\n\n\n\nWaveforms are loaded as \nnormalized\n arrays (i.e., from -1 to 1) to the onboard RAM of the AWG; when they are loaded the user specifies an number ID which servers as the handle to the waveform from then on. The loaded waveforms are then queued onto particular channels with the following parameters:\n\n\n\n\nTrigger mode (i.e.: Trigger from PXI or Software or Automatically)\n\n\nDelay from trigger to output\n\n\nNumber of repetitions\n\n\nPrescaler\n\n\n\n\nThen, after queueing the waveforms, we \"start\" the AWG (with our \nawg_start\n function), which then starts outputting waveforms upon acquisition of triggers.\n\n\nMoreover, each AWG card has it's own internal 100MHz clock which is phase-locked to the chassis clock: any actions taken by the AWG occur on a clock tick (so in intervals of 10ns), and different AWG/Digitizer cards are synchronized through the chassis clock. Each card also has an extra port called the TRG port, on which triggers can be received or generated.\n\n\nUsage\n\n\nAll instrument control and configuration happens through the following \nInstrument\n subtype:\n\n\n#\n\n\nInstrumentControl.AWGM320XA.InsAWGM320XA\n \n \nType\n.\n\n\nmutable struct InsAWGM320XA \n: Instrument\n    serial_num::String\n    product_name::String\n    index::Int\n    chassis_num::Int\n    slot_num::Int\n    channels::Dict{Int, Dict{Any, Any}}\n    waveforms::Dict{Int, Waveform}\nend\n\n\n\n\n\nObject representing an AWGM320XA instrument. It holds, as fields, instrument information such as AWG instrument index, slot number, chassis number, serial number, product name, etc. We take this object to represent both M3202A AWGs and M3201A AWGs, since they have the exact same functionality, they only have different specs. The \nproduct_name\n field can be used to distinguish wether an object of type \nInsAWGM320XA\n correponds to an M3202A or M3101A AWG via its \"name\".\n\n\nIn addition, the AWG object holds all the waveforms stored in RAM in a dictionary, named \nwaveforms\n,  where the waveforms are indexed by their identifier number, which the user specifies when he/she loads an waveform into the RAM of the AWG.\n\n\nThis object also holds individual channel properties in a dictionary named \nchannels\n, where in the type's implementation, the values of the dictionaries are themselves dictionaries that hold all configuration information for a particular channel.For example, for an object \nins::InsAWGM320XA\n, \nins.channels[1]\n will return a dictionary that holds all configuration information for channel 1; its keys will be subtypes of the \nInstrumentProperty\n abstract type, and its values will be the values which the instrument property associated that subtype are configured to in that channel in the digitizer.\n\n\nTwo inner constructors are provided: one which initializes the object with a given slot number and chassis number, and one which initializes the object with a given serial number and name. Both inner constructors also take a \nnum_channels\n keyword argument, corresponding to the number of channels on the instrument, which is used for initial configuration of the instrument channels. When the object is initialized, it obtains all other instrument information described above with the passed arguments, initializes the \nwaveforms\n dictionary, and initializes all the channels properties to some standard values and records them in the \nchannels\n dictionary through the \nconfigure_channels!\n function.\n\n\nsource\n\n\nFor example, calling \nInsAWGM320XA(3,1,num_channels = 4)\n will open the AWG card on slot 3 on the PXI chassis indexed by 1 (internal Keysight software does the chassis \"indexing\"); \nnum_channels\n corresponds to the number of channels in the AWG card. The second input, which sets the value for the \nchassis\n field in the \nInsAWGM320XA\n object, is an optional argument with default value \n1\n (for the case when only one chassis is connected to the computer), while the \nnum_channels\n input is a keyword argument whose default value is \n4\n \u2013\n Hence, \nInsAWGM320XA(3)\n would make an instance of the same object.\n\n\nMoreover, once waveforms are loaded and queued, each channel's AWG can be started and checked to see if it's running with the following methods\n\n\n#\n\n\nInstrumentControl.AWGM320XA.awg_start\n \n \nFunction\n.\n\n\nawg_start(awg::InsAWGM320XA, ch::Integer)\nawg_start(awg::InsAWGM320XA, chs::Vararg{Int})\n\nStarts acquisition of triggers for generation/ouputting of all waveforms\nqueued on the awg(s) of channel `ch` or channels `chs`.\n\n\n\n\n\nsource\n\n\n#\n\n\nInstrumentControl.AWGM320XA.awg_is_running\n \n \nFunction\n.\n\n\nawg_is_run(awg::InsAWGM320XA, ch::Integer)\nChecks if the AWG corresponding to channel `ch` on AWG card corresponding to\nobject `awg` is \nrunning\n, i.e. it is waiting for triggers to output waveforms\nor is actively outputting waveforms. Prints either \nYES\n or \nNO\n\n\n\n\n\n\nsource\n\n\nConfiguration\n\n\nConfiguration/Inspection of settings happens through setindex!/getindex methods, as described in \nOverview\n\n\nThese are the following properties which can be configured, each of which has it's own \nInstrumentProperty\n subtype:\n\n\n#\n\n\nInstrumentControl.AWGM320XA.OutputMode\n \n \nType\n.\n\n\nConfigures the type of output from an AWG channel. Can be configured to be either :Off, :Sinusoidal, :Triangular, :Square, :DC, :Arbitrary, or :Differential\n\n\nsource\n\n\n#\n\n\nInstrumentControl.AWGM320XA.DCOffset\n \n \nType\n.\n\n\nSets a channel's DC offset on output. Configured to be a \nFloat64\n number.\n\n\nsource\n\n\n#\n\n\nInstrumentControl.AWGM320XA.FGFrequency\n \n \nType\n.\n\n\nSets a channel's function generator frequency. Configured to be a \nFloat64\n number.\n\n\nsource\n\n\n#\n\n\nInstrumentControl.AWGM320XA.FGPhase\n \n \nType\n.\n\n\nSets a channel's function generator's relative phase. Configured to be a \nFloat64\n number.\n\n\nsource\n\n\n#\n\n\nInstrumentControl.AWGM320XA.TrigSource\n \n \nType\n.\n\n\nSource of external trigger. Can be configured to be either a number 0-7, which corresponds to a PXI line on the PXI backplane, or :TrgPort, which corresponds to the Trg port on the AWG card\n\n\nsource\n\n\n#\n\n\nInstrumentControl.AWGM320XA.TrigBehavior\n \n \nType\n.\n\n\nExternal trigger behavior is what behavior by the external trigger actually triggers the DAQ to start acquiring data. Can be configured to either: :Rising, :Falling, :High, or :Low; corresponding to, respectively, trigger on the rising edge, trigger on the falling edge, trigger on high voltage, trigger on low voltage\n\n\nsource\n\n\n#\n\n\nInstrumentControl.AWGM320XA.TrigSync\n \n \nType\n.\n\n\nCan be configured to be :CLKsys or :CLK10, which, respectively, corresponds to processing an acquired trigger on the next internal clock tick, or on the next chassis clock tick.\n\n\nsource\n\n\n#\n\n\nInstrumentControl.AWGM320XA.Queue\n \n \nType\n.\n\n\nList of waveform IDs, corresponding to waveforms queued in a particular channel. Order of waveform IDs corresponds to order of queued waveforms\n\n\nsource\n\n\n#\n\n\nInstrumentControl.AWGM320XA.QueueCycleMode\n \n \nType\n.\n\n\nCan be configured to, respectively, :Cyclic or :OneShot, which corresponds to, respectively, configuring the queue to repeat indefinitely, or configuring the queue to only be outputted one time\n\n\nsource\n\n\n#\n\n\nInstrumentControl.AWGM320XA.QueueSyncMode\n \n \nType\n.\n\n\nCan be configured to be :CLKsys or :CLK10, which, respectively, corresponds to start sequencing a queue on the next internal clock tick, or on the next chassis clock tick.\n\n\nsource\n\n\n#\n\n\nInstrumentControl.AWGM320XA.AmpModMode\n \n \nType\n.\n\n\nAmplitude modulation mode. Can be configured to either :NoMod, :AmplitudeMod, or :DCMod\n\n\nsource\n\n\n#\n\n\nInstrumentControl.AWGM320XA.AngModMode\n \n \nType\n.\n\n\nAngle modulation mode. Can be configure to either :NoMod, :PhaseMod, or :FrequencyMod.\n\n\nsource\n\n\n#\n\n\nInstrumentControl.AWGM320XA.AmpModGain\n \n \nType\n.\n\n\nAmplitude of amplitude modulating signal. Configured to be a \nFloat64\n number.\n\n\nsource\n\n\n#\n\n\nInstrumentControl.AWGM320XA.AngModGain\n \n \nType\n.\n\n\nAmplitude of angle modulating signal. Configured to be a \nFloat64\n number.\n\n\nsource\n\n\n\n\nWaveforms\n\n\nBasics In this module's implementation, we allow for handling of waveforms through the following type:\n\n\n#\n\n\nInstrumentControl.AWGM320XA.Waveform\n \n \nType\n.\n\n\nmutable struct Waveform\n    waveformValues::Array{Float64}\n    name::String\n    ch_properties::Dict{Int, Dict{Any, Any}}\n    Waveform(waveformValues, name) = begin\n        wav = new()\n        wav.name = name\n        wav.waveformValues = waveformValues\n        wav.ch_properties = Dict{Int, Dict{Any, Any}}()\n        return wav\n    end\nend\n\n\n\n\n\nObject representing a waveform; it holds as fields a waveform name, the actual waveform digital values, and  individual channel properties in a dictionary named \nch_properties\n. When waveforms are queued in an AWG channel from the RAM, various settings pertaining to when and how the waveform will be generated and outputted must be specified, such as: what triggers the waveform to start, how many times it should repeat in a cycle, what is the delay between the trigger and the generation of the waveform, etc. These settings can also vary from channel to channel, and cannot be queried directly from the instrument\n\n\nThus, we store this waveform channel configuration information in the dictionary \nch_properties\n. In this type's implementation, the values of the dictionaries are themselves dictionaries that hold all configuration information particular to a channel.For example, for an object \nwav::Waveform\n, \nwav.ch_properties[1]\n will return a dictionary that holds all configuration information specific to channel 1. Its keys will be subtypes of the \nWaveChProperty\n abstract type, and its values will be the values which the channel property associated that subtype are configured to for the waveform.\n\n\nThe inner constructor provided takes an array of points and a waveform name, and initializes a blank \nch_properties\n dictionary.\n\n\nsource\n\n\nWhen a waveform is loaded into the RAM, the corresponding \nWaveform\n object is stored in the \nwaveforms\n field of the \nInsAWGM320XA\n object, indexed by the ID specified when loading the waveform. When a waveform is queued in a particular channel, it's ID is added to a list of the queued waveforms which can be accessed by a \ngetindex\n with \nQueue\n as the \"index\". This object conveniently stores the waveform array values, a name (meant to be more descriptive than an integer), and queue properties once a waveform is queued.\n\n\nNatively, you load waveforms into the AWG as arrays through Keysight's native C functions, where you specify an \"id\" which is the defacto handle for handling waveforms for all subsequent queueing. However, once you load a waveform you can't query the instrument to see it, and an id is not exactly a descriptive handle; moreover, once you queue a waveform you can't query the instrument for what settings the waveform was queued with (trigger_mode, delay, etc). We get around these nuisances by making all loading and queueing of waveforms be tied to instantiating and manipulating these \nWaveform\n objects. However, waveform manipulation can also be done through the waveform ID's if so desired by the user.\n\n\n\n\nUsage\n\n\nOnce you have a \nWaveform\n object, or an array of values to load onto the AWG's RAM as a waveform, these are the methods to load and queue waveforms, as well as to empty the queues, empty the RAM, etc:\n\n\n#\n\n\nInstrumentControl.AWGM320XA.load_waveform\n \n \nFunction\n.\n\n\nload_waveform\n(\nins\n::\nInsAWGM320XA\n,\n \nwaveform\n::\nWaveform\n,\n \nid\n::\nInteger\n;\n\n                   \ninput_type\n::\nSymbol\n \n=\n \n:\nAnalog16\n)\n\n\nload_waveform\n(\nins\n::\nInsAWGM320XA\n,\n \nwaveformValues\n::\nArray\n{\nFloat64\n}\n,\n \nid\n::\nInteger\n,\n\n                   \nname\n::\nAbstractString\n \n=\n \nstring\n(\nid\n);\n \ninput_type\n::\nSymbol\n \n=\n \n:\nAnalog16\n)\n\n\nload_waveform\n(\nins\n::\nInsAWGM320XA\n,\n \nwaveformFile\n::\nString\n,\n \nid\n::\nInteger\n,\n\n                   \nname\n::\nAbstractString\n \n=\n \nstring\n(\nid\n))\n\n\n\n\n\n\nLoads a waveform into the the RAM of the AWG corresponding to object \nins\n. When loading a waveform, the user picks an id to be the identifier and handle for the loaded waveform. Thus, the function takes as arguments either: A \nWaveform\n object , or the waveform digital values, or a filepath to a waveform file, as well as the user-specified id, a name for the waveform (meant to be a more descriptive identifier than an integer), and the input type(refer to Table 9 of the userguide for discussion on input types). The waveform digital values can be passed as an array of values, or as a path to a file containing the values.\n\n\nThe loads a the waveform, initializes a waveform object if passed an array or filepath, and initializes the blank dictionaries for each channel in the field \nch_properties\n. The function returns a handle to the new \nWaveform\n object created and stored in \nins.waveforms\n, indexed by it's user-specified id.\n\n\nsource\n\n\n#\n\n\nInstrumentControl.AWGM320XA.queue_waveform\n \n \nFunction\n.\n\n\nqueue_waveform\n(\nins\n::\nInsAWGM320XA\n,\n \nch\n::\nInteger\n,\n \nid\n::\nInteger\n,\n \ntrigger_mode\n::\nSymbol\n;\n\n              \nrepetitions\n::\nInteger\n \n=\n \n1\n,\n \ndelay\n::\nInteger\n \n=\n \n0\n,\n \nprescaler\n::\nInteger\n \n=\n \n0\n \n)\n\n\nqueue_waveform\n(\nins\n::\nInsAWGM320XA\n,\n \nch\n::\nInteger\n,\n \nwav\n::\nWaveform\n,\n \ntrigger_mode\n::\nSymbol\n;\n\n               \nrepetitions\n::\nInteger\n \n=\n \n1\n,\n \ndelay\n::\nInteger\n \n=\n \n0\n,\n \nprescaler\n::\nInteger\n \n=\n \n0\n \n)\n\n\n\n\n\n\nQueues a waveform in a channel of the AWG either by a passed \nWaveform\n object or the waveform id. It also takes inputs for configuration settings pertaining to when and how the waveform will be generated and outputted, such as trigger mode, number of repetitions, delay between the trigger and generation, and the prescaler value for the outputted waveform. While the channel and trigger_mode must be specified, the other settings are used as keyword arguments with standard values (chosen by me).\n\n\nsource\n\n\n#\n\n\nInstrumentControl.AWGM320XA.waveforms_flush\n \n \nFunction\n.\n\n\nwaveforms_flush(ins::InsAWGM320XA)\n\n\n\n\n\nErases all waveforms stored in the RAM of the AWG, and empties the queue of all the channels. This function both: uses the native C \nSD_AOU_waveformFlush\n function to empty the erase the RAM and empty the queues in the instrument, it re-initializes \nins.channels[ch][Queue]\n vector as a blank vector for all channels, erasing the record of the queue in the \nInsAWGM30XA\n object as well, and re-initializes \nins.waveforms\n as a blank dictionary\n\n\nsource\n\n\n#\n\n\nInstrumentControl.AWGM320XA.memory_size\n \n \nFunction\n.\n\n\nmemory_size(ins::InsAWGM320XA, wav::Waveform)\nmemory_size(ins::InsAWGM320XA, id::Integer)\n\n\n\n\n\nObtain size of waveform in memory\n\n\nsource", 
            "title": "M320XA"
        }, 
        {
            "location": "/waveform_generators/awgM320XA/#keysight-m320xa-awgs", 
            "text": "This module contains the many methods and types necessary to control and configure the Keysight M3202A/M3201A AWGs. In essence, it wraps the  KeysightInstruments.jl  package, which in itself is a bare-bones wrapper to the native C library which controls the Keysight instruments, in a way which affords compatibility with the rest of the InstrumentControl package, as well as consistency between the control code of this instrument and other instruments represented in this package.", 
            "title": "Keysight M320XA AWGs"
        }, 
        {
            "location": "/waveform_generators/awgM320XA/#usageconfiguration", 
            "text": "", 
            "title": "Usage/Configuration"
        }, 
        {
            "location": "/waveform_generators/awgM320XA/#instrument-overview", 
            "text": "Each M320XA AWG card has several channels; each channel has it's own  Function Generator  as well as it's own  Arbitary Waveform Generator . The function generator outputs sinusoids, triangular waves, and square waves. The user can select the output of the channel to either come from the arbitrary waveform generator, or from the function generator.  Moreover, the arbitrary waveform generator can be used to  modulate  the function generator output: it can be used for amplitude modulation, phase modulation, frequency modulation, or DC offset modulation  When used for amplitude modulation, the output signal is given by:  Output(t) = (A + G*AWG(t))* cos(\u03c9t + \u03d5) + DC  When used for phase modulation, the output signal is given by:  Output(t) = A*cos(\u03c9t + \u03d5 + G*AWG(t)) + DC  When used for frequency modulation, the output signal is given by:  Output(t) = A*cos((\u03c9+G*AWG(t))* t + \u03d5) + DC  When used for DC offset modulation, the output signal is given by:  Output(t) = A*cos(\u03c9t + \u03d5) + DC + G*AWG(t)     When using the AWG for direct output (not modulation):  Output(t) = A*AWG(t) + DC   A is the channel amplitude configured by the user  AWG(t) is the  normalized  waveform which is loaded and queued by the user and generated by the AWG  f = \u03c9/2\u03c0 is the channel's function generator's frequency set by the user  \u03d5 is the channel's function generator's relative phase configured by the user  G is the \"amplitude\" of the AWG signal, which is configured by the user  DC is the channel's DC offset, configured by the user.   Waveforms are loaded as  normalized  arrays (i.e., from -1 to 1) to the onboard RAM of the AWG; when they are loaded the user specifies an number ID which servers as the handle to the waveform from then on. The loaded waveforms are then queued onto particular channels with the following parameters:   Trigger mode (i.e.: Trigger from PXI or Software or Automatically)  Delay from trigger to output  Number of repetitions  Prescaler   Then, after queueing the waveforms, we \"start\" the AWG (with our  awg_start  function), which then starts outputting waveforms upon acquisition of triggers.  Moreover, each AWG card has it's own internal 100MHz clock which is phase-locked to the chassis clock: any actions taken by the AWG occur on a clock tick (so in intervals of 10ns), and different AWG/Digitizer cards are synchronized through the chassis clock. Each card also has an extra port called the TRG port, on which triggers can be received or generated.", 
            "title": "Instrument Overview"
        }, 
        {
            "location": "/waveform_generators/awgM320XA/#usage", 
            "text": "All instrument control and configuration happens through the following  Instrument  subtype:  #  InstrumentControl.AWGM320XA.InsAWGM320XA     Type .  mutable struct InsAWGM320XA  : Instrument\n    serial_num::String\n    product_name::String\n    index::Int\n    chassis_num::Int\n    slot_num::Int\n    channels::Dict{Int, Dict{Any, Any}}\n    waveforms::Dict{Int, Waveform}\nend  Object representing an AWGM320XA instrument. It holds, as fields, instrument information such as AWG instrument index, slot number, chassis number, serial number, product name, etc. We take this object to represent both M3202A AWGs and M3201A AWGs, since they have the exact same functionality, they only have different specs. The  product_name  field can be used to distinguish wether an object of type  InsAWGM320XA  correponds to an M3202A or M3101A AWG via its \"name\".  In addition, the AWG object holds all the waveforms stored in RAM in a dictionary, named  waveforms ,  where the waveforms are indexed by their identifier number, which the user specifies when he/she loads an waveform into the RAM of the AWG.  This object also holds individual channel properties in a dictionary named  channels , where in the type's implementation, the values of the dictionaries are themselves dictionaries that hold all configuration information for a particular channel.For example, for an object  ins::InsAWGM320XA ,  ins.channels[1]  will return a dictionary that holds all configuration information for channel 1; its keys will be subtypes of the  InstrumentProperty  abstract type, and its values will be the values which the instrument property associated that subtype are configured to in that channel in the digitizer.  Two inner constructors are provided: one which initializes the object with a given slot number and chassis number, and one which initializes the object with a given serial number and name. Both inner constructors also take a  num_channels  keyword argument, corresponding to the number of channels on the instrument, which is used for initial configuration of the instrument channels. When the object is initialized, it obtains all other instrument information described above with the passed arguments, initializes the  waveforms  dictionary, and initializes all the channels properties to some standard values and records them in the  channels  dictionary through the  configure_channels!  function.  source  For example, calling  InsAWGM320XA(3,1,num_channels = 4)  will open the AWG card on slot 3 on the PXI chassis indexed by 1 (internal Keysight software does the chassis \"indexing\");  num_channels  corresponds to the number of channels in the AWG card. The second input, which sets the value for the  chassis  field in the  InsAWGM320XA  object, is an optional argument with default value  1  (for the case when only one chassis is connected to the computer), while the  num_channels  input is a keyword argument whose default value is  4  \u2013  Hence,  InsAWGM320XA(3)  would make an instance of the same object.  Moreover, once waveforms are loaded and queued, each channel's AWG can be started and checked to see if it's running with the following methods  #  InstrumentControl.AWGM320XA.awg_start     Function .  awg_start(awg::InsAWGM320XA, ch::Integer)\nawg_start(awg::InsAWGM320XA, chs::Vararg{Int})\n\nStarts acquisition of triggers for generation/ouputting of all waveforms\nqueued on the awg(s) of channel `ch` or channels `chs`.  source  #  InstrumentControl.AWGM320XA.awg_is_running     Function .  awg_is_run(awg::InsAWGM320XA, ch::Integer)\nChecks if the AWG corresponding to channel `ch` on AWG card corresponding to\nobject `awg` is  running , i.e. it is waiting for triggers to output waveforms\nor is actively outputting waveforms. Prints either  YES  or  NO   source", 
            "title": "Usage"
        }, 
        {
            "location": "/waveform_generators/awgM320XA/#configuration", 
            "text": "Configuration/Inspection of settings happens through setindex!/getindex methods, as described in  Overview  These are the following properties which can be configured, each of which has it's own  InstrumentProperty  subtype:  #  InstrumentControl.AWGM320XA.OutputMode     Type .  Configures the type of output from an AWG channel. Can be configured to be either :Off, :Sinusoidal, :Triangular, :Square, :DC, :Arbitrary, or :Differential  source  #  InstrumentControl.AWGM320XA.DCOffset     Type .  Sets a channel's DC offset on output. Configured to be a  Float64  number.  source  #  InstrumentControl.AWGM320XA.FGFrequency     Type .  Sets a channel's function generator frequency. Configured to be a  Float64  number.  source  #  InstrumentControl.AWGM320XA.FGPhase     Type .  Sets a channel's function generator's relative phase. Configured to be a  Float64  number.  source  #  InstrumentControl.AWGM320XA.TrigSource     Type .  Source of external trigger. Can be configured to be either a number 0-7, which corresponds to a PXI line on the PXI backplane, or :TrgPort, which corresponds to the Trg port on the AWG card  source  #  InstrumentControl.AWGM320XA.TrigBehavior     Type .  External trigger behavior is what behavior by the external trigger actually triggers the DAQ to start acquiring data. Can be configured to either: :Rising, :Falling, :High, or :Low; corresponding to, respectively, trigger on the rising edge, trigger on the falling edge, trigger on high voltage, trigger on low voltage  source  #  InstrumentControl.AWGM320XA.TrigSync     Type .  Can be configured to be :CLKsys or :CLK10, which, respectively, corresponds to processing an acquired trigger on the next internal clock tick, or on the next chassis clock tick.  source  #  InstrumentControl.AWGM320XA.Queue     Type .  List of waveform IDs, corresponding to waveforms queued in a particular channel. Order of waveform IDs corresponds to order of queued waveforms  source  #  InstrumentControl.AWGM320XA.QueueCycleMode     Type .  Can be configured to, respectively, :Cyclic or :OneShot, which corresponds to, respectively, configuring the queue to repeat indefinitely, or configuring the queue to only be outputted one time  source  #  InstrumentControl.AWGM320XA.QueueSyncMode     Type .  Can be configured to be :CLKsys or :CLK10, which, respectively, corresponds to start sequencing a queue on the next internal clock tick, or on the next chassis clock tick.  source  #  InstrumentControl.AWGM320XA.AmpModMode     Type .  Amplitude modulation mode. Can be configured to either :NoMod, :AmplitudeMod, or :DCMod  source  #  InstrumentControl.AWGM320XA.AngModMode     Type .  Angle modulation mode. Can be configure to either :NoMod, :PhaseMod, or :FrequencyMod.  source  #  InstrumentControl.AWGM320XA.AmpModGain     Type .  Amplitude of amplitude modulating signal. Configured to be a  Float64  number.  source  #  InstrumentControl.AWGM320XA.AngModGain     Type .  Amplitude of angle modulating signal. Configured to be a  Float64  number.  source", 
            "title": "Configuration"
        }, 
        {
            "location": "/waveform_generators/awgM320XA/#waveforms", 
            "text": "", 
            "title": "Waveforms"
        }, 
        {
            "location": "/waveform_generators/awgM320XA/#basics-in-this-modules-implementation-we-allow-for-handling-of-waveforms-through-the-following-type", 
            "text": "#  InstrumentControl.AWGM320XA.Waveform     Type .  mutable struct Waveform\n    waveformValues::Array{Float64}\n    name::String\n    ch_properties::Dict{Int, Dict{Any, Any}}\n    Waveform(waveformValues, name) = begin\n        wav = new()\n        wav.name = name\n        wav.waveformValues = waveformValues\n        wav.ch_properties = Dict{Int, Dict{Any, Any}}()\n        return wav\n    end\nend  Object representing a waveform; it holds as fields a waveform name, the actual waveform digital values, and  individual channel properties in a dictionary named  ch_properties . When waveforms are queued in an AWG channel from the RAM, various settings pertaining to when and how the waveform will be generated and outputted must be specified, such as: what triggers the waveform to start, how many times it should repeat in a cycle, what is the delay between the trigger and the generation of the waveform, etc. These settings can also vary from channel to channel, and cannot be queried directly from the instrument  Thus, we store this waveform channel configuration information in the dictionary  ch_properties . In this type's implementation, the values of the dictionaries are themselves dictionaries that hold all configuration information particular to a channel.For example, for an object  wav::Waveform ,  wav.ch_properties[1]  will return a dictionary that holds all configuration information specific to channel 1. Its keys will be subtypes of the  WaveChProperty  abstract type, and its values will be the values which the channel property associated that subtype are configured to for the waveform.  The inner constructor provided takes an array of points and a waveform name, and initializes a blank  ch_properties  dictionary.  source  When a waveform is loaded into the RAM, the corresponding  Waveform  object is stored in the  waveforms  field of the  InsAWGM320XA  object, indexed by the ID specified when loading the waveform. When a waveform is queued in a particular channel, it's ID is added to a list of the queued waveforms which can be accessed by a  getindex  with  Queue  as the \"index\". This object conveniently stores the waveform array values, a name (meant to be more descriptive than an integer), and queue properties once a waveform is queued.  Natively, you load waveforms into the AWG as arrays through Keysight's native C functions, where you specify an \"id\" which is the defacto handle for handling waveforms for all subsequent queueing. However, once you load a waveform you can't query the instrument to see it, and an id is not exactly a descriptive handle; moreover, once you queue a waveform you can't query the instrument for what settings the waveform was queued with (trigger_mode, delay, etc). We get around these nuisances by making all loading and queueing of waveforms be tied to instantiating and manipulating these  Waveform  objects. However, waveform manipulation can also be done through the waveform ID's if so desired by the user.", 
            "title": "Basics In this module's implementation, we allow for handling of waveforms through the following type:"
        }, 
        {
            "location": "/waveform_generators/awgM320XA/#usage_1", 
            "text": "Once you have a  Waveform  object, or an array of values to load onto the AWG's RAM as a waveform, these are the methods to load and queue waveforms, as well as to empty the queues, empty the RAM, etc:  #  InstrumentControl.AWGM320XA.load_waveform     Function .  load_waveform ( ins :: InsAWGM320XA ,   waveform :: Waveform ,   id :: Integer ; \n                    input_type :: Symbol   =   : Analog16 )  load_waveform ( ins :: InsAWGM320XA ,   waveformValues :: Array { Float64 } ,   id :: Integer , \n                    name :: AbstractString   =   string ( id );   input_type :: Symbol   =   : Analog16 )  load_waveform ( ins :: InsAWGM320XA ,   waveformFile :: String ,   id :: Integer , \n                    name :: AbstractString   =   string ( id ))   Loads a waveform into the the RAM of the AWG corresponding to object  ins . When loading a waveform, the user picks an id to be the identifier and handle for the loaded waveform. Thus, the function takes as arguments either: A  Waveform  object , or the waveform digital values, or a filepath to a waveform file, as well as the user-specified id, a name for the waveform (meant to be a more descriptive identifier than an integer), and the input type(refer to Table 9 of the userguide for discussion on input types). The waveform digital values can be passed as an array of values, or as a path to a file containing the values.  The loads a the waveform, initializes a waveform object if passed an array or filepath, and initializes the blank dictionaries for each channel in the field  ch_properties . The function returns a handle to the new  Waveform  object created and stored in  ins.waveforms , indexed by it's user-specified id.  source  #  InstrumentControl.AWGM320XA.queue_waveform     Function .  queue_waveform ( ins :: InsAWGM320XA ,   ch :: Integer ,   id :: Integer ,   trigger_mode :: Symbol ; \n               repetitions :: Integer   =   1 ,   delay :: Integer   =   0 ,   prescaler :: Integer   =   0   )  queue_waveform ( ins :: InsAWGM320XA ,   ch :: Integer ,   wav :: Waveform ,   trigger_mode :: Symbol ; \n                repetitions :: Integer   =   1 ,   delay :: Integer   =   0 ,   prescaler :: Integer   =   0   )   Queues a waveform in a channel of the AWG either by a passed  Waveform  object or the waveform id. It also takes inputs for configuration settings pertaining to when and how the waveform will be generated and outputted, such as trigger mode, number of repetitions, delay between the trigger and generation, and the prescaler value for the outputted waveform. While the channel and trigger_mode must be specified, the other settings are used as keyword arguments with standard values (chosen by me).  source  #  InstrumentControl.AWGM320XA.waveforms_flush     Function .  waveforms_flush(ins::InsAWGM320XA)  Erases all waveforms stored in the RAM of the AWG, and empties the queue of all the channels. This function both: uses the native C  SD_AOU_waveformFlush  function to empty the erase the RAM and empty the queues in the instrument, it re-initializes  ins.channels[ch][Queue]  vector as a blank vector for all channels, erasing the record of the queue in the  InsAWGM30XA  object as well, and re-initializes  ins.waveforms  as a blank dictionary  source  #  InstrumentControl.AWGM320XA.memory_size     Function .  memory_size(ins::InsAWGM320XA, wav::Waveform)\nmemory_size(ins::InsAWGM320XA, id::Integer)  Obtain size of waveform in memory  source", 
            "title": "Usage"
        }, 
        {
            "location": "/waveform_generators/awg5014c/", 
            "text": "Documentation forthcoming.", 
            "title": "AWG5014C"
        }, 
        {
            "location": "/digitizers/digM3102A/", 
            "text": "Keysight M3102A Digitizer\n\n\nThis module contains the many methods and types necessary to control and configure the Keysight M3102A Digitizer. In essence, it wraps the \nKeysightInstruments.jl\n package, which in itself is a bare-bones wrapper to the native C library which controls the Keysight instruments, in a way which affords compatibility with the rest of the InstrumentControl package, as well as consistency between the control code of this instrument and other instruments represented in this package.\n\n\n\n\nUsage/Configuration\n\n\nInstrument Overview\n\n\nEach MM3102A Digitizer card has several channels; each channel has it's own DAQ for reading data. The DAQ reads data upon acquisition of triggers, and stores the data in a buffer allocated in the onboard RAM of the digitizer card. Upon reaching a user defined threshold for data acquisition, either an memory threshold or a time threshold, the contents of the buffer are passed on to the computer through the (fast) PXI cables. The DAQ can also be configured to read the data in \"cycles\", where acquisition for each cycle commences upon receiving a trigger, in which the user configures the amount of data acquired in each cycle.\n\n\nMoreover, each Digitizer card has it's own internal 100MHz clock which is phase-locked to the chassis clock: any actions taken by the AWG occur on a clock tick (so in intervals of 10ns), and different AWG/Digitizer cards are synchronized through the chassis clock. Each card also has an extra port called the TRG port, on which triggers can be received or generated\n\n\nUsage\n\n\nAll instrument control and configuration happens through the following \nInstrument\n subtype:\n\n\n#\n\n\nInstrumentControl.DigitizerM3102A.InsDigitizerM3102A\n \n \nType\n.\n\n\nmutable struct InsDigitizerM3102A \n: Instrument\n    serial_num::String\n    product_name::String\n    index::Int\n    chassis_num::Int\n    slot_num::Int\n    channels::Dict{Int,Dict{Any,Any}}\nend\n\n\n\n\n\nObject representing an DigitizerM3102A instrument. It holds, as fields, instrument information such as digitizer card instrument index, slot number, chassis number, serial number, product name, etc.\n\n\nThis object also holds individual channel properties in a dictionary named \nchannels\n, where in the type's implementation, the values of the dictionaries are themselves dictionaries that hold all configuration information for a particular channel.For example, for an object \nins::InsDigitizerM3102A\n, \nins.channels[1]\n will return a dictionary that holds all configuration information for channel 1; its keys will be subtypes of the \nInstrumentProperty\n abstract type, and its values will be the values which the instrument property associated that subtype are configured to in that channel in the digitizer.\n\n\nTwo inner constructors are provided: one which initializes the object with a given slot number and chassis number, and one which initializes the object with a given serial number. When the object is initialized, it obtains all other instrument information described above with the passed arguments, and initializes all the channels properties to some standard values and records them in the \nchannels\n dictionary through the \nconfigure_channels!\n function\n\n\nsource\n\n\nFor example, calling \nInsDigitizerM3102A(16,1,num_channels = 4)\n will open the Digitizer card on slot 16 on the PXI chassis indexed by 1 (internal Keysight software does the chassis \"indexing\"); \nnum_channels\n corresponds to the number of channels in the Digitizer card. The second input, which sets the value for the \nchassis\n field in the \nInsDigitizerM3102A\n object, is an optional argument with default value \n1\n (for the case when only one chassis is connected to the computer), while the \nnum_channels\n input is a keyword argument whose default value is \n4\n \u2013\n Hence, \nInsDigitizerM3102A(16)\n would make an instance of the same object.\n\n\nConfiguration\n\n\nConfiguration/Inspection of settings happens through setindex!/getindex methods, as described in \nOverview\n\n\nThese are the following properties which can be configured, each of which has it's own \nInstrumentProperty\n subtype:\n\n\n#\n\n\nInstrumentControl.DigitizerM3102A.FullScale\n \n \nType\n.\n\n\nFullscale of each channel. For example, if the fullscale is configured to be 1V, the digitizer measures voltages on the range of 1V to -1V, and truncates any values outside this interval to the interval's boundary. The data acquired by the digitizer is converted to voltages by the formula data*FullScale/2e15\n\n\nsource\n\n\n#\n\n\nInstrumentControl.DigitizerM3102A.InputMode\n \n \nType\n.\n\n\nCan be configured to be either :DC or :AC\n\n\nsource\n\n\n#\n\n\nInstrumentControl.DigitizerM3102A.Impedance\n \n \nType\n.\n\n\nCan be configured to be either :Ohm_50 or :Ohm_High, corresponding to either 50\u03a9 impedance or 1M\u03a9 impedance\n\n\nsource\n\n\n#\n\n\nInstrumentControl.DigitizerM3102A.Prescaler\n \n \nType\n.\n\n\nUsed to arbitrarily change the sampling rate of the digitizer: the effective sampling rate is 500e8/(1+prescaler). Can be configured to be an integer greater than or equal to zero\n\n\nsource\n\n\n#\n\n\nInstrumentControl.DigitizerM3102A.AnalogTrigBehavior\n \n \nType\n.\n\n\nAnalog trigger means trigger by the incoming data itself. Analog trigger behavior is what behavior by the incoming data triggers the DAQ to start acquiring data. Can be configured to either: :RisingAnalog, :FallingAnalog, or :BothAnalog, corresponding to, respectively, trigger on the rising edge, trigger on the falling edge, or trigger on any edge\n\n\nsource\n\n\n#\n\n\nInstrumentControl.DigitizerM3102A.AnalogTrigThreshold\n \n \nType\n.\n\n\nThreshold on which, if the incoming data surpasses, generarates an analog trigger to the DAQ. Configured to be a \nFloat64\n number.\n\n\nsource\n\n\n#\n\n\nInstrumentControl.DigitizerM3102A.DAQTrigMode\n \n \nType\n.\n\n\nConfigures which type of trigger the DAQ will start measuring data upon trigger acquisition. Can be configured to :Auto (no trigger), :Software, :External, or :Analog.\n\n\nsource\n\n\n#\n\n\nInstrumentControl.DigitizerM3102A.DAQTrigDelay\n \n \nType\n.\n\n\nDelay between acquisition of trigger and measurement of incoming data. Configured to be an integer, the delay is measured in units of samples \n-\n in units of 2ns.\n\n\nsource\n\n\n#\n\n\nInstrumentControl.DigitizerM3102A.DAQPointsPerCycle\n \n \nType\n.\n\n\nNumber of samples measured per DAQ cycle\n\n\nsource\n\n\n#\n\n\nInstrumentControl.DigitizerM3102A.DAQCycles\n \n \nType\n.\n\n\nNumber of \"cycles\" for which the digitizer will acquire data; data acquisition for each cycle starts upon receiving whatever trigger is configure by DAQTrigMode property\n\n\nsource\n\n\n#\n\n\nInstrumentControl.DigitizerM3102A.ExternalTrigSource\n \n \nType\n.\n\n\nSource of external trigger. Can be configured to be either a number 0-7, which corresponds to a PXI line on the PXI backplane, or :TrgPort, which corresponds to the Trg port on the digitizer card\n\n\nsource\n\n\n#\n\n\nInstrumentControl.DigitizerM3102A.ExternalTrigBehavior\n \n \nType\n.\n\n\nExternal trigger behavior is what behavior by the external trigger actually triggers the DAQ to start acquiring data. Can be configured to either: :Rising, :Falling, :High, or :Low; corresponding to, respectively, trigger on the rising edge, trigger on the falling edge, trigger on high voltage, trigger on low voltage\n\n\nsource\n\n\n#\n\n\nInstrumentControl.DigitizerM3102A.AnalogTrigSource\n \n \nType\n.\n\n\nSource of analog trigger; can be configured to be an integer corresponding to a channel number in the digitizer\n\n\nsource", 
            "title": "M3102A"
        }, 
        {
            "location": "/digitizers/digM3102A/#keysight-m3102a-digitizer", 
            "text": "This module contains the many methods and types necessary to control and configure the Keysight M3102A Digitizer. In essence, it wraps the  KeysightInstruments.jl  package, which in itself is a bare-bones wrapper to the native C library which controls the Keysight instruments, in a way which affords compatibility with the rest of the InstrumentControl package, as well as consistency between the control code of this instrument and other instruments represented in this package.", 
            "title": "Keysight M3102A Digitizer"
        }, 
        {
            "location": "/digitizers/digM3102A/#usageconfiguration", 
            "text": "", 
            "title": "Usage/Configuration"
        }, 
        {
            "location": "/digitizers/digM3102A/#instrument-overview", 
            "text": "Each MM3102A Digitizer card has several channels; each channel has it's own DAQ for reading data. The DAQ reads data upon acquisition of triggers, and stores the data in a buffer allocated in the onboard RAM of the digitizer card. Upon reaching a user defined threshold for data acquisition, either an memory threshold or a time threshold, the contents of the buffer are passed on to the computer through the (fast) PXI cables. The DAQ can also be configured to read the data in \"cycles\", where acquisition for each cycle commences upon receiving a trigger, in which the user configures the amount of data acquired in each cycle.  Moreover, each Digitizer card has it's own internal 100MHz clock which is phase-locked to the chassis clock: any actions taken by the AWG occur on a clock tick (so in intervals of 10ns), and different AWG/Digitizer cards are synchronized through the chassis clock. Each card also has an extra port called the TRG port, on which triggers can be received or generated", 
            "title": "Instrument Overview"
        }, 
        {
            "location": "/digitizers/digM3102A/#usage", 
            "text": "All instrument control and configuration happens through the following  Instrument  subtype:  #  InstrumentControl.DigitizerM3102A.InsDigitizerM3102A     Type .  mutable struct InsDigitizerM3102A  : Instrument\n    serial_num::String\n    product_name::String\n    index::Int\n    chassis_num::Int\n    slot_num::Int\n    channels::Dict{Int,Dict{Any,Any}}\nend  Object representing an DigitizerM3102A instrument. It holds, as fields, instrument information such as digitizer card instrument index, slot number, chassis number, serial number, product name, etc.  This object also holds individual channel properties in a dictionary named  channels , where in the type's implementation, the values of the dictionaries are themselves dictionaries that hold all configuration information for a particular channel.For example, for an object  ins::InsDigitizerM3102A ,  ins.channels[1]  will return a dictionary that holds all configuration information for channel 1; its keys will be subtypes of the  InstrumentProperty  abstract type, and its values will be the values which the instrument property associated that subtype are configured to in that channel in the digitizer.  Two inner constructors are provided: one which initializes the object with a given slot number and chassis number, and one which initializes the object with a given serial number. When the object is initialized, it obtains all other instrument information described above with the passed arguments, and initializes all the channels properties to some standard values and records them in the  channels  dictionary through the  configure_channels!  function  source  For example, calling  InsDigitizerM3102A(16,1,num_channels = 4)  will open the Digitizer card on slot 16 on the PXI chassis indexed by 1 (internal Keysight software does the chassis \"indexing\");  num_channels  corresponds to the number of channels in the Digitizer card. The second input, which sets the value for the  chassis  field in the  InsDigitizerM3102A  object, is an optional argument with default value  1  (for the case when only one chassis is connected to the computer), while the  num_channels  input is a keyword argument whose default value is  4  \u2013  Hence,  InsDigitizerM3102A(16)  would make an instance of the same object.", 
            "title": "Usage"
        }, 
        {
            "location": "/digitizers/digM3102A/#configuration", 
            "text": "Configuration/Inspection of settings happens through setindex!/getindex methods, as described in  Overview  These are the following properties which can be configured, each of which has it's own  InstrumentProperty  subtype:  #  InstrumentControl.DigitizerM3102A.FullScale     Type .  Fullscale of each channel. For example, if the fullscale is configured to be 1V, the digitizer measures voltages on the range of 1V to -1V, and truncates any values outside this interval to the interval's boundary. The data acquired by the digitizer is converted to voltages by the formula data*FullScale/2e15  source  #  InstrumentControl.DigitizerM3102A.InputMode     Type .  Can be configured to be either :DC or :AC  source  #  InstrumentControl.DigitizerM3102A.Impedance     Type .  Can be configured to be either :Ohm_50 or :Ohm_High, corresponding to either 50\u03a9 impedance or 1M\u03a9 impedance  source  #  InstrumentControl.DigitizerM3102A.Prescaler     Type .  Used to arbitrarily change the sampling rate of the digitizer: the effective sampling rate is 500e8/(1+prescaler). Can be configured to be an integer greater than or equal to zero  source  #  InstrumentControl.DigitizerM3102A.AnalogTrigBehavior     Type .  Analog trigger means trigger by the incoming data itself. Analog trigger behavior is what behavior by the incoming data triggers the DAQ to start acquiring data. Can be configured to either: :RisingAnalog, :FallingAnalog, or :BothAnalog, corresponding to, respectively, trigger on the rising edge, trigger on the falling edge, or trigger on any edge  source  #  InstrumentControl.DigitizerM3102A.AnalogTrigThreshold     Type .  Threshold on which, if the incoming data surpasses, generarates an analog trigger to the DAQ. Configured to be a  Float64  number.  source  #  InstrumentControl.DigitizerM3102A.DAQTrigMode     Type .  Configures which type of trigger the DAQ will start measuring data upon trigger acquisition. Can be configured to :Auto (no trigger), :Software, :External, or :Analog.  source  #  InstrumentControl.DigitizerM3102A.DAQTrigDelay     Type .  Delay between acquisition of trigger and measurement of incoming data. Configured to be an integer, the delay is measured in units of samples  -  in units of 2ns.  source  #  InstrumentControl.DigitizerM3102A.DAQPointsPerCycle     Type .  Number of samples measured per DAQ cycle  source  #  InstrumentControl.DigitizerM3102A.DAQCycles     Type .  Number of \"cycles\" for which the digitizer will acquire data; data acquisition for each cycle starts upon receiving whatever trigger is configure by DAQTrigMode property  source  #  InstrumentControl.DigitizerM3102A.ExternalTrigSource     Type .  Source of external trigger. Can be configured to be either a number 0-7, which corresponds to a PXI line on the PXI backplane, or :TrgPort, which corresponds to the Trg port on the digitizer card  source  #  InstrumentControl.DigitizerM3102A.ExternalTrigBehavior     Type .  External trigger behavior is what behavior by the external trigger actually triggers the DAQ to start acquiring data. Can be configured to either: :Rising, :Falling, :High, or :Low; corresponding to, respectively, trigger on the rising edge, trigger on the falling edge, trigger on high voltage, trigger on low voltage  source  #  InstrumentControl.DigitizerM3102A.AnalogTrigSource     Type .  Source of analog trigger; can be configured to be an integer corresponding to a channel number in the digitizer  source", 
            "title": "Configuration"
        }, 
        {
            "location": "/digitizers/Alazar/", 
            "text": "Alazar digitizers\n\n\nWe put all Alazar digitizers in module \nAlazarModule\n; the feature set and API is so similar for the various models that just one module makes sense.\n\n\nAn \nAlazarResponse\n type is given for each measurement mode of the digitizer. (\"Traditional record mode\" has not been implemented yet for lack of immediate need.) Additionally, one can define custom \nAlazarResponse\n types so that some custom computations or data reductions can be performed during acquisition. \nIQSoftwareResponse\n is a good example of this.\n\n\nIn the following discussion, it is important to understand some Alazar terminology. Newer Alazar digitizers use direct memory access (DMA) to stream data into a computer's RAM. A single \nacquisition\n uses one or many \nbuffers\n, which constitute preallocated regions in the computer's physical memory. Each buffer contains one or many \nrecords\n. Each \nrecord\n contains many \nsamples\n, which are the voltages measured by the digitizer. In streaming mode, there is only one record per buffer, but in other modes there can be many records per buffer.\n\n\nLooking at the source code, it would seem that there is some redundancy in the types, for instance there is an \nNPTRecordMode\n and an \nNPTRecordResponse\n object. The former is used internally in the code to denote a particular method of configuring the instrument, mirroring the terminology used in the Alazar API documentation. The latter specifies what you actually want to do using that configuration of the instrument. Perhaps you want to measure in a given mode, but do some custom post-processing or processing during acquisition. \nIQSoftwareResponse\n is an example of this: it uses \nNPTRecordMode\n but reduces the data during measurement. Typically the user doesn't have to deal with the various mode objects, unless developing a new \nAlazarResponse\n type.\n\n\n\n\nUsage\n\n\nHere are the currently defined \nAlazarResponse\n types you can use:\n\n\n#\n\n\nInstrumentControl.AlazarModule.ContinuousStreamResponse\n \n \nType\n.\n\n\nmutable struct ContinuousStreamResponse{S,T} \n: StreamResponse{S,T}\n\n\n\n\n\nResponse type implementing the \"continuous streaming mode\" of the Alazar API.\n\n\nUsage example:\n\n\nats = AlazarATS9870()\nsamples_per_ch = 1024\nres = ContinuousStreamResponse(ats, samples_per_ch)\nmeasure(res)\n\n\n\n\n\nsource\n\n\n#\n\n\nInstrumentControl.AlazarModule.TriggeredStreamResponse\n \n \nType\n.\n\n\nmutable struct TriggeredStreamResponse{S,T} \n: StreamResponse{S,T}\n\n\n\n\n\nResponse type implementing the \"triggered streaming mode\" of the Alazar API.\n\n\nUsage example:\n\n\nats = AlazarATS9870()\nsamples_per_ch = 1024\nres = TriggeredStreamResponse(ats, samples_per_ch)\nmeasure(res)\n\n\n\n\n\nsource\n\n\n#\n\n\nInstrumentControl.AlazarModule.NPTRecordResponse\n \n \nType\n.\n\n\nmutable struct NPTRecordResponse{S,T} \n: RecordResponse{S,T}\n\n\n\n\n\nResponse type implementing the \"NPT record mode\" of the Alazar API.\n\n\nUsage example:\n\n\nats = AlazarATS9870()\nsamples_per_rec_per_ch = 1024\ntotal_recs = 10\nres = NPTRecordResponse(ats, sam_per_rec_per_ch, total_recs)\nmeasure(res)\n\n\n\n\n\nsource\n\n\n#\n\n\nInstrumentControl.AlazarModule.FFTHardwareResponse\n \n \nType\n.\n\n\nmutable struct FFTHardwareResponse{S,T,U} \n: FFTResponse{S,T}\n\n\n\n\n\nResponse type implementing the FPGA-based \"FFT record mode\" of the Alazar API. Not all Alazar digitizers support this mode.\n\n\nUsage example:\n\n\nats = AlazarATS9360()\nsamples_per_rec = 1024\nsam_per_fft = 512\ntotal_recs = 10\nres = FFTHardwareResponse(ats, sam_per_rec, sam_per_fft, total_recs, Alazar.S32Real)\nmeasure(res)\n\n\n\n\n\nsource\n\n\n#\n\n\nInstrumentControl.AlazarModule.IQSoftwareResponse\n \n \nType\n.\n\n\nmutable struct IQSoftwareResponse{S,T} \n: RecordResponse{S,T}\n\n\n\n\n\nResponse type for measuring with NPT record mode and mixing in software to find the phase and amplitude of a component at frequency \nf\n. Slower than doing it in an FPGA, but ultimately necessary if we want to use both channels as inputs to the FFT.\n\n\nUsage example:\n\n\nats = AlazarATS9870()\nsamples_per_rec_per_ch = 1024\ntotal_recs = 10\nf = 100e6\nres = IQSoftwareResponse(ats, samples_per_rec_per_ch, total_recs, f)\nmeasure(res)\n\n\n\n\n\nsource\n\n\nThese definitions referenced some abstract types, described here:\n\n\n#\n\n\nInstrumentControl.AlazarModule.AlazarResponse\n \n \nType\n.\n\n\nabstract type AlazarResponse{S,T} \n: Response\n\n\n\n\n\nAbstract \nResponse\n from an Alazar digitizer instrument. Subtypes should implement \nreturn_type\n to specify the output array type if they rely on the generic method \nmeasure(::AlazarResponse)\n.\n\n\nsource\n\n\n#\n\n\nInstrumentControl.AlazarModule.StreamResponse\n \n \nType\n.\n\n\nabstract type StreamResponse{S,T} \n: AlazarResponse{S,T}\n\n\n\n\n\nAbstract time-domain streaming \nResponse\n from an Alazar digitizer instrument.\n\n\nsource\n\n\n#\n\n\nInstrumentControl.AlazarModule.RecordResponse\n \n \nType\n.\n\n\nabstract type RecordResponse{S,T} \n: AlazarResponse{S,T}\n\n\n\n\n\nAbstract time-domain record \nResponse\n from an Alazar digitizer instrument.\n\n\nsource\n\n\n\n\nTechnical details\n\n\n\n\nDigitizer requirements\n\n\nThe Alazar digitizers expect buffers in physical memory which are page-aligned. The size of each buffer should also be chosen appropriately.\n\n\nThe behavior of the digitizer is not specified when the buffer is made larger than 64 MB. On our computer, it seems like an \nApiWaitTimeout\n error is thrown when the buffer is too large (for some unspecified definition of \"large\" greater than 64 MB). The digitizer will then throw \nApiInsufficientResources\n errors whenever another acquisition is attempted, until the computer is restarted. Just restarting the Julia kernel, forcing a reload of the Alazar DLLs, does not appear to be enough to reset the digitizer fully.\n\n\nFor performance reasons, a buffer should not be made much smaller than 1 MB if mulitple buffers are required. There is also a minimum record size for each model of digitizer. For the ATS9360, if a record has fewer than 256 samples (could be 128 from channel A + 128 from channel B) then the acquisition will proceed, but return garbage data. Allocating too small of a buffer is therefore still bad, but less fatal than allocating one that is too large.\n\n\n\n\nHow to allocate appropriate buffers in Julia\n\n\nIn Julia, just allocating an array will not necessarily return a page-aligned block in memory. The Alazar.jl package provides two array types to help with this. These arrays are not required to be created by the user.\n\n\n\n\nAlazar.PageAlignedVector\n is just like \nBase.Vector\n except that the memory backing the array is guaranteed to be page-aligned.\n\n\nThe elements of an \nAlazar.DMABufferVector\n are pointers to different locations in memory which are page-aligned and can act as DMA buffers. The array is iterable and indexable as usual. The \nAlazar.DMABufferVector\n must itself be backed by a page-aligned array type, like \nAlazar.PageAlignedVector\n or \nBase.SharedVector\n (although support for \nBase.SharedVector\n is absent in InstrumentControl).", 
            "title": "Alazar digitizers"
        }, 
        {
            "location": "/digitizers/Alazar/#alazar-digitizers", 
            "text": "We put all Alazar digitizers in module  AlazarModule ; the feature set and API is so similar for the various models that just one module makes sense.  An  AlazarResponse  type is given for each measurement mode of the digitizer. (\"Traditional record mode\" has not been implemented yet for lack of immediate need.) Additionally, one can define custom  AlazarResponse  types so that some custom computations or data reductions can be performed during acquisition.  IQSoftwareResponse  is a good example of this.  In the following discussion, it is important to understand some Alazar terminology. Newer Alazar digitizers use direct memory access (DMA) to stream data into a computer's RAM. A single  acquisition  uses one or many  buffers , which constitute preallocated regions in the computer's physical memory. Each buffer contains one or many  records . Each  record  contains many  samples , which are the voltages measured by the digitizer. In streaming mode, there is only one record per buffer, but in other modes there can be many records per buffer.  Looking at the source code, it would seem that there is some redundancy in the types, for instance there is an  NPTRecordMode  and an  NPTRecordResponse  object. The former is used internally in the code to denote a particular method of configuring the instrument, mirroring the terminology used in the Alazar API documentation. The latter specifies what you actually want to do using that configuration of the instrument. Perhaps you want to measure in a given mode, but do some custom post-processing or processing during acquisition.  IQSoftwareResponse  is an example of this: it uses  NPTRecordMode  but reduces the data during measurement. Typically the user doesn't have to deal with the various mode objects, unless developing a new  AlazarResponse  type.", 
            "title": "Alazar digitizers"
        }, 
        {
            "location": "/digitizers/Alazar/#usage", 
            "text": "Here are the currently defined  AlazarResponse  types you can use:  #  InstrumentControl.AlazarModule.ContinuousStreamResponse     Type .  mutable struct ContinuousStreamResponse{S,T}  : StreamResponse{S,T}  Response type implementing the \"continuous streaming mode\" of the Alazar API.  Usage example:  ats = AlazarATS9870()\nsamples_per_ch = 1024\nres = ContinuousStreamResponse(ats, samples_per_ch)\nmeasure(res)  source  #  InstrumentControl.AlazarModule.TriggeredStreamResponse     Type .  mutable struct TriggeredStreamResponse{S,T}  : StreamResponse{S,T}  Response type implementing the \"triggered streaming mode\" of the Alazar API.  Usage example:  ats = AlazarATS9870()\nsamples_per_ch = 1024\nres = TriggeredStreamResponse(ats, samples_per_ch)\nmeasure(res)  source  #  InstrumentControl.AlazarModule.NPTRecordResponse     Type .  mutable struct NPTRecordResponse{S,T}  : RecordResponse{S,T}  Response type implementing the \"NPT record mode\" of the Alazar API.  Usage example:  ats = AlazarATS9870()\nsamples_per_rec_per_ch = 1024\ntotal_recs = 10\nres = NPTRecordResponse(ats, sam_per_rec_per_ch, total_recs)\nmeasure(res)  source  #  InstrumentControl.AlazarModule.FFTHardwareResponse     Type .  mutable struct FFTHardwareResponse{S,T,U}  : FFTResponse{S,T}  Response type implementing the FPGA-based \"FFT record mode\" of the Alazar API. Not all Alazar digitizers support this mode.  Usage example:  ats = AlazarATS9360()\nsamples_per_rec = 1024\nsam_per_fft = 512\ntotal_recs = 10\nres = FFTHardwareResponse(ats, sam_per_rec, sam_per_fft, total_recs, Alazar.S32Real)\nmeasure(res)  source  #  InstrumentControl.AlazarModule.IQSoftwareResponse     Type .  mutable struct IQSoftwareResponse{S,T}  : RecordResponse{S,T}  Response type for measuring with NPT record mode and mixing in software to find the phase and amplitude of a component at frequency  f . Slower than doing it in an FPGA, but ultimately necessary if we want to use both channels as inputs to the FFT.  Usage example:  ats = AlazarATS9870()\nsamples_per_rec_per_ch = 1024\ntotal_recs = 10\nf = 100e6\nres = IQSoftwareResponse(ats, samples_per_rec_per_ch, total_recs, f)\nmeasure(res)  source  These definitions referenced some abstract types, described here:  #  InstrumentControl.AlazarModule.AlazarResponse     Type .  abstract type AlazarResponse{S,T}  : Response  Abstract  Response  from an Alazar digitizer instrument. Subtypes should implement  return_type  to specify the output array type if they rely on the generic method  measure(::AlazarResponse) .  source  #  InstrumentControl.AlazarModule.StreamResponse     Type .  abstract type StreamResponse{S,T}  : AlazarResponse{S,T}  Abstract time-domain streaming  Response  from an Alazar digitizer instrument.  source  #  InstrumentControl.AlazarModule.RecordResponse     Type .  abstract type RecordResponse{S,T}  : AlazarResponse{S,T}  Abstract time-domain record  Response  from an Alazar digitizer instrument.  source", 
            "title": "Usage"
        }, 
        {
            "location": "/digitizers/Alazar/#technical-details", 
            "text": "", 
            "title": "Technical details"
        }, 
        {
            "location": "/digitizers/Alazar/#digitizer-requirements", 
            "text": "The Alazar digitizers expect buffers in physical memory which are page-aligned. The size of each buffer should also be chosen appropriately.  The behavior of the digitizer is not specified when the buffer is made larger than 64 MB. On our computer, it seems like an  ApiWaitTimeout  error is thrown when the buffer is too large (for some unspecified definition of \"large\" greater than 64 MB). The digitizer will then throw  ApiInsufficientResources  errors whenever another acquisition is attempted, until the computer is restarted. Just restarting the Julia kernel, forcing a reload of the Alazar DLLs, does not appear to be enough to reset the digitizer fully.  For performance reasons, a buffer should not be made much smaller than 1 MB if mulitple buffers are required. There is also a minimum record size for each model of digitizer. For the ATS9360, if a record has fewer than 256 samples (could be 128 from channel A + 128 from channel B) then the acquisition will proceed, but return garbage data. Allocating too small of a buffer is therefore still bad, but less fatal than allocating one that is too large.", 
            "title": "Digitizer requirements"
        }, 
        {
            "location": "/digitizers/Alazar/#how-to-allocate-appropriate-buffers-in-julia", 
            "text": "In Julia, just allocating an array will not necessarily return a page-aligned block in memory. The Alazar.jl package provides two array types to help with this. These arrays are not required to be created by the user.   Alazar.PageAlignedVector  is just like  Base.Vector  except that the memory backing the array is guaranteed to be page-aligned.  The elements of an  Alazar.DMABufferVector  are pointers to different locations in memory which are page-aligned and can act as DMA buffers. The array is iterable and indexable as usual. The  Alazar.DMABufferVector  must itself be backed by a page-aligned array type, like  Alazar.PageAlignedVector  or  Base.SharedVector  (although support for  Base.SharedVector  is absent in InstrumentControl).", 
            "title": "How to allocate appropriate buffers in Julia"
        }, 
        {
            "location": "/vna/vna/", 
            "text": "Most of the time you will probably want \nVNA.stimdata\n, \nVNA.data\n, and \nVNA.FrequencySweep\n.\n\n\n\n\nStimuli and responses\n\n\n#\n\n\nInstrumentControl.VNA.FrequencySweep\n \n \nType\n.\n\n\nmutable struct FrequencySweep \n: Response\n    ins::InstrumentVNA\n    reject::Int\nend\n\n\n\n\n\nYour standard frequency sweep using a VNA. \nreject\n lets you reject a number of traces to reject before keeping measurements.\n\n\nsource\n\n\n\n\nInstrument properties\n\n\n#\n\n\nInstrumentControl.VNA.Format\n \n \nType\n.\n\n\nFormat of returned data. Search for \nVNA.Format\n in the instrument template files to find valid options; some examples include \n:LogMagnitude\n, \n:GroupDelay\n, \n:PolarComplex\n, etc.\n\n\nsource\n\n\n#\n\n\nInstrumentControl.VNA.Graphs\n \n \nType\n.\n\n\nGraph layout on the VNA display. Specify with a matrix of integers.\n\n\nThe following example will have graph 1 occupying the top half of the screen, graph 2 occupying the lower-left, and graph 3 the lower-right:\n\n\nins[Graphs] = [1 1; 2 3]\n\n\n\n\n\nsource\n\n\n#\n\n\nInstrumentControl.VNA.Marker\n \n \nType\n.\n\n\nMarker state for a given marker (on/off).\n\n\nsource\n\n\n#\n\n\nInstrumentControl.VNA.MarkerX\n \n \nType\n.\n\n\nX-axis value for a given marker.\n\n\nsource\n\n\n#\n\n\nInstrumentControl.VNA.MarkerY\n \n \nType\n.\n\n\nY-axis value for a marker.\n\n\nsource\n\n\n#\n\n\nInstrumentControl.VNA.Parameter\n \n \nType\n.\n\n\nScattering parameter. For two-port VNAs, you can specify \n:S11\n, \n:S12\n, \n:S21\n, or \n:S22\n.\n\n\nExample:\n\n\nchannel, trace = 1, 2\nins[Parameter, channel, trace] = :S21\n\n\n\n\n\nsource\n\n\n#\n\n\nInstrumentControl.VNA.SearchTracking\n \n \nType\n.\n\n\nDo a marker search with each trace update (yes/no).\n\n\nsource\n\n\n\n\nMethods\n\n\n#\n\n\nInstrumentControl.VNA.clearavg\n \n \nFunction\n.\n\n\nclearavg(ins::InstrumentVNA, ch::Integer=1)\n\n\n\n\n\nRestart averaging for a given channel \nch\n (defaults to 1).\n\n\nsource\n\n\n#\n\n\nInstrumentControl.VNA.data\n \n \nFunction\n.\n\n\ndata(ins::InstrumentVNA, fmt::Symbol, ch::Integer=1, tr::Integer=1)\ndata(ins::InstrumentVNA, ch::Integer=1, tr::Integer=1)\n\n\n\n\n\nRead the trace data from the VNA. If you provide \nfmt\n (which should be a symbol suitable for setting the \nVNA.Format\n property) the data will be returned in that format.\n\n\nsource\n\n\n#\n\n\nBase.search\n \n \nMethod\n.\n\n\nsearch(ins::InstrumentVNA, m1::MarkerSearch, m2::MarkerSearch, m3::MarkerSearch...)\n\n\n\n\n\nExecute marker searches defined by any number of \nMarkerSearch\n objects.\n\n\nsource\n\n\n#\n\n\nInstrumentControl.VNA.shotgun\n \n \nFunction\n.\n\n\nshotgun(ins::InstrumentVNA, m::AbstractArray=1:9, ch::Integer=1, tr::Integer=1)\n\n\n\n\n\nMarkers with numbers in the range \nm\n are spread across the frequency span. The first marker begins at the start frequency but the last marker is positioned before the stop frequency, such that each marker has the same frequency span to the right of it within the stimulus window.\n\n\nsource\n\n\n#\n\n\nInstrumentControl.VNA.stimdata\n \n \nFunction\n.\n\n\nstimdata(ins::InstrumentVNA, ch::Integer=1)\n\n\n\n\n\nShort for \"stimulus data,\" reads the frequency axis from the VNA.\n\n\nsource\n\n\n#\n\n\nInstrumentControl.VNA.sweeptime\n \n \nFunction\n.\n\n\nsweeptime(ins::InstrumentVNA)\n\n\n\n\n\nReturns the sweep time for a given VNA, including averaging.\n\n\nsource\n\n\n\n\nMiscellaneous\n\n\n#\n\n\nInstrumentControl.VNA.MarkerSearch\n \n \nType\n.\n\n\nstruct MarkerSearch{T}\n    ch::Int\n    tr::Int\n    m::Int\n    val::Float64\n    pol::Polarity\nend\n\n\n\n\n\nType encapsulating a marker search query. The type parameter should be a symbol specifying the search type. The available options may depend on VNA capabilities.\n\n\nThe E5071C supports:\n\n\n:\nMax\n\n\n:\nMin\n\n\n:\nPeak\n\n\n:\nLeftPeak\n\n\n:\nRightPeak\n\n\n:\nTarget\n\n\n:\nLeftTarget\n\n\n:\nRightTarget\n\n\n\n\n\n\nsource\n\n\n#\n\n\nInstrumentControl.VNA.MarkerSearch\n \n \nMethod\n.\n\n\nMarkerSearch(typ::Symbol, ch, tr, m, val=0.0, pol::Polarity=Both())\n\n\n\n\n\nYou are recommended to construct a \nMarkerSearch\n object using this function, which makes a suitable one given the type of search you want to do (specified by \ntyp::Symbol\n), the channel \nch\n, trace \ntr\n, marker number \nm\n, value \nval\n and polarity \npol::Polarity\n (\nPositive()\n, \nNegative()\n, or \nBoth()\n). The value will depend on what you're doing but is typically a peak excursion or transition threshold.\n\n\nsource", 
            "title": "VNAs"
        }, 
        {
            "location": "/vna/vna/#stimuli-and-responses", 
            "text": "#  InstrumentControl.VNA.FrequencySweep     Type .  mutable struct FrequencySweep  : Response\n    ins::InstrumentVNA\n    reject::Int\nend  Your standard frequency sweep using a VNA.  reject  lets you reject a number of traces to reject before keeping measurements.  source", 
            "title": "Stimuli and responses"
        }, 
        {
            "location": "/vna/vna/#instrument-properties", 
            "text": "#  InstrumentControl.VNA.Format     Type .  Format of returned data. Search for  VNA.Format  in the instrument template files to find valid options; some examples include  :LogMagnitude ,  :GroupDelay ,  :PolarComplex , etc.  source  #  InstrumentControl.VNA.Graphs     Type .  Graph layout on the VNA display. Specify with a matrix of integers.  The following example will have graph 1 occupying the top half of the screen, graph 2 occupying the lower-left, and graph 3 the lower-right:  ins[Graphs] = [1 1; 2 3]  source  #  InstrumentControl.VNA.Marker     Type .  Marker state for a given marker (on/off).  source  #  InstrumentControl.VNA.MarkerX     Type .  X-axis value for a given marker.  source  #  InstrumentControl.VNA.MarkerY     Type .  Y-axis value for a marker.  source  #  InstrumentControl.VNA.Parameter     Type .  Scattering parameter. For two-port VNAs, you can specify  :S11 ,  :S12 ,  :S21 , or  :S22 .  Example:  channel, trace = 1, 2\nins[Parameter, channel, trace] = :S21  source  #  InstrumentControl.VNA.SearchTracking     Type .  Do a marker search with each trace update (yes/no).  source", 
            "title": "Instrument properties"
        }, 
        {
            "location": "/vna/vna/#methods", 
            "text": "#  InstrumentControl.VNA.clearavg     Function .  clearavg(ins::InstrumentVNA, ch::Integer=1)  Restart averaging for a given channel  ch  (defaults to 1).  source  #  InstrumentControl.VNA.data     Function .  data(ins::InstrumentVNA, fmt::Symbol, ch::Integer=1, tr::Integer=1)\ndata(ins::InstrumentVNA, ch::Integer=1, tr::Integer=1)  Read the trace data from the VNA. If you provide  fmt  (which should be a symbol suitable for setting the  VNA.Format  property) the data will be returned in that format.  source  #  Base.search     Method .  search(ins::InstrumentVNA, m1::MarkerSearch, m2::MarkerSearch, m3::MarkerSearch...)  Execute marker searches defined by any number of  MarkerSearch  objects.  source  #  InstrumentControl.VNA.shotgun     Function .  shotgun(ins::InstrumentVNA, m::AbstractArray=1:9, ch::Integer=1, tr::Integer=1)  Markers with numbers in the range  m  are spread across the frequency span. The first marker begins at the start frequency but the last marker is positioned before the stop frequency, such that each marker has the same frequency span to the right of it within the stimulus window.  source  #  InstrumentControl.VNA.stimdata     Function .  stimdata(ins::InstrumentVNA, ch::Integer=1)  Short for \"stimulus data,\" reads the frequency axis from the VNA.  source  #  InstrumentControl.VNA.sweeptime     Function .  sweeptime(ins::InstrumentVNA)  Returns the sweep time for a given VNA, including averaging.  source", 
            "title": "Methods"
        }, 
        {
            "location": "/vna/vna/#miscellaneous", 
            "text": "#  InstrumentControl.VNA.MarkerSearch     Type .  struct MarkerSearch{T}\n    ch::Int\n    tr::Int\n    m::Int\n    val::Float64\n    pol::Polarity\nend  Type encapsulating a marker search query. The type parameter should be a symbol specifying the search type. The available options may depend on VNA capabilities.  The E5071C supports:  : Max  : Min  : Peak  : LeftPeak  : RightPeak  : Target  : LeftTarget  : RightTarget   source  #  InstrumentControl.VNA.MarkerSearch     Method .  MarkerSearch(typ::Symbol, ch, tr, m, val=0.0, pol::Polarity=Both())  You are recommended to construct a  MarkerSearch  object using this function, which makes a suitable one given the type of search you want to do (specified by  typ::Symbol ), the channel  ch , trace  tr , marker number  m , value  val  and polarity  pol::Polarity  ( Positive() ,  Negative() , or  Both() ). The value will depend on what you're doing but is typically a peak excursion or transition threshold.  source", 
            "title": "Miscellaneous"
        }, 
        {
            "location": "/vna/e5071c/", 
            "text": "Instrument properties\n\n\nWe support the following instrument properties for the E5071C:\n\n\nusing\n \nInstrumentControl\n\n\nmethods\n(\ngetindex\n,\n \n(\nInstrumentControl\n.\nE5071C\n.\nInsE5071C\n,\n \nVararg\n{\nAny\n}))\n\n\n\n\n\n\n# 101 methods for generic function \ngetindex\n:\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.AutoSweepTime}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.AutoSweepTime}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.SweepTime}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.SweepTime}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.ElectricalMedium}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.ElectricalMedium}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.ElectricalMedium}, ch::Integer, tr::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.VNA.Format}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.VNA.Format}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.VNA.Format}, ch::Integer, tr::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.VNA.Parameter}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.VNA.Parameter}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.VNA.Parameter}, ch::Integer, tr::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.TriggerOutputPolarity}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.TriggerOutputTiming}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.Averaging}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.Averaging}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.AveragingFactor}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.AveragingFactor}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.AveragingTrigger}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.ElectricalDelay}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.ElectricalDelay}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.ElectricalDelay}, ch::Integer, tr::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.ExtTriggerDelay}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.ExtTriggerLowLatency}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.FrequencyStart}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.FrequencyStart}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.FrequencyStop}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.FrequencyStop}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.FrequencyCenter}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.FrequencyCenter}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.FrequencySpan}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.FrequencySpan}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.IFBandwidth}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.IFBandwidth}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.NumTraces}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.NumTraces}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.NumPoints}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.NumPoints}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.Output}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.PhaseOffset}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.PhaseOffset}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.PhaseOffset}, ch::Integer, tr::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.PointTrigger}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.PowerCoupled}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.PowerCoupled}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.PowerLevel}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.PowerLevel}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.PowerPortLevel}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.PowerPortLevel}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.PowerPortLevel}, ch::Integer, port::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.PowerSlope}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.PowerSlope}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.PowerSlopeLevel}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.PowerSlopeLevel}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.PowerSweepFrequency}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.PowerSweepFrequency}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.TraceDisplay}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.TraceDisplay}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.TraceDisplay}, ch::Integer, tr::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.Smoothing}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.Smoothing}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.Smoothing}, ch::Integer, tr::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.SmoothingAperture}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.SmoothingAperture}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.SmoothingAperture}, ch::Integer, tr::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.TraceMaximized}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.TraceMaximized}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.WaveguideCutoff}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.WaveguideCutoff}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.WaveguideCutoff}, ch::Integer, tr::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.YDivisions}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.YDivisions}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.YScalePerDivision}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.YScalePerDivision}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.YScalePerDivision}, ch::Integer, tr::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.YReferenceLevel}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.YReferenceLevel}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.YReferenceLevel}, ch::Integer, tr::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.YReferencePosition}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.YReferencePosition}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.YReferencePosition}, ch::Integer, tr::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.TransferByteOrder}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.TransferFormat}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.TriggerSlope}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.TriggerSource}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.TriggerOutput}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.VNA.Marker}, m::Integer) in InstrumentControl.E5071C at /home/travis/.julia/v0.6/InstrumentControl/src/instruments/VNAs/E5071C.jl:67\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.VNA.Marker}, m::Integer, ch::Integer) in InstrumentControl.E5071C at /home/travis/.julia/v0.6/InstrumentControl/src/instruments/VNAs/E5071C.jl:67\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.VNA.Marker}, m::Integer, ch::Integer, tr::Integer) in InstrumentControl.E5071C at /home/travis/.julia/v0.6/InstrumentControl/src/instruments/VNAs/E5071C.jl:67\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.VNA.MarkerX}, m::Integer) in InstrumentControl.E5071C at /home/travis/.julia/v0.6/InstrumentControl/src/instruments/VNAs/E5071C.jl:72\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.VNA.MarkerX}, m::Integer, ch::Integer) in InstrumentControl.E5071C at /home/travis/.julia/v0.6/InstrumentControl/src/instruments/VNAs/E5071C.jl:72\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.VNA.MarkerX}, m::Integer, ch::Integer, tr::Integer) in InstrumentControl.E5071C at /home/travis/.julia/v0.6/InstrumentControl/src/instruments/VNAs/E5071C.jl:72\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.VNA.MarkerY}, m::Integer) in InstrumentControl.E5071C at /home/travis/.julia/v0.6/InstrumentControl/src/instruments/VNAs/E5071C.jl:77\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.VNA.MarkerY}, m::Integer, ch::Integer) in InstrumentControl.E5071C at /home/travis/.julia/v0.6/InstrumentControl/src/instruments/VNAs/E5071C.jl:77\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.VNA.MarkerY}, m::Integer, ch::Integer, tr::Integer) in InstrumentControl.E5071C at /home/travis/.julia/v0.6/InstrumentControl/src/instruments/VNAs/E5071C.jl:77\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.VNA.SearchTracking}, m::Integer) in InstrumentControl.E5071C at /home/travis/.julia/v0.6/InstrumentControl/src/instruments/VNAs/E5071C.jl:83\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.VNA.SearchTracking}, m::Integer, ch::Integer) in InstrumentControl.E5071C at /home/travis/.julia/v0.6/InstrumentControl/src/instruments/VNAs/E5071C.jl:83\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.VNA.SearchTracking}, m::Integer, ch::Integer, tr::Integer) in InstrumentControl.E5071C at /home/travis/.julia/v0.6/InstrumentControl/src/instruments/VNAs/E5071C.jl:83\ngetindex(ins::ICCommon.Instrument, ::Type{InstrumentControl.Timeout}) in InstrumentControl at /home/travis/.julia/v0.6/InstrumentControl/src/VISA.jl:192\ngetindex(ins::ICCommon.Instrument, ::Type{InstrumentControl.WriteTermCharEnable}) in InstrumentControl at /home/travis/.julia/v0.6/InstrumentControl/src/VISA.jl:200\n\n\n\n\n\n\n\nMethods\n\n\n#\n\n\nInstrumentControl.E5071C.screen\n \n \nFunction\n.\n\n\nscreen(ins::InsE5071C, filename::AbstractString=\nscreen.png\n, display::Bool=true)\n\n\n\n\n\nTake and retrieve a local copy of a screenshot. Display the screenshot if \ndisplay\n is true.\n\n\nWhatever is at \nfilename\n on the computer calling this method will be overwritten with the screenshot. The screenshot is also saved on the instrument.\n\n\nsource", 
            "title": "E5071C"
        }, 
        {
            "location": "/vna/e5071c/#instrument-properties", 
            "text": "We support the following instrument properties for the E5071C:  using   InstrumentControl  methods ( getindex ,   ( InstrumentControl . E5071C . InsE5071C ,   Vararg { Any }))   # 101 methods for generic function  getindex :\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.AutoSweepTime}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.AutoSweepTime}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.SweepTime}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.SweepTime}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.ElectricalMedium}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.ElectricalMedium}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.ElectricalMedium}, ch::Integer, tr::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.VNA.Format}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.VNA.Format}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.VNA.Format}, ch::Integer, tr::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.VNA.Parameter}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.VNA.Parameter}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.VNA.Parameter}, ch::Integer, tr::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.TriggerOutputPolarity}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.TriggerOutputTiming}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.Averaging}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.Averaging}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.AveragingFactor}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.AveragingFactor}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.AveragingTrigger}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.ElectricalDelay}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.ElectricalDelay}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.ElectricalDelay}, ch::Integer, tr::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.ExtTriggerDelay}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.ExtTriggerLowLatency}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.FrequencyStart}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.FrequencyStart}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.FrequencyStop}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.FrequencyStop}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.FrequencyCenter}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.FrequencyCenter}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.FrequencySpan}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.FrequencySpan}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.IFBandwidth}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.IFBandwidth}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.NumTraces}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.NumTraces}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.NumPoints}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.NumPoints}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.Output}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.PhaseOffset}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.PhaseOffset}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.PhaseOffset}, ch::Integer, tr::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.PointTrigger}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.PowerCoupled}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.PowerCoupled}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.PowerLevel}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.PowerLevel}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.PowerPortLevel}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.PowerPortLevel}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.PowerPortLevel}, ch::Integer, port::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.PowerSlope}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.PowerSlope}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.PowerSlopeLevel}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.PowerSlopeLevel}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.PowerSweepFrequency}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.PowerSweepFrequency}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.TraceDisplay}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.TraceDisplay}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.TraceDisplay}, ch::Integer, tr::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.Smoothing}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.Smoothing}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.Smoothing}, ch::Integer, tr::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.SmoothingAperture}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.SmoothingAperture}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.SmoothingAperture}, ch::Integer, tr::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.TraceMaximized}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.TraceMaximized}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.WaveguideCutoff}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.WaveguideCutoff}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.WaveguideCutoff}, ch::Integer, tr::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.YDivisions}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.YDivisions}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.YScalePerDivision}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.YScalePerDivision}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.YScalePerDivision}, ch::Integer, tr::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.YReferenceLevel}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.YReferenceLevel}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.YReferenceLevel}, ch::Integer, tr::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.YReferencePosition}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.YReferencePosition}, ch::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.YReferencePosition}, ch::Integer, tr::Integer) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.TransferByteOrder}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.TransferFormat}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.TriggerSlope}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.TriggerSource}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.TriggerOutput}) in InstrumentControl.E5071C\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.VNA.Marker}, m::Integer) in InstrumentControl.E5071C at /home/travis/.julia/v0.6/InstrumentControl/src/instruments/VNAs/E5071C.jl:67\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.VNA.Marker}, m::Integer, ch::Integer) in InstrumentControl.E5071C at /home/travis/.julia/v0.6/InstrumentControl/src/instruments/VNAs/E5071C.jl:67\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.VNA.Marker}, m::Integer, ch::Integer, tr::Integer) in InstrumentControl.E5071C at /home/travis/.julia/v0.6/InstrumentControl/src/instruments/VNAs/E5071C.jl:67\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.VNA.MarkerX}, m::Integer) in InstrumentControl.E5071C at /home/travis/.julia/v0.6/InstrumentControl/src/instruments/VNAs/E5071C.jl:72\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.VNA.MarkerX}, m::Integer, ch::Integer) in InstrumentControl.E5071C at /home/travis/.julia/v0.6/InstrumentControl/src/instruments/VNAs/E5071C.jl:72\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.VNA.MarkerX}, m::Integer, ch::Integer, tr::Integer) in InstrumentControl.E5071C at /home/travis/.julia/v0.6/InstrumentControl/src/instruments/VNAs/E5071C.jl:72\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.VNA.MarkerY}, m::Integer) in InstrumentControl.E5071C at /home/travis/.julia/v0.6/InstrumentControl/src/instruments/VNAs/E5071C.jl:77\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.VNA.MarkerY}, m::Integer, ch::Integer) in InstrumentControl.E5071C at /home/travis/.julia/v0.6/InstrumentControl/src/instruments/VNAs/E5071C.jl:77\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.VNA.MarkerY}, m::Integer, ch::Integer, tr::Integer) in InstrumentControl.E5071C at /home/travis/.julia/v0.6/InstrumentControl/src/instruments/VNAs/E5071C.jl:77\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.VNA.SearchTracking}, m::Integer) in InstrumentControl.E5071C at /home/travis/.julia/v0.6/InstrumentControl/src/instruments/VNAs/E5071C.jl:83\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.VNA.SearchTracking}, m::Integer, ch::Integer) in InstrumentControl.E5071C at /home/travis/.julia/v0.6/InstrumentControl/src/instruments/VNAs/E5071C.jl:83\ngetindex(ins::InstrumentControl.E5071C.InsE5071C, ::Type{InstrumentControl.VNA.SearchTracking}, m::Integer, ch::Integer, tr::Integer) in InstrumentControl.E5071C at /home/travis/.julia/v0.6/InstrumentControl/src/instruments/VNAs/E5071C.jl:83\ngetindex(ins::ICCommon.Instrument, ::Type{InstrumentControl.Timeout}) in InstrumentControl at /home/travis/.julia/v0.6/InstrumentControl/src/VISA.jl:192\ngetindex(ins::ICCommon.Instrument, ::Type{InstrumentControl.WriteTermCharEnable}) in InstrumentControl at /home/travis/.julia/v0.6/InstrumentControl/src/VISA.jl:200", 
            "title": "Instrument properties"
        }, 
        {
            "location": "/vna/e5071c/#methods", 
            "text": "#  InstrumentControl.E5071C.screen     Function .  screen(ins::InsE5071C, filename::AbstractString= screen.png , display::Bool=true)  Take and retrieve a local copy of a screenshot. Display the screenshot if  display  is true.  Whatever is at  filename  on the computer calling this method will be overwritten with the screenshot. The screenshot is also saved on the instrument.  source", 
            "title": "Methods"
        }, 
        {
            "location": "/docbuild/", 
            "text": "Continuous integration testing\n\n\nTests are run on this package whenever an update is merged into the master branch. Two environment variables are required to be set on the testing server for tests to pass (they can be set to anything). These are \nICTESTMODE\n and \nVISA_JL_NO_LOAD\n. The former tells InstrumentControl.jl not to open a VISA resource manager as well as to skip loading the \nconfig.json\n file. The latter tells VISA.jl not to look for and load a VISA library. Together, these environment variables enable some basic testing and automatic docs building for InstrumentControl.jl.\n\n\n\n\nDocumentation build process\n\n\nDocumenter.jl\n is used to build these docs automatically whenever tests complete successfully.", 
            "title": "Documentation and testing"
        }, 
        {
            "location": "/docbuild/#continuous-integration-testing", 
            "text": "Tests are run on this package whenever an update is merged into the master branch. Two environment variables are required to be set on the testing server for tests to pass (they can be set to anything). These are  ICTESTMODE  and  VISA_JL_NO_LOAD . The former tells InstrumentControl.jl not to open a VISA resource manager as well as to skip loading the  config.json  file. The latter tells VISA.jl not to look for and load a VISA library. Together, these environment variables enable some basic testing and automatic docs building for InstrumentControl.jl.", 
            "title": "Continuous integration testing"
        }, 
        {
            "location": "/docbuild/#documentation-build-process", 
            "text": "Documenter.jl  is used to build these docs automatically whenever tests complete successfully.", 
            "title": "Documentation build process"
        }, 
        {
            "location": "/releases/", 
            "text": "Releases\n\n\nv0.0.1      Currently under development", 
            "title": "Release notes"
        }, 
        {
            "location": "/releases/#releases", 
            "text": "v0.0.1      Currently under development", 
            "title": "Releases"
        }, 
        {
            "location": "/LICENSE/", 
            "text": "License\n\n\nMost code:\n\n\n\n\nCopyright (c) 2015: Andrew Keller.\n\n\n\n\nRandom.jl, Time.jl, and a few other snippets here and there:\n\n\n\n\nCopyright (c) 2014: Menyoung Lee.\n\n\n\n\nLarge majority of code in VISA.jl package:\n\n\n\n\nCopyright (c) 2014: Colm Ryan.\n\n\n\n\nAll of the code is licensed under the MIT \"Expat\" License by the respective copyright holders:\n\n\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.", 
            "title": "License"
        }, 
        {
            "location": "/LICENSE/#license", 
            "text": "Most code:   Copyright (c) 2015: Andrew Keller.   Random.jl, Time.jl, and a few other snippets here and there:   Copyright (c) 2014: Menyoung Lee.   Large majority of code in VISA.jl package:   Copyright (c) 2014: Colm Ryan.   All of the code is licensed under the MIT \"Expat\" License by the respective copyright holders:   Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.", 
            "title": "License"
        }
    ]
}