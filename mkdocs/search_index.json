{
    "docs": [
        {
            "location": "/", 
            "text": "PainterQB.jl\n\n\nA \nJulia\n package for qubit measurement and analysis.\n\n\nWork in development, not ready for implementation. The documentation may assume some familiarity\nwith Julia.\n\n\nInstallation\n\n\n\n\nInstall \nNational Instruments VISA libraries\n\n (tested with v15.0.1 on Windows 10)\n\n\nInstall \nAlazarTech\n digitizer drivers and shared libraries\n (may need to contact AlazarTech)\n\n\nInstall \nVISA.jl\n\n\nInstall \nAlazar.jl\n\n\nInstall \nPainterQB.jl\n\n\n\n\nQuick start\n\n\nusing PainterQB\nusing PainterQB.AlazarModule\nusing PainterQB.AWG5014CModule  # etc.\n\nawg = AWG5014C(tcpip_socket(\n1.2.3.4\n,5000))\nats = AlazarATS9360()\n\n# do something with awg and ats\n\n\n\n\nBuilding this documentation\n\n\nIn a fresh instance of Julia:\n\n\ninclude(joinpath(Pkg.dir(\nPainterQB\n),\ndocs/build.jl\n))\n\n\n\n\nTo process with mkdocs, run the following in the PainterQB pkg. directory:\n\n\nmkdocs build --clean\n\n\n\n\nTo serve locally or publish to GitHub, run either of the following in the PainterQB pkg. directory:\n\n\nmkdocs serve\nmkdocs gh-deploy --clean", 
            "title": "Home"
        }, 
        {
            "location": "/#painterqbjl", 
            "text": "A  Julia  package for qubit measurement and analysis.  Work in development, not ready for implementation. The documentation may assume some familiarity\nwith Julia.", 
            "title": "PainterQB.jl"
        }, 
        {
            "location": "/#installation", 
            "text": "Install  National Instruments VISA libraries \n (tested with v15.0.1 on Windows 10)  Install  AlazarTech  digitizer drivers and shared libraries\n (may need to contact AlazarTech)  Install  VISA.jl  Install  Alazar.jl  Install  PainterQB.jl", 
            "title": "Installation"
        }, 
        {
            "location": "/#quick-start", 
            "text": "using PainterQB\nusing PainterQB.AlazarModule\nusing PainterQB.AWG5014CModule  # etc.\n\nawg = AWG5014C(tcpip_socket( 1.2.3.4 ,5000))\nats = AlazarATS9360()\n\n# do something with awg and ats", 
            "title": "Quick start"
        }, 
        {
            "location": "/#building-this-documentation", 
            "text": "In a fresh instance of Julia:  include(joinpath(Pkg.dir( PainterQB ), docs/build.jl ))  To process with mkdocs, run the following in the PainterQB pkg. directory:  mkdocs build --clean  To serve locally or publish to GitHub, run either of the following in the PainterQB pkg. directory:  mkdocs serve\nmkdocs gh-deploy --clean", 
            "title": "Building this documentation"
        }, 
        {
            "location": "/design/", 
            "text": "Design overview\n\n\nWhat should good measurement code do?\n\n\nAnyone who has written code in MATLAB or something comparable (IGOR Pro, in the\nauthor's case) has undoubtedly seen spaghetti code. Often there are many copies\nof a measurement routine that differ only slightly, perhaps in the functionality\nof what happens inside some for loop, etc.\n\n\nWe would like to have clear, reusable code to avoid redundancy and accidental\nerrors, both of which consume precious time on the part of the experimenters.\nConsider an archetypal measurement scheme wherein we measure a device's response to\nvarious stimuli (perhaps we measure current as a function of applied bias).\nWe should be able to write just one sweep function to do this:\n\n\nfunction sweep(ch0::Stimulus, ch1::Response, x_itr, tstep)\n    map(x_itr) do x\n        source(ch0, x)\n        sleep(tstep)\n        measure(ch1)\n    end\nend\n\n\n\n\nThe idea of \nmultiple dispatch\n, natively supported in Julia, permits writing such\nconvenient and abstract code. This is just one example where the advantages of\nmultiple dispatch are obvious. We hope it will more broadly simplify the extension of\nmeasurement code while ensuring continued reliability.\n\n\nHow do we take measurements?\n\n\nSource and measure\n\n\nTwo functions are provided to abstract away many kinds of measurements: \nsource\n\nand \nmeasure\n. In an experiment you source some stimulus and measure a response.\nTherefore \nsource\n takes as an argument an object matching type signature\n\nStimulus\n, which can have different fields for different types of stimuli, as\nwell as some value. \nmeasure\n takes as an argument an object matching type\nsignature \nResponse\n. The idea is to write new subtypes of \nStimulus\n and \nResponse\n\nto describe what you are doing, as well as new methods for \nsource\n and \nmeasure\n.\n\n\nStimuli\n\n\nAll stimuli are objects, subtyped from the abstract \nStimulus\n type.\nMany stimuli, associated with the capabilities of particular instruments,\nare already implemented.\n\n\nNot all stimuli are associated with a physical instrument. For instance, sourcing a\n\nDelayStimulus\n will cause the script to block until a specified time after\ncreation of the \nDelayStimulus\n object.\n\n\nStimuli could also be associated with several instruments. Maybe a stimulus that\nmakes sense for a particular experiment would be to change all gate voltages at once.\nThese gate voltages could of course be sourced by several physical instruments.\n\n\nResponses\n\n\nAll responses are objects, subtyped from the abstract parametric \nResponse{T}\n type.\nWe use a parametric type for responses so that the return type of the numerical data\nis clear. Usually a response is associated with a particular instrument.\n\n\nHowever, responses need not come from instruments. For test purposes, suppose we want to\nmimic a measurement by generating random numbers. \nRandomResponse\n produces a\nrandom number in the unit interval when it is measured. A \nTimerResponse\n will\nmeasure the time since creation of the \nTimerResponse\n object.\n\n\nWhat is an instrument?\n\n\nFor the purposes of this package, an instrument is just something connected to the\ncomputer that we need to communicate with, and which can source or measure something.\nEvery instrument may connect to the computer by different hardware,\ncomms protocols, and command dialects.\n\n\nAll instruments are Julia objects, subtypes of the abstract type \nInstrument\n.\n\n\nInstrument types\n\n\nMany instruments share the same communications protocols. We subtype \nInstrument\n\nbased on these protocols.\n\n\nVISA\n\n\nMany instruments are able to be addressed using the\n\nVISA\n standard (Virtual\nInstrument Software Architecture), currently maintained by the IVI Foundation.\n\nInstrumentVISA\n is an abstract subtype of \nInstrument\n.\n\n\nTo talk to VISA instruments will require the Julia package \nVISA.jl\n\nas well as the \nNational Instruments VISA libraries\n.\nInstallation instructions are available at each link.\n\n\nAlazar digitizers\n\n\nDigitizers made by \nAlazarTech\n are notably \nnot\n\ncompatible with the VISA standard. All Alazar digitizers are addressable by an API\nsupplied by the company, which talks to the card through a shared library (a .dll on\nWindows or .so on Linux). \nInstrumentAlazar\n is an abstract subtype of \nInstrument\n.\n\n\nThe shared library files and API documentation are only available from AlazarTech.\n\n\nHow do we configure instruments?\n\n\nProperties\n\n\nInstrument properties are configured and inspected using two functions,\n\nconfigure\n and \ninspect\n. Why not \nset\n and \nget\n? Ultimately these verbs are\npretty generic and often have implicit meanings in other programming languages.\nIn Objective C, for instance, \nget\n implies that the function will return an address\nin memory rather than a value.\n\n\nBoth \nconfigure\n and \ninspect\n have a lot of methods that take as one of their\narguments an \nInstrumentProperty\n subtype. One subtypes \nInstrumentProperty\n for\nproperties such as \nClockSource\n, the\nlogical states of which have no obvious consistent encoding. One should instead\nsubtype \nNumericalProperty\n for properties where a number suffices to describe\nthe property (up to units).\n\n\nProperties which may be shared by multiple instruments should be defined in\n\nsrc/InstrumentDefs.jl\n. Examples include \nFrequency\n, \nPower\n, \nSampleRate\n, etc.\nThey may be imported in each instrument's module as needed. Properties specific\nto a given instrument may of course be defined in that instrument's module.\n\n\nA design choice was for \nconfigure\n and \ninspect\n to take types rather than\nobjects. Two examples:\n\n\nconfigure(awg, RisingTrigger)    # not RisingTrigger()\nconfigure(awg, SampleRate, 10e6) # not SampleRate() or SampleRate(10e6)\n\n\n\n\nDifference between stimuli and instrument properties\n\n\nBecause a stimulus is defined so broadly, the difference between a stimulus\nand an instrument property is not obvious. A stimulus is like a generalized\ninstrument property: sourcing a stimulus may entail configuring zero or more\ninstrument properties.\n\n\nIt is useful to think of a stimulus to be something that what you are measuring\nhas a chance to react to. For example, this could be applied voltage, sourced by\none or more instruments. The applied voltages would be seen by the device under test,\nwhich would respond accordingly. The stimulus could also just be a time delay,\nprovided by the measurement computer. It could even be the number of threads used\nby Julia for real-time processing.\n\n\nAn instrument property is any persistent setting of an instrument. Tweaking an\ninstrument property could affect the device under test, but it might not.\nAveraging is a good example. With averaging a measurement may look less noisy,\nbut your device under test doesn't know the difference. The trigger engine of a\ndigitizer would also have associated instrument properties.\n\n\nIn many cases there is an overlap between stimuli and properties. Consider that\nthe frequency of a signal generator is an instrument property. In this case\nsourcing a frequency stimulus results in configuring an instrument property.\nRather than make a \nFrequencyStimulus\n type, we provide a \nPropertyStimulus\n type\nwhich can be used more generically. Consider the following example, where we make a\n\nPropertyStimulus\n for sweeping the frequency of our E8257D signal generator:\n\n\nstim = PropertyStimulus(siggen::E8257D, Frequency)\nfor freq in 1e9:1e8:5e9     # 1 GHz to 5 GHz in steps of 100 MHz\n    source(stim, freq)\n    # measure(something)\nend\n\n\n\n\nNote that \nFrequency\n is a subtype of \nNumericalProperty\n, which is required for\nmaking a \nPropertyStimulus\n.\n\n\nAgain, stimuli need not be tied to a particular property. Rather, this is just one\nconvenient and easily generalized example. In more complicated instances it is\nprobably better to make a new \nStimulus\n subtype rather than use \nPropertyStimulus\n.\n\n\nFuture directions\n\n\nFeedback loops\n\n\nIn principle, asynchronous software feedback loops could be implemented\nwith the \nReactive.jl\n package. This\nwould probably only be suitable for slowly varying signals, e.g. PID temperature\ncontrol. Ultimately benchmarking needs to be done to determine how useful\nthis approach would be.", 
            "title": "Design"
        }, 
        {
            "location": "/design/#design-overview", 
            "text": "", 
            "title": "Design overview"
        }, 
        {
            "location": "/design/#what-should-good-measurement-code-do", 
            "text": "Anyone who has written code in MATLAB or something comparable (IGOR Pro, in the\nauthor's case) has undoubtedly seen spaghetti code. Often there are many copies\nof a measurement routine that differ only slightly, perhaps in the functionality\nof what happens inside some for loop, etc.  We would like to have clear, reusable code to avoid redundancy and accidental\nerrors, both of which consume precious time on the part of the experimenters.\nConsider an archetypal measurement scheme wherein we measure a device's response to\nvarious stimuli (perhaps we measure current as a function of applied bias).\nWe should be able to write just one sweep function to do this:  function sweep(ch0::Stimulus, ch1::Response, x_itr, tstep)\n    map(x_itr) do x\n        source(ch0, x)\n        sleep(tstep)\n        measure(ch1)\n    end\nend  The idea of  multiple dispatch , natively supported in Julia, permits writing such\nconvenient and abstract code. This is just one example where the advantages of\nmultiple dispatch are obvious. We hope it will more broadly simplify the extension of\nmeasurement code while ensuring continued reliability.", 
            "title": "What should good measurement code do?"
        }, 
        {
            "location": "/design/#how-do-we-take-measurements", 
            "text": "Source and measure  Two functions are provided to abstract away many kinds of measurements:  source \nand  measure . In an experiment you source some stimulus and measure a response.\nTherefore  source  takes as an argument an object matching type signature Stimulus , which can have different fields for different types of stimuli, as\nwell as some value.  measure  takes as an argument an object matching type\nsignature  Response . The idea is to write new subtypes of  Stimulus  and  Response \nto describe what you are doing, as well as new methods for  source  and  measure .  Stimuli  All stimuli are objects, subtyped from the abstract  Stimulus  type.\nMany stimuli, associated with the capabilities of particular instruments,\nare already implemented.  Not all stimuli are associated with a physical instrument. For instance, sourcing a DelayStimulus  will cause the script to block until a specified time after\ncreation of the  DelayStimulus  object.  Stimuli could also be associated with several instruments. Maybe a stimulus that\nmakes sense for a particular experiment would be to change all gate voltages at once.\nThese gate voltages could of course be sourced by several physical instruments.  Responses  All responses are objects, subtyped from the abstract parametric  Response{T}  type.\nWe use a parametric type for responses so that the return type of the numerical data\nis clear. Usually a response is associated with a particular instrument.  However, responses need not come from instruments. For test purposes, suppose we want to\nmimic a measurement by generating random numbers.  RandomResponse  produces a\nrandom number in the unit interval when it is measured. A  TimerResponse  will\nmeasure the time since creation of the  TimerResponse  object.", 
            "title": "How do we take measurements?"
        }, 
        {
            "location": "/design/#what-is-an-instrument", 
            "text": "For the purposes of this package, an instrument is just something connected to the\ncomputer that we need to communicate with, and which can source or measure something.\nEvery instrument may connect to the computer by different hardware,\ncomms protocols, and command dialects.  All instruments are Julia objects, subtypes of the abstract type  Instrument .  Instrument types  Many instruments share the same communications protocols. We subtype  Instrument \nbased on these protocols.  VISA  Many instruments are able to be addressed using the VISA  standard (Virtual\nInstrument Software Architecture), currently maintained by the IVI Foundation. InstrumentVISA  is an abstract subtype of  Instrument .  To talk to VISA instruments will require the Julia package  VISA.jl \nas well as the  National Instruments VISA libraries .\nInstallation instructions are available at each link.  Alazar digitizers  Digitizers made by  AlazarTech  are notably  not \ncompatible with the VISA standard. All Alazar digitizers are addressable by an API\nsupplied by the company, which talks to the card through a shared library (a .dll on\nWindows or .so on Linux).  InstrumentAlazar  is an abstract subtype of  Instrument .  The shared library files and API documentation are only available from AlazarTech.", 
            "title": "What is an instrument?"
        }, 
        {
            "location": "/design/#how-do-we-configure-instruments", 
            "text": "Properties  Instrument properties are configured and inspected using two functions, configure  and  inspect . Why not  set  and  get ? Ultimately these verbs are\npretty generic and often have implicit meanings in other programming languages.\nIn Objective C, for instance,  get  implies that the function will return an address\nin memory rather than a value.  Both  configure  and  inspect  have a lot of methods that take as one of their\narguments an  InstrumentProperty  subtype. One subtypes  InstrumentProperty  for\nproperties such as  ClockSource , the\nlogical states of which have no obvious consistent encoding. One should instead\nsubtype  NumericalProperty  for properties where a number suffices to describe\nthe property (up to units).  Properties which may be shared by multiple instruments should be defined in src/InstrumentDefs.jl . Examples include  Frequency ,  Power ,  SampleRate , etc.\nThey may be imported in each instrument's module as needed. Properties specific\nto a given instrument may of course be defined in that instrument's module.  A design choice was for  configure  and  inspect  to take types rather than\nobjects. Two examples:  configure(awg, RisingTrigger)    # not RisingTrigger()\nconfigure(awg, SampleRate, 10e6) # not SampleRate() or SampleRate(10e6)  Difference between stimuli and instrument properties  Because a stimulus is defined so broadly, the difference between a stimulus\nand an instrument property is not obvious. A stimulus is like a generalized\ninstrument property: sourcing a stimulus may entail configuring zero or more\ninstrument properties.  It is useful to think of a stimulus to be something that what you are measuring\nhas a chance to react to. For example, this could be applied voltage, sourced by\none or more instruments. The applied voltages would be seen by the device under test,\nwhich would respond accordingly. The stimulus could also just be a time delay,\nprovided by the measurement computer. It could even be the number of threads used\nby Julia for real-time processing.  An instrument property is any persistent setting of an instrument. Tweaking an\ninstrument property could affect the device under test, but it might not.\nAveraging is a good example. With averaging a measurement may look less noisy,\nbut your device under test doesn't know the difference. The trigger engine of a\ndigitizer would also have associated instrument properties.  In many cases there is an overlap between stimuli and properties. Consider that\nthe frequency of a signal generator is an instrument property. In this case\nsourcing a frequency stimulus results in configuring an instrument property.\nRather than make a  FrequencyStimulus  type, we provide a  PropertyStimulus  type\nwhich can be used more generically. Consider the following example, where we make a PropertyStimulus  for sweeping the frequency of our E8257D signal generator:  stim = PropertyStimulus(siggen::E8257D, Frequency)\nfor freq in 1e9:1e8:5e9     # 1 GHz to 5 GHz in steps of 100 MHz\n    source(stim, freq)\n    # measure(something)\nend  Note that  Frequency  is a subtype of  NumericalProperty , which is required for\nmaking a  PropertyStimulus .  Again, stimuli need not be tied to a particular property. Rather, this is just one\nconvenient and easily generalized example. In more complicated instances it is\nprobably better to make a new  Stimulus  subtype rather than use  PropertyStimulus .", 
            "title": "How do we configure instruments?"
        }, 
        {
            "location": "/design/#future-directions", 
            "text": "Feedback loops  In principle, asynchronous software feedback loops could be implemented\nwith the  Reactive.jl  package. This\nwould probably only be suitable for slowly varying signals, e.g. PID temperature\ncontrol. Ultimately benchmarking needs to be done to determine how useful\nthis approach would be.", 
            "title": "Future directions"
        }, 
        {
            "location": "/implementation/", 
            "text": "Implementation overview\n\n\nCode organization\n\n\nOrganizing the code into Julia modules is tricky and the organization may change\nin future releases. It would not be surprising if the way Julia implements modules\nchanges before Julia v1.0.\n\n\n\n\nWith few exceptions, all code is kept inside a single package. For now the\npackage is unregistered and must be retrieved from the repository with\n\nPkg.clone()\n rather than \nPkg.add()\n.\n\n\nLow-level wrappers for shared libraries are kept in their own packages\n(e.g. VISA and Alazar calls). This way, at least some code can be reused if\nsomeone else does not want to use our codebase.\n\n\n\n\n\n\nAll code is kept inside a \"main\" \nPainterQB\n module, defined inside \nsrc/PainterQB.jl\n.\n\n\nCommon instrument definitions and functions are defined in \nsrc/Definitions.jl\n.\n\n\nInstrumentVISA\n and associated functions are defined in \nsrc/VISA.jl\n.\n\n\nCode that should be loaded by Julia workers for parallel processing is\nactually kept outside the module to avoid loading the whole module unnecessarily.\nThese are typically functions that are focused on number crunching and don't\nneed to know much about the internals of PainterQB.\n\n\n\n\n\n\nEach instrument is defined within its own module, a submodule of \nPainterQB\n.\n\n\nEach instrument has a corresponding .jl file in \nsrc/instruments\n.\n\n\nInstrument model numbers are used for type definitions (e.g. \nAWG5014C\n),\nso module names have \"Module\" appended (e.g. \nAWG5014CModule\n). We put all\nAlazar digitizers in \nAlazarModule\n; the feature set and API is so similar\nfor the various models that just one module makes sense.\n\n\nexport\n statements from an instrument submodule are not currently exported\nfrom \nPainterQB\n. The statement \nusing PainterQB.AWG5014CModule\n\nmay be desired when using the AWG, for instance.\n\n\n\n\n\n\nTo test for possible namespace conflicts when adding new instruments,\nuncomment the \nimportall\n statements in \nsrc/PainterQB.jl\n.\n\n\nAs functions from different instrument modules are imported, any functions\nthat are defined in different modules will be printed and warned about. The\nsolution is to define the shared function name in \nsrc/Definitions.jl\n\n(\nglobal\n and \nexport\n) such that the submodules can both import the function.\n\n\n\n\n\n\n\n\nVISA instruments\n\n\nMany commercial instruments support a common communications protocol and command\nsyntax (VISA and SCPI respectively). For such instruments, many methods for\n\nconfigure\n and \ninspect\n can be generated with metaprogramming, rather than\ntyping them out explicitly. The implementation could and should be done\nmore elegantly, but it seems to work for now.\n\n\nThe file \nsrc/Metaprogramming.jl\n is included in each VISA\ninstrument's source file, and therefore in each instrument's own module.\nInitially this file was included directly in the PainterQB module, but it seems\nthere are subtleties regarding the use of the \n@eval\n macro between modules.\n\n\nMetaprogramming\n\n\ngenerate_inspect\n\n\ngenerate_inspect{S\n:Instrument,T\n:InstrumentProperty}(instype::Type{S},\n        command::ASCIIString, proptype::Type{T}, returntype...)\n\n\n\n\nThis command takes an \nInstrument\n subtype \ninstype\n, a VISA command, an\n\nInstrumentProperty\n subtype \nproptype\n, and possibly an argument. It will\ngenerate the following method in the module where \ngenerate_inspect\n is defined:\n\n\ninspect(ins::instype, ::Type{proptype}, infixes::Int...)\n\n\nThe \ninfixes\n variable argument allows for numbers to be inserted within the\ncommands, for instance in \nOUTP#:FILT:FREQ\n, where the \n#\n sign should be\nreplaced by an integer. The replacements are done in the order of the arguments.\nError checking is done on the number of arguments.\n\n\nFor a given property, \ninspect\n will return either an InstrumentProperty subtype,\na number, a boolean, or a string as appropriate.\n\n\ngenerate_configure\n\n\ngenerate_configure{S\n:Instrument,T\n:InstrumentProperty}(instype::Type{S},\n        command::ASCIIString, proptype::Type{T}, returntype...)\n\n\n\n\nThis command takes an \nInstrument\n subtype \nInsType\n, a VISA command, an\n\nInstrumentProperty\n type, and possibly an argument. It will generate one of the\nfollowing methods in the module where \ngenerate_inspect\n is defined:\n\n\nconfigure(ins::InsType, PropertySubtype)\nconfigure(ins::InsType, Property, values..., infixes...)\n\n\n\n\ngenerate_properties\n\n\ngenerate_properties{S\n:InstrumentProperty}(subtype::Symbol, supertype::Type{S})\n\n\n\n\nThis makes it easy to generate new \nInstrumentProperty\n subtypes. Typically\nthis function is called inside a for loop. Calling this function is equivalent\nto writing the following pseudocode:\n\n\nimmutable subtype{T} \n: supertype\nend\n\nexport subtype\n\n\n\n\ngenerate_handlers\n\n\ngenerate_handlers{T\n:Instrument}(insType::Type{T}, responseDict::Dict)\n\n\n\n\nEach instrument can have a \nresponseDict\n. For each setting of the instrument,\nfor instance the \nClockSource\n, we need to know the correspondence between a\nlogical state \nExternalClock\n and how the instrument encodes that logical state\n(e.g. \"EXT\").\nThe \nresponseDict\n is actually a dictionary of dictionaries. The first level keys\nare like \nClockSource\n and the second level keys are like \"EXT\", with the value\nbeing \n:ExternalClock\n. Undoubtedly\nthis nested dictionary is \"nasty\" (in the technical parlance) but the dictionary\nis only used for code\ncreation and is not used at run-time (if the code works as intended).\n\n\nThis function makes a lot of other functions. Given some response from an instrument,\nwe require a function to map that response back on to the appropiate logical state.\n\n\nClockSource(ins::AWG5014C, res::AbstractString)\n\nreturns an \nInternalClock\n or \nExternalClock\n type as appropriate,\nbased on the logical meaning of the response.\n\n\nWe also want a function to generate logical states without having to know the way\nthey are encoded by the instrument.\n\n\ncode(ins::AWG5014C, ::Type{InternalClock})\n returns \"INT\",\nwith \"INT\" encoding how to pass this logical state to the instrument \nins\n.\n\n\nResponses\n\n\nUnlike stimuli, all responses are subtypes of an abstract parametric type,\n\nResponse{T}\n. Although it may seem unduly abstract to have it be both abstract\nand parametric, we use this\nfunctionality to distinguish between desired return types of a measurement.\nSuppose an instrument provides data in some kind of awkward format, like 12-bit\nunsigned integers. For reasons of convenience we may want the measurement to\nreturn the data in a machine-native \nInt64\n format, or we may want to specify\na linear or 2D shape for the data, etc.\n\n\nAn important consideration in writing fast Julia code is to ensure type stability.\nIn other words, the type that is returned from a function should depend only on\nthe method signature and not depend on some value at run-time. By parameterizing\n\nResponse\n types with the return type, we can ensure that \nmeasure\n will be\ntype stable. If we instead had the desired return type as some field\nin a \nResponse\n object, then \nmeasure\n would not be type stable.\n\n\nAlazar digitizers\n\n\nA response type is given for each measurement mode:\ncontinuous streaming (\nContinuousStreamResponse\n), triggered streaming (\n\nTriggeredStreamResponse\n), NPT records (\nNPTRecordResponse\n),\nand FPGA-based FFT calculations (\nFFTHardwareResponse\n).\nTraditional record mode has not been implemented yet for lack of immediate need.\n\n\nLooking at the source code, it would\nseem that there is some redundancy in the types, for instance there is an\n\nNPTRecordMode\n and an \nNPTRecordResponse\n object. The difference is that the\nformer is used internally in the code to denote a particular method of configuring\nthe instrument, allocating buffers, etc., whereas the latter specifies what you\nactually want to do: retrieve NPT records from the digitizer, perhaps doing\nsome post-processing or processing during acquisition along the way. Perhaps\ndifferent responses would dictate different processing behavior, while the\ninstrument is ultimately configured the same way.\n\n\nAlazar instruments\n\n\nIn the following discussion, it is important to understand some Alazar terminology.\nNewer Alazar digitizers use direct memory access (DMA) to stream data into\na computer's RAM. A single \nacquisition\n uses one or many \nbuffers\n, which\nconstitute preallocated regions in the computer's physical memory. Each buffer\ncontains one or many \nrecords\n. Each \nrecord\n contains many \nsamples\n,\nwhich are the voltages measured by the digitizer.\n\n\nIn streaming mode, there is only one record per buffer, but in other modes there\ncan be many records per buffer.\n\n\nBuffer allocation\n\n\nDigitizer requirements\n\n\nThe Alazar digitizers expect buffers in physical memory which are page-aligned.\nThe size of each buffer should also be chosen appropriately.\n\n\nThe behavior of the digitizer is not specified when the buffer is made larger\nthan 64 MB. On our computer, it seems like an \nApiWaitTimeout\n error is thrown\nwhen the buffer is too large (for some unspecified definition of \"large\" greater\nthan 64 MB). The digitizer will then throw \nApiInsufficientResources\n errors\nwhenever another acquisition is attempted, until the computer is restarted.\nJust restarting the Julia kernel, forcing a reload of the Alazar DLLs,\ndoes not appear to be enough to reset the digitizer fully.\n\n\nFor performance reasons, a buffer should not be made much smaller than 1 MB if\nmulitple buffers are required.\nThere is also a minimum record size for each model of digitizer. For the ATS9360,\nif a record has fewer than 256 samples (could be 128 from channel A + 128 from channel B)\nthen the acquisition will proceed, but return garbage data. Allocating too small\nof a buffer is therefore still bad, but less fatal than allocating one that is too large.\n\n\n\n\n\nHow to allocate appropriate buffers in Julia\n\n\nIn Julia, just allocating a fixed-size array will not necessarily return a\npage-aligned block in memory. One approach would be to allocate our own page-aligned\nmemory using \nvalloc\n and \nvfree\n (or their Windows equivalents).\n\n\nfunction virtualalloc{T\n:Union{UInt8,UInt16}}(size_bytes::Integer, ::Type{T})\n    @windows? begin\n        MEM_COMMIT = U32(0x1000)\n        PAGE_READWRITE = U32(0x4)\n        addr = ccall((:VirtualAlloc, \nKernel32\n), Ptr{T},\n                     (Ptr{Void}, Culonglong, Culong, Culong),\n                     C_NULL, size_bytes, MEM_COMMIT, PAGE_READWRITE)\n    end : (@linux? begin\n        addr = ccall((:valloc, libc), Ptr{T}, (Culonglong,), size_bytes)\n    end : throw(SystemError()))\n\n    addr == C_NULL \n throw(OutOfMemoryError())\n\n    addr::Ptr{T}\nend\n\nfunction virtualfree{T\n:Union{UInt16,UInt8}}(addr::Ptr{T})\n    @windows? begin\n        MEM_RELEASE = 0x8000\n        ccall((:VirtualFree, \nKernel32\n), Cint, (Ptr{Void}, Culonglong, Culong),\n            addr, Culonglong(0), MEM_RELEASE)\n    end : (@linux? begin\n        ccall((:free, \nlibc\n), Void, (Ptr{Void},), addr)\n    end : throw(SystemError()))\n    nothing\nend\n\n\n\n\nIn case it wasn't obvious, this was my original approach.\nNote that memory allocated in this way will not be visible to multiple processes\nwithout extra work, and moreover we will need to deallocate the memory ourselves\nat a later time, perhaps using \nfinalizer()\n if the memory is made to be part of\na Julia object.\n\n\nFortunately, there is a special kind of array in Julia called the \nSharedArray\n.\nIt can be viewed and modified from multiple processes, and the memory is page-aligned.\nHopefully this continues to be the case in future Julia releases.\nWe implement a type called the \nDMABufferArray\n whose definition is worth\nrepeating here:\n\n\ntype DMABufferArray{sample_type} \n:\n        AbstractArray{Ptr{sample_type},1}\n\n    bytes_buf::Int\n    n_buf::Int\n    backing::SharedArray{sample_type}\n\n    DMABufferArray(bytes_buf, n_buf) = begin\n        n_buf \n 1 \n bytes_buf % Base.Mmap.PAGESIZE != 0 \n\n            error(\nBytes per buffer must be a multiple of Base.Mmap.PAGESIZE when \n,\n                  \nthere is more than one buffer.\n)\n\n        backing = SharedArray(sample_type,\n                        Int((bytes_buf * n_buf) / sizeof(sample_type)))\n\n        dmabuf = new(bytes_buf,\n                     n_buf,\n                     backing)\n\n        return dmabuf\n    end\n\nend\n\nBase.size(dma::DMABufferArray) = (dma.n_buf,)\nBase.linearindexing(::Type{DMABufferArray}) = Base.LinearFast()\nBase.getindex(dma::DMABufferArray, i::Int) =\n    pointer(dma.backing) + (i-1) * dma.bytes_buf\nBase.length(dma::DMABufferArray) = dma.n_buf\n\nbytespersample{T}(buf_array::DMABufferArray{T}) = sizeof(T)\nsampletype{T}(buf_array::DMABufferArray{T}) = T\n\n\n\n\nSome comments:\n\n\n\n\nA single SharedArray is used to back \nall\n DMA buffers. Memory is therefore\ncontiguous and page-aligned.\n\n\nThe memory for each DMA buffer is required to be a multiple of the page size\nwhen there is more than one buffer.\n\n\nThe memory can be accessed by multiple processes.\n\n\nThe elements of a \nDMABufferArray\n are pointers to the the different\nlocations in memory which act as DMA buffers. The array is iterable and indexable\nas usual.", 
            "title": "Implementation"
        }, 
        {
            "location": "/implementation/#implementation-overview", 
            "text": "", 
            "title": "Implementation overview"
        }, 
        {
            "location": "/implementation/#code-organization", 
            "text": "Organizing the code into Julia modules is tricky and the organization may change\nin future releases. It would not be surprising if the way Julia implements modules\nchanges before Julia v1.0.   With few exceptions, all code is kept inside a single package. For now the\npackage is unregistered and must be retrieved from the repository with Pkg.clone()  rather than  Pkg.add() .  Low-level wrappers for shared libraries are kept in their own packages\n(e.g. VISA and Alazar calls). This way, at least some code can be reused if\nsomeone else does not want to use our codebase.    All code is kept inside a \"main\"  PainterQB  module, defined inside  src/PainterQB.jl .  Common instrument definitions and functions are defined in  src/Definitions.jl .  InstrumentVISA  and associated functions are defined in  src/VISA.jl .  Code that should be loaded by Julia workers for parallel processing is\nactually kept outside the module to avoid loading the whole module unnecessarily.\nThese are typically functions that are focused on number crunching and don't\nneed to know much about the internals of PainterQB.    Each instrument is defined within its own module, a submodule of  PainterQB .  Each instrument has a corresponding .jl file in  src/instruments .  Instrument model numbers are used for type definitions (e.g.  AWG5014C ),\nso module names have \"Module\" appended (e.g.  AWG5014CModule ). We put all\nAlazar digitizers in  AlazarModule ; the feature set and API is so similar\nfor the various models that just one module makes sense.  export  statements from an instrument submodule are not currently exported\nfrom  PainterQB . The statement  using PainterQB.AWG5014CModule \nmay be desired when using the AWG, for instance.    To test for possible namespace conflicts when adding new instruments,\nuncomment the  importall  statements in  src/PainterQB.jl .  As functions from different instrument modules are imported, any functions\nthat are defined in different modules will be printed and warned about. The\nsolution is to define the shared function name in  src/Definitions.jl \n( global  and  export ) such that the submodules can both import the function.", 
            "title": "Code organization"
        }, 
        {
            "location": "/implementation/#visa-instruments", 
            "text": "Many commercial instruments support a common communications protocol and command\nsyntax (VISA and SCPI respectively). For such instruments, many methods for configure  and  inspect  can be generated with metaprogramming, rather than\ntyping them out explicitly. The implementation could and should be done\nmore elegantly, but it seems to work for now.  The file  src/Metaprogramming.jl  is included in each VISA\ninstrument's source file, and therefore in each instrument's own module.\nInitially this file was included directly in the PainterQB module, but it seems\nthere are subtleties regarding the use of the  @eval  macro between modules.  Metaprogramming  generate_inspect  generate_inspect{S :Instrument,T :InstrumentProperty}(instype::Type{S},\n        command::ASCIIString, proptype::Type{T}, returntype...)  This command takes an  Instrument  subtype  instype , a VISA command, an InstrumentProperty  subtype  proptype , and possibly an argument. It will\ngenerate the following method in the module where  generate_inspect  is defined:  inspect(ins::instype, ::Type{proptype}, infixes::Int...)  The  infixes  variable argument allows for numbers to be inserted within the\ncommands, for instance in  OUTP#:FILT:FREQ , where the  #  sign should be\nreplaced by an integer. The replacements are done in the order of the arguments.\nError checking is done on the number of arguments.  For a given property,  inspect  will return either an InstrumentProperty subtype,\na number, a boolean, or a string as appropriate.  generate_configure  generate_configure{S :Instrument,T :InstrumentProperty}(instype::Type{S},\n        command::ASCIIString, proptype::Type{T}, returntype...)  This command takes an  Instrument  subtype  InsType , a VISA command, an InstrumentProperty  type, and possibly an argument. It will generate one of the\nfollowing methods in the module where  generate_inspect  is defined:  configure(ins::InsType, PropertySubtype)\nconfigure(ins::InsType, Property, values..., infixes...)  generate_properties  generate_properties{S :InstrumentProperty}(subtype::Symbol, supertype::Type{S})  This makes it easy to generate new  InstrumentProperty  subtypes. Typically\nthis function is called inside a for loop. Calling this function is equivalent\nto writing the following pseudocode:  immutable subtype{T}  : supertype\nend\n\nexport subtype  generate_handlers  generate_handlers{T :Instrument}(insType::Type{T}, responseDict::Dict)  Each instrument can have a  responseDict . For each setting of the instrument,\nfor instance the  ClockSource , we need to know the correspondence between a\nlogical state  ExternalClock  and how the instrument encodes that logical state\n(e.g. \"EXT\").\nThe  responseDict  is actually a dictionary of dictionaries. The first level keys\nare like  ClockSource  and the second level keys are like \"EXT\", with the value\nbeing  :ExternalClock . Undoubtedly\nthis nested dictionary is \"nasty\" (in the technical parlance) but the dictionary\nis only used for code\ncreation and is not used at run-time (if the code works as intended).  This function makes a lot of other functions. Given some response from an instrument,\nwe require a function to map that response back on to the appropiate logical state.  ClockSource(ins::AWG5014C, res::AbstractString) \nreturns an  InternalClock  or  ExternalClock  type as appropriate,\nbased on the logical meaning of the response.  We also want a function to generate logical states without having to know the way\nthey are encoded by the instrument.  code(ins::AWG5014C, ::Type{InternalClock})  returns \"INT\",\nwith \"INT\" encoding how to pass this logical state to the instrument  ins .", 
            "title": "VISA instruments"
        }, 
        {
            "location": "/implementation/#responses", 
            "text": "Unlike stimuli, all responses are subtypes of an abstract parametric type, Response{T} . Although it may seem unduly abstract to have it be both abstract\nand parametric, we use this\nfunctionality to distinguish between desired return types of a measurement.\nSuppose an instrument provides data in some kind of awkward format, like 12-bit\nunsigned integers. For reasons of convenience we may want the measurement to\nreturn the data in a machine-native  Int64  format, or we may want to specify\na linear or 2D shape for the data, etc.  An important consideration in writing fast Julia code is to ensure type stability.\nIn other words, the type that is returned from a function should depend only on\nthe method signature and not depend on some value at run-time. By parameterizing Response  types with the return type, we can ensure that  measure  will be\ntype stable. If we instead had the desired return type as some field\nin a  Response  object, then  measure  would not be type stable.  Alazar digitizers  A response type is given for each measurement mode:\ncontinuous streaming ( ContinuousStreamResponse ), triggered streaming ( TriggeredStreamResponse ), NPT records ( NPTRecordResponse ),\nand FPGA-based FFT calculations ( FFTHardwareResponse ).\nTraditional record mode has not been implemented yet for lack of immediate need.  Looking at the source code, it would\nseem that there is some redundancy in the types, for instance there is an NPTRecordMode  and an  NPTRecordResponse  object. The difference is that the\nformer is used internally in the code to denote a particular method of configuring\nthe instrument, allocating buffers, etc., whereas the latter specifies what you\nactually want to do: retrieve NPT records from the digitizer, perhaps doing\nsome post-processing or processing during acquisition along the way. Perhaps\ndifferent responses would dictate different processing behavior, while the\ninstrument is ultimately configured the same way.", 
            "title": "Responses"
        }, 
        {
            "location": "/implementation/#alazar-instruments", 
            "text": "In the following discussion, it is important to understand some Alazar terminology.\nNewer Alazar digitizers use direct memory access (DMA) to stream data into\na computer's RAM. A single  acquisition  uses one or many  buffers , which\nconstitute preallocated regions in the computer's physical memory. Each buffer\ncontains one or many  records . Each  record  contains many  samples ,\nwhich are the voltages measured by the digitizer.  In streaming mode, there is only one record per buffer, but in other modes there\ncan be many records per buffer.  Buffer allocation  Digitizer requirements  The Alazar digitizers expect buffers in physical memory which are page-aligned.\nThe size of each buffer should also be chosen appropriately.  The behavior of the digitizer is not specified when the buffer is made larger\nthan 64 MB. On our computer, it seems like an  ApiWaitTimeout  error is thrown\nwhen the buffer is too large (for some unspecified definition of \"large\" greater\nthan 64 MB). The digitizer will then throw  ApiInsufficientResources  errors\nwhenever another acquisition is attempted, until the computer is restarted.\nJust restarting the Julia kernel, forcing a reload of the Alazar DLLs,\ndoes not appear to be enough to reset the digitizer fully.  For performance reasons, a buffer should not be made much smaller than 1 MB if\nmulitple buffers are required.\nThere is also a minimum record size for each model of digitizer. For the ATS9360,\nif a record has fewer than 256 samples (could be 128 from channel A + 128 from channel B)\nthen the acquisition will proceed, but return garbage data. Allocating too small\nof a buffer is therefore still bad, but less fatal than allocating one that is too large.   How to allocate appropriate buffers in Julia  In Julia, just allocating a fixed-size array will not necessarily return a\npage-aligned block in memory. One approach would be to allocate our own page-aligned\nmemory using  valloc  and  vfree  (or their Windows equivalents).  function virtualalloc{T :Union{UInt8,UInt16}}(size_bytes::Integer, ::Type{T})\n    @windows? begin\n        MEM_COMMIT = U32(0x1000)\n        PAGE_READWRITE = U32(0x4)\n        addr = ccall((:VirtualAlloc,  Kernel32 ), Ptr{T},\n                     (Ptr{Void}, Culonglong, Culong, Culong),\n                     C_NULL, size_bytes, MEM_COMMIT, PAGE_READWRITE)\n    end : (@linux? begin\n        addr = ccall((:valloc, libc), Ptr{T}, (Culonglong,), size_bytes)\n    end : throw(SystemError()))\n\n    addr == C_NULL   throw(OutOfMemoryError())\n\n    addr::Ptr{T}\nend\n\nfunction virtualfree{T :Union{UInt16,UInt8}}(addr::Ptr{T})\n    @windows? begin\n        MEM_RELEASE = 0x8000\n        ccall((:VirtualFree,  Kernel32 ), Cint, (Ptr{Void}, Culonglong, Culong),\n            addr, Culonglong(0), MEM_RELEASE)\n    end : (@linux? begin\n        ccall((:free,  libc ), Void, (Ptr{Void},), addr)\n    end : throw(SystemError()))\n    nothing\nend  In case it wasn't obvious, this was my original approach.\nNote that memory allocated in this way will not be visible to multiple processes\nwithout extra work, and moreover we will need to deallocate the memory ourselves\nat a later time, perhaps using  finalizer()  if the memory is made to be part of\na Julia object.  Fortunately, there is a special kind of array in Julia called the  SharedArray .\nIt can be viewed and modified from multiple processes, and the memory is page-aligned.\nHopefully this continues to be the case in future Julia releases.\nWe implement a type called the  DMABufferArray  whose definition is worth\nrepeating here:  type DMABufferArray{sample_type}  :\n        AbstractArray{Ptr{sample_type},1}\n\n    bytes_buf::Int\n    n_buf::Int\n    backing::SharedArray{sample_type}\n\n    DMABufferArray(bytes_buf, n_buf) = begin\n        n_buf   1   bytes_buf % Base.Mmap.PAGESIZE != 0  \n            error( Bytes per buffer must be a multiple of Base.Mmap.PAGESIZE when  ,\n                   there is more than one buffer. )\n\n        backing = SharedArray(sample_type,\n                        Int((bytes_buf * n_buf) / sizeof(sample_type)))\n\n        dmabuf = new(bytes_buf,\n                     n_buf,\n                     backing)\n\n        return dmabuf\n    end\n\nend\n\nBase.size(dma::DMABufferArray) = (dma.n_buf,)\nBase.linearindexing(::Type{DMABufferArray}) = Base.LinearFast()\nBase.getindex(dma::DMABufferArray, i::Int) =\n    pointer(dma.backing) + (i-1) * dma.bytes_buf\nBase.length(dma::DMABufferArray) = dma.n_buf\n\nbytespersample{T}(buf_array::DMABufferArray{T}) = sizeof(T)\nsampletype{T}(buf_array::DMABufferArray{T}) = T  Some comments:   A single SharedArray is used to back  all  DMA buffers. Memory is therefore\ncontiguous and page-aligned.  The memory for each DMA buffer is required to be a multiple of the page size\nwhen there is more than one buffer.  The memory can be accessed by multiple processes.  The elements of a  DMABufferArray  are pointers to the the different\nlocations in memory which act as DMA buffers. The array is iterable and indexable\nas usual.", 
            "title": "Alazar instruments"
        }, 
        {
            "location": "/api/api/", 
            "text": "API-INDEX\n\n\nMODULE: PainterQB\n\n\n\n\nMethods [Exported]\n\n\naborttrigger(ins::PainterQB.InstrumentVISA)\n  Abort triggering with ABOR.\n\n\nask(ins::PainterQB.InstrumentVISA,  msg::ASCIIString)\n  Idiomatic \"write and read available\" function with optional delay.\n\n\nask(ins::PainterQB.InstrumentVISA,  msg::ASCIIString,  delay::Real)\n  Idiomatic \"write and read available\" function with optional delay.\n\n\nbinblockreadavailable(ins::PainterQB.InstrumentVISA)\n  Read an entire block of bytes with properly formatted IEEE header.\n\n\nbinblockwrite(ins::PainterQB.InstrumentVISA,  message::Union{ASCIIString, Array{UInt8, 1}},  data::Array{UInt8, 1})\n  Write an IEEE header block followed by an arbitary sequency of bytes and the terminator.\n\n\nclearregisters(ins::PainterQB.InstrumentVISA)\n  Clear registers with *CLS.\n\n\nfindresources()\n  Finds VISA resources to which we can connect. Doesn't seem to find ethernet instruments.\n\n\nfindresources(expr::AbstractString)\n  Finds VISA resources to which we can connect. Doesn't seem to find ethernet instruments.\n\n\ngpib(board,  primary)\n  Returns a \nviSession\n for the given GPIB board and primary address.\n\n\ngpib(board,  primary,  secondary)\n  Returns a \nviSession\n for the given GPIB board, primary, and secondary address.\n\n\ngpib(primary)\n  Returns a \nviSession\n for the given GPIB primary address using board 0.\n\n\nidentify(ins::PainterQB.InstrumentVISA)\n  Ask the *IDN? command.\n\n\ninspect(ins::PainterQB.Instrument,  args::Tuple{Vararg{DataType}})\n  Allow inspecting mulitple properties at once.\n\n\ninspect(ins::PainterQB.Instrument,  args::Tuple{Vararg{T}})\n  Splat tuples into new inspect commands.\n\n\nmeasure(ch::PainterQB.RandomResponse)\n  Returns a random number in the unit interval.\n\n\nmeasure(ch::PainterQB.TimeAResponse)\n  Returns how many seconds it takes to measure the response field \nch\n holds.\n\n\nmeasure{T}(ch::PainterQB.AveragingResponse{T})\n  Measures the response held by \nch\n \nn_avg\n times, and returns the average.\n\n\nmeasure{T}(ch::PainterQB.TimerResponse{T})\n  Returns how many seconds have elapsed since the timer was initialized or reset.\n\n\nquoted(str::ASCIIString)\n  Surround a string in quotation marks.\n\n\nread(ins::PainterQB.InstrumentVISA)\n  Read from an instrument. Strips trailing carriage returns and new lines.\n\n\nreadavailable(ins::PainterQB.InstrumentVISA)\n  Keep reading from an instrument until the instrument says we are done.\n\n\nreset(d::PainterQB.DelayStimulus)\n  Reset the DelayStimulus reference time to now.\n\n\nreset(d::PainterQB.TimerResponse{T\n:AbstractFloat})\n  Reset the TimerResponse reference time to now.\n\n\nreset(ins::PainterQB.InstrumentVISA)\n  Reset with the *RST command.\n\n\nsource(ch::PainterQB.DelayStimulus,  val::Real)\n  Wait until \nval\n seconds have elapsed since \nch\n was initialized or reset.\n\n\nsource(ch::PainterQB.DummyStimulus)\n  Returns a random number in the unit interval.\n\n\nsource(ch::PainterQB.PropertyStimulus{T\n:PainterQB.InstrumentProperty{Number}},  val::Real)\n  Sourcing a PropertyStimulus configures an InstrumentProperty.\n\n\nsource(ch::PainterQB.ThreadStimulus,  nw::Int64)\n  Adds or removes threads to reach the desired number of worker threads.\n\n\nsource{T}(ch::PainterQB.ResponseStimulus{T},  val)\n  Sets the field named \n:name\n in the \nResponse\n held by \nch\n to \nval\n.\n\n\nsweep{T\n:Real, N}(dep::PainterQB.Response{T\n:Real},  indep::NTuple{N, Tuple{PainterQB.Stimulus, AbstractArray{T, N}}})\n  Measures a response as a function of an arbitrary number of stimuli.\n\n\nsweep{T}(dep::PainterQB.Response{T},  indep::Tuple{PainterQB.Stimulus, AbstractArray{T, N}}...)\n  This method is slightly more convenient than the other sweep method\n\n\ntcpip_instr(ip)\n  Returns a INSTR \nviSession\n for the given IPv4 address string.\n\n\ntcpip_socket(ip,  port)\n  Returns a raw socket \nviSession\n for the given IPv4 address string.\n\n\ntest(ins::PainterQB.InstrumentVISA)\n  Test with the *TST? command.\n\n\ntrigger(ins::PainterQB.InstrumentVISA)\n  Bus trigger with *TRG.\n\n\nunquoted(str::ASCIIString)\n  Strip a string of enclosing quotation marks.\n\n\nwait(ins::PainterQB.InstrumentVISA)\n  Wait for completion of a sweep.\n\n\nwrite(ins::PainterQB.InstrumentVISA,  msg::ASCIIString)\n  Write to an instrument. Appends the instrument's write terminator.\n\n\n\n\nTypes [Exported]\n\n\nPainterQB.All\n  The All type is meant to be dispatched upon and not instantiated.\n\n\nPainterQB.AveragingResponse{T}\n  Response that averages other responses. Not clear if this is a good idea yet.\n\n\nPainterQB.ClockSlope\n  Clock may tick on a rising or falling slope.\n\n\nPainterQB.ClockSource\n  Clock source can be internal or external.\n\n\nPainterQB.Coupling\n  Signals may be AC or DC coupled.\n\n\nPainterQB.DelayStimulus\n  A stimulus for delaying until time has passed since a reference time t0.\n\n\nPainterQB.DummyStimulus\n  Random number response suitable for testing the measurement code without having\n\n\nPainterQB.Frequency\n  Fixed frequency of a sourced signal.\n\n\nPainterQB.FrequencyStart\n  Start frequency of a fixed range.\n\n\nPainterQB.FrequencyStop\n  Stop frequency of a fixed range.\n\n\nPainterQB.Instrument\n  Abstract supertype representing an instrument.\n\n\nPainterQB.InstrumentException\n  Exception to be thrown by an instrument. Fields include the instrument in error\n\n\nPainterQB.InstrumentProperty{T}\n  Abstract parametric supertype representing communications with an instrument.\n\n\nPainterQB.InstrumentVISA\n  Abstract supertype of all Instruments addressable using a VISA library.\n\n\nPainterQB.NoArgs\n  Used internally to indicate that a property takes no argument.\n\n\nPainterQB.NumPoints\n  Number of points per sweep.\n\n\nPainterQB.OscillatorSource\n  Oscillator source can be internal or external.\n\n\nPainterQB.Output\n  Boolean output state of an instrument.\n\n\nPainterQB.Power\n  Output power level.\n\n\nPainterQB.PropertyStimulus{T\n:PainterQB.InstrumentProperty{Number}}\n  Wraps any Number-valued \nInstrumentProperty\n into a \nStimulus\n. Essentially,\n\n\nPainterQB.RandomResponse\n  Random number response suitable for testing the measurement code without having\n\n\nPainterQB.ResponseStimulus{T}\n  Esoteric stimulus to consider changing the fields of a \nResponse\n as a stimulus.\n\n\nPainterQB.SParameter\n  Scattering parameter, e.g. S11, S12, etc.\n\n\nPainterQB.SampleRate\n  The sample rate for digitizing, synthesizing, etc.\n\n\nPainterQB.ThreadStimulus\n  Changes the number of Julia worker threads. An Expr object is used to\n\n\nPainterQB.TimeAResponse\n  A response for timing other responses.\n\n\nPainterQB.TimerResponse{T\n:AbstractFloat}\n  A response for measuring how much time has passed since a reference time t0.\n\n\nPainterQB.TriggerImpedance\n  Trigger input impedance may be 50 Ohm or 1 kOhm.\n\n\nPainterQB.TriggerLevel\n  Trigger level.\n\n\nPainterQB.TriggerSlope\n  Trigger engine can fire on a rising or falling slope.\n\n\nPainterQB.TriggerSource\n  Trigger may be sourced from: internal, external, bus, etc.\n\n\n\n\nGlobals [Exported]\n\n\nresourcemanager\n  The default VISA resource manager.\n\n\n\n\nMethods [Internal]\n\n\ngenerate_configure{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty{T}}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty{T}})\n  This method generates the following method in the module where\n\n\ngenerate_configure{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty{T}}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty{T}},  ::Type{PainterQB.NoArgs})\n  This method generates the following method in the module where\n\n\ngenerate_configure{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty{T}}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty{T}},  returntype...)\n  This method generates the following method in the module where\n\n\ngenerate_handlers{T\n:PainterQB.Instrument}(insType::Type{T\n:PainterQB.Instrument},  responseDict::Dict{K, V})\n  Each instrument can have a \nresponseDict\n. For each setting of the instrument,\n\n\ngenerate_inspect{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty{T}}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty{T}},  ::Type{PainterQB.NoArgs})\n  This method does/returns nothing.\n\n\ngenerate_inspect{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty{T}}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty{T}},  returntype...)\n  This method will\n\n\ngenerate_properties{S\n:PainterQB.InstrumentProperty{T}}(subtype::Symbol,  supertype::Type{S\n:PainterQB.InstrumentProperty{T}})\n  Creates and exports immutable singleton subtypes.\n\n\n\n\nGlobals [Internal]\n\n\nLIVE_DATA\n  Condition indicating more data for a live update.\n\n\nLIVE_DIE\n  Condition indicating the end of a live update.\n\n\nLIVE_NEW_MEAS\n  Condition indicating the start of a live update.\n\n\nMODULE: PainterQB.E5071CModule\n\n\n\n\nTypes [Exported]\n\n\nPainterQB.E5071CModule.ElectricalMedium\n  Signals may propagate on coax or waveguide media.\n\n\n\n\nMethods [Internal]\n\n\ngenerate_configure{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty{T}}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty{T}})\n  This method generates the following method in the module where\n\n\ngenerate_configure{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty{T}}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty{T}},  ::Type{PainterQB.NoArgs})\n  This method generates the following method in the module where\n\n\ngenerate_configure{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty{T}}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty{T}},  returntype...)\n  This method generates the following method in the module where\n\n\ngenerate_handlers{T\n:PainterQB.Instrument}(insType::Type{T\n:PainterQB.Instrument},  responseDict::Dict{K, V})\n  Each instrument can have a \nresponseDict\n. For each setting of the instrument,\n\n\ngenerate_inspect{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty{T}}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty{T}},  ::Type{PainterQB.NoArgs})\n  This method does/returns nothing.\n\n\ngenerate_inspect{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty{T}}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty{T}},  returntype...)\n  This method will\n\n\ngenerate_properties{S\n:PainterQB.InstrumentProperty{T}}(subtype::Symbol,  supertype::Type{S\n:PainterQB.InstrumentProperty{T}})\n  Creates and exports immutable singleton subtypes.\n\n\nMODULE: PainterQB.ZNB20Module\n\n\n\n\nMethods [Exported]\n\n\ncd(ins::PainterQB.ZNB20Module.ZNB20,  dir::AbstractString)\n  \nMMEMory:CDIRectory\n\n\ncp(ins::PainterQB.ZNB20Module.ZNB20,  src::AbstractString,  dest::AbstractString)\n  \nMMEMory:COPY\n\n\nhidetrace(ins::PainterQB.ZNB20Module.ZNB20,  win::Int64,  wtrace::Int64)\n  \nDISPLAY:WINDOW#:TRACE#:DELETE\n\n\nlstrace(ins::PainterQB.ZNB20Module.ZNB20,  ch::Int64)\n  \nCALCULATE#:PARAMETER:CATALOG?\n\n\nmkdir(ins::PainterQB.ZNB20Module.ZNB20,  dir::AbstractString)\n  \nMMEMory:MDIRectory\n\n\nmktrace(ins::PainterQB.ZNB20Module.ZNB20,  name::AbstractString,  parameter,  ch::Int64)\n  \nCALCulate#:PARameter:SDEFine\n\n\npwd(ins::PainterQB.ZNB20Module.ZNB20)\n  \nMMEMory:CDIRectory?\n\n\nreaddir(ins::PainterQB.ZNB20Module.ZNB20)\n  \nMMEMory:CATalog?\n\n\nreaddir(ins::PainterQB.ZNB20Module.ZNB20,  dir::AbstractString)\n  \nMMEMory:CATalog?\n\n\nrm(ins::PainterQB.ZNB20Module.ZNB20,  file::AbstractString)\n  \nMMEMory:DELete\n\n\nrmtrace(ins::PainterQB.ZNB20Module.ZNB20)\n  \nCALCulate:PARameter:DELete:ALL\n\n\nrmtrace(ins::PainterQB.ZNB20Module.ZNB20,  ch::Int64)\n  \nCALCulate#:PARameter:DELete:CALL\n\n\nrmtrace(ins::PainterQB.ZNB20Module.ZNB20,  name::AbstractString,  ch::Int64)\n  \nCALCULATE#:PARAMETER:DELETE\n\n\nshowtrace(ins::PainterQB.ZNB20Module.ZNB20,  name::AbstractString,  win::Int64,  wtrace::Int64)\n  \nDISPLAY:WINDOW#:TRACE#:FEED\n\n\n\n\nTypes [Exported]\n\n\nPainterQB.ZNB20Module.AutoSweepTime\n  Configure or inspect. Does the instrument choose the minimum sweep time?\n\n\nPainterQB.ZNB20Module.DisplayUpdate\n  Configure or inspect. Display updates during measurement.\n\n\nPainterQB.ZNB20Module.SweepTime\n  Configure or inspect. Adjust time it takes to complete a sweep (all partial measurements).\n\n\nPainterQB.ZNB20Module.Window\n  \nInstrumentProperty\n: Window.\n\n\n\n\nMethods [Internal]\n\n\nconfigure(ins::PainterQB.ZNB20Module.ZNB20,  ::Type{PainterQB.NumPoints},  n::Int64)\n  \nSENSE#:SWEEP:POINTS\n\n\nconfigure(ins::PainterQB.ZNB20Module.ZNB20,  ::Type{PainterQB.NumPoints},  n::Int64,  ch::Int64)\n  \nSENSE#:SWEEP:POINTS\n\n\nconfigure(ins::PainterQB.ZNB20Module.ZNB20,  ::Type{PainterQB.ZNB20Module.AutoSweepTime},  b::Bool)\n  \nSENSE#:SWEEP:TIME:AUTO\n\n\nconfigure(ins::PainterQB.ZNB20Module.ZNB20,  ::Type{PainterQB.ZNB20Module.AutoSweepTime},  b::Bool,  ch::Int64)\n  \nSENSE#:SWEEP:TIME:AUTO\n\n\nconfigure(ins::PainterQB.ZNB20Module.ZNB20,  ::Type{PainterQB.ZNB20Module.DisplayUpdate},  b::Bool)\n  \nSYSTEM:DISPLAY:UPDATE\n\n\nconfigure(ins::PainterQB.ZNB20Module.ZNB20,  ::Type{PainterQB.ZNB20Module.SweepTime},  time::Real)\n  \nSENSE#:SWEEP:TIME\n\n\nconfigure(ins::PainterQB.ZNB20Module.ZNB20,  ::Type{PainterQB.ZNB20Module.SweepTime},  time::Real,  ch::Int64)\n  \nSENSE#:SWEEP:TIME\n\n\nconfigure(ins::PainterQB.ZNB20Module.ZNB20,  ::Type{PainterQB.ZNB20Module.Window},  b::Bool,  win::Int64)\n  \nDISPLAY:WINDOW#:STATE\n\n\ngenerate_configure{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty{T}}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty{T}})\n  This method generates the following method in the module where\n\n\ngenerate_configure{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty{T}}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty{T}},  ::Type{PainterQB.NoArgs})\n  This method generates the following method in the module where\n\n\ngenerate_configure{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty{T}}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty{T}},  returntype...)\n  This method generates the following method in the module where\n\n\ngenerate_handlers{T\n:PainterQB.Instrument}(insType::Type{T\n:PainterQB.Instrument},  responseDict::Dict{K, V})\n  Each instrument can have a \nresponseDict\n. For each setting of the instrument,\n\n\ngenerate_inspect{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty{T}}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty{T}},  ::Type{PainterQB.NoArgs})\n  This method does/returns nothing.\n\n\ngenerate_inspect{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty{T}}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty{T}},  returntype...)\n  This method will\n\n\ngenerate_properties{S\n:PainterQB.InstrumentProperty{T}}(subtype::Symbol,  supertype::Type{S\n:PainterQB.InstrumentProperty{T}})\n  Creates and exports immutable singleton subtypes.\n\n\ninspect(ins::PainterQB.ZNB20Module.ZNB20,  ::Type{PainterQB.NumPoints})\n  \nSENSE#:SWEEP:POINTS\n\n\ninspect(ins::PainterQB.ZNB20Module.ZNB20,  ::Type{PainterQB.NumPoints},  ch::Int64)\n  \nSENSE#:SWEEP:POINTS\n\n\ninspect(ins::PainterQB.ZNB20Module.ZNB20,  ::Type{PainterQB.ZNB20Module.AutoSweepTime})\n  \nSENSE#:SWEEP:TIME:AUTO\n\n\ninspect(ins::PainterQB.ZNB20Module.ZNB20,  ::Type{PainterQB.ZNB20Module.AutoSweepTime},  ch::Int64)\n  \nSENSE#:SWEEP:TIME:AUTO\n\n\ninspect(ins::PainterQB.ZNB20Module.ZNB20,  ::Type{PainterQB.ZNB20Module.DisplayUpdate})\n  \nSYSTEM:DISPLAY:UPDATE\n\n\ninspect(ins::PainterQB.ZNB20Module.ZNB20,  ::Type{PainterQB.ZNB20Module.SweepTime})\n  \nSENSE#:SWEEP:TIME\n\n\ninspect(ins::PainterQB.ZNB20Module.ZNB20,  ::Type{PainterQB.ZNB20Module.SweepTime},  ch::Int64)\n  \nSENSE#:SWEEP:TIME\n\n\ninspect(ins::PainterQB.ZNB20Module.ZNB20,  ::Type{PainterQB.ZNB20Module.Window},  win::Int64)\n  Determines if a window exists, by window number. See \nlswindow\n.\n\n\ninspect(ins::PainterQB.ZNB20Module.ZNB20,  ::Type{PainterQB.ZNB20Module.Window},  wname::AbstractString)\n  Determines if a window exists, by window name. See \nlswindow\n.\n\n\nlswindows(ins::PainterQB.ZNB20Module.ZNB20)\n  \nDISPLAY:CATALOG?\n\n\nMODULE: PainterQB.E8257DModule\n\n\n\n\nFunctions [Exported]\n\n\nPainterQB.E8257DModule.cumulativeattenuatorswitches\n  Returns the number of attenuator switching events over the instrument lifetime.\n\n\nPainterQB.E8257DModule.cumulativeontime\n  Returns the cumulative on-time over the instrument lifetime.\n\n\nPainterQB.E8257DModule.cumulativepowerons\n  Returns the number of power on events over the instrument lifetime.\n\n\nPainterQB.E8257DModule.revision\n  Reports the revision of the E8257D.\n\n\nPainterQB.options\n  Reports the options available for the given E8257D.\n\n\n\n\nTypes [Exported]\n\n\nPainterQB.E8257DModule.ALC\n  Boolean state of the ALC.\n\n\nPainterQB.E8257DModule.ALCBandwidth\n  ALC bandwidth.\n\n\nPainterQB.E8257DModule.ALCBandwidthAuto\n  Boolean state for automatic selection of the ALC bandwidth.\n\n\nPainterQB.E8257DModule.ALCLevel\n  Level of the ALC when the attenuator hold is active.\n\n\nPainterQB.E8257DModule.AttenuatorAuto\n  Boolean state for automatic operation of the attenuator.\n\n\nPainterQB.E8257DModule.E8257D\n  Concrete type representing an E8257D.\n\n\nPainterQB.E8257DModule.FlatnessCorrection\n  Boolean state for flatness correction.\n\n\nPainterQB.E8257DModule.FrequencyReference\n  Boolean state of the frequency reference level.\n\n\nPainterQB.E8257DModule.FrequencyReferenceLevel\n  Reference level for configuring/inspecting frequency.\n\n\nPainterQB.E8257DModule.FrequencyStep\n  Step size for a frequency sweep.\n\n\nPainterQB.E8257DModule.OutputBlanking\n  Boolean state for the output blanking.\n\n\nPainterQB.E8257DModule.OutputBlankingAuto\n  Boolean state for automatic blanking of the output.\n\n\nPainterQB.E8257DModule.OutputSettled\n  Has the output settled?\n\n\nPainterQB.E8257DModule.PowerLimit\n  RF output power limit.\n\n\nPainterQB.E8257DModule.PowerLimitAdjustable\n  Boolean for whether or not the RF output power limit can be adjusted.\n\n\nPainterQB.E8257DModule.PowerReference\n  Boolean state of the power reference level.\n\n\nPainterQB.E8257DModule.PowerReferenceLevel\n  Reference level for configuring/inspecting power.\n\n\nPainterQB.E8257DModule.PowerStart\n  Start power in a sweep.\n\n\nPainterQB.E8257DModule.PowerStep\n  Step size for a power sweep.\n\n\nPainterQB.E8257DModule.PowerStop\n  Stop power in a sweep.\n\n\n\n\nMethods [Internal]\n\n\ngenerate_configure{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty{T}}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty{T}})\n  This method generates the following method in the module where\n\n\ngenerate_configure{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty{T}}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty{T}},  ::Type{PainterQB.NoArgs})\n  This method generates the following method in the module where\n\n\ngenerate_configure{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty{T}}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty{T}},  returntype...)\n  This method generates the following method in the module where\n\n\ngenerate_handlers{T\n:PainterQB.Instrument}(insType::Type{T\n:PainterQB.Instrument},  responseDict::Dict{K, V})\n  Each instrument can have a \nresponseDict\n. For each setting of the instrument,\n\n\ngenerate_inspect{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty{T}}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty{T}},  ::Type{PainterQB.NoArgs})\n  This method does/returns nothing.\n\n\ngenerate_inspect{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty{T}}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty{T}},  returntype...)\n  This method will\n\n\ngenerate_properties{S\n:PainterQB.InstrumentProperty{T}}(subtype::Symbol,  supertype::Type{S\n:PainterQB.InstrumentProperty{T}})\n  Creates and exports immutable singleton subtypes.\n\n\nMODULE: PainterQB.AWG5014CModule\n\n\n\n\nFunctions [Exported]\n\n\nPainterQB.AWG5014CModule.applicationstate\n  Is an application running?\n\n\nPainterQB.AWG5014CModule.clearwaveforms\n  Clear waveforms from all channels.\n\n\nPainterQB.AWG5014CModule.deletewaveform\n  Delete a waveform by name.\n\n\nPainterQB.AWG5014CModule.load_awg_settings\n  Load an AWG settings file.\n\n\nPainterQB.AWG5014CModule.newwaveform\n  Create a new waveform by name, number of points, and waveform type.\n\n\nPainterQB.AWG5014CModule.normalizewaveform\n  Normalize a waveform.\n\n\nPainterQB.AWG5014CModule.pullfrom_awg\n  Pull data from the AWG, performing checks and generating errors as appropriate.\n\n\nPainterQB.AWG5014CModule.pushto_awg\n  Push waveform data to the AWG, performing checks and generating errors as appropriate.\n\n\nPainterQB.AWG5014CModule.resamplewaveform\n  Resample a waveform.\n\n\nPainterQB.AWG5014CModule.runapplication\n  Run an application, e.g. SerialXpress\n\n\nPainterQB.AWG5014CModule.save_awg_settings\n  Save an AWG settings file.\n\n\nPainterQB.AWG5014CModule.validate\n  Validates data to be pushed to the AWG to check for internal consistency\n\n\nPainterQB.AWG5014CModule.waveform\n  Uses Julia style indexing (begins at 1) to retrieve the name of a waveform\n\n\nPainterQB.AWG5014CModule.waveformexists\n  Does a waveform identified by \nname\n exist?\n\n\nPainterQB.AWG5014CModule.waveformispredefined\n  Returns whether or not a waveform is predefined (comes with instrument).\n\n\nPainterQB.AWG5014CModule.waveformlength\n  Returns the length of a waveform.\n\n\nPainterQB.AWG5014CModule.waveformtimestamp\n  Return the timestamp for when a waveform was last updated.\n\n\nPainterQB.AWG5014CModule.waveformtype\n  Returns the type of the waveform. The AWG hardware\n\n\n\n\nTypes [Exported]\n\n\nPainterQB.AWG5014CModule.AWG5014C\n  Concrete type representing an AWG5014C.\n\n\nPainterQB.AWG5014CModule.AWG5014CData\n  Type for storing waveform data (including markers) in Float32 format.\n\n\nPainterQB.AWG5014CModule.Amplitude\n  Amplitude for a given channel.\n\n\nPainterQB.AWG5014CModule.AnalogOutputDelay\n  Analog output delay for a given channel.\n\n\nPainterQB.AWG5014CModule.ChannelOutput\n  Boolean state of the output for a given channel.\n\n\nPainterQB.AWG5014CModule.DCOutput\n  Boolean state of the DC output for a given channel (bottom-right of AWG).\n\n\nPainterQB.AWG5014CModule.DCOutputLevel\n  DC output level for a given channel.\n\n\nPainterQB.AWG5014CModule.EventImpedance\n  Event input impedance may be 50 Ohm or 1 kOhm.\n\n\nPainterQB.AWG5014CModule.EventSlope\n  Event may fire on a rising or falling slope.\n\n\nPainterQB.AWG5014CModule.EventTiming\n  Events may occur synchronously or asynchronously.\n\n\nPainterQB.AWG5014CModule.ExtInputAddsToOutput\n  Add the signal from an external input to the given channel output.\n\n\nPainterQB.AWG5014CModule.ExtOscDividerRate\n  Divider rate of the external oscillator; must be a power of 2 (1 ok).\n\n\nPainterQB.AWG5014CModule.MarkerDelay\n  Marker delay for a given channel and marker. Marker can be 1 or 2.\n\n\nPainterQB.AWG5014CModule.OutputFilterFrequency\n  Low-pass filter frequency for the output. INF = 9.9e37\n\n\nPainterQB.AWG5014CModule.RefOscFrequency\n  Reference oscillator frequency.\n\n\nPainterQB.AWG5014CModule.RefOscMultiplier\n  Reference oscillator multiplier.\n\n\nPainterQB.AWG5014CModule.RepRate\n  Repetition rate (frequency of waveform). Changing this will change the\n\n\nPainterQB.AWG5014CModule.RepRateHeld\n  Boolean hold state of the repetition rate. If held, the repetition rate will\n\n\nPainterQB.AWG5014CModule.SCPIVersion\n  The SCPI version of the AWG.\n\n\nPainterQB.AWG5014CModule.SequencerEventJumpTarget\n  Target index for the sequencer event jump operation.\n\n\nPainterQB.AWG5014CModule.SequencerGOTOState\n  Boolean GOTO state of the sequencer.\n\n\nPainterQB.AWG5014CModule.SequencerGOTOTarget\n  Target index for the GOTO command of the sequencer.\n\n\nPainterQB.AWG5014CModule.SequencerInfiniteLoop\n  Boolean state of infinite loop on a sequencer element.\n\n\nPainterQB.AWG5014CModule.SequencerLength\n  Length of the sequence. Can be destructive to existing sequences.\n\n\nPainterQB.AWG5014CModule.SequencerLoopCount\n  Loop count of the sequencer, from 1 to 65536. Ignored if infinite loop.\n\n\nPainterQB.AWG5014CModule.SequencerPosition\n  Current sequencer position.\n\n\nPainterQB.AWG5014CModule.SequencerType\n  Sequencer may be hardware or software.\n\n\nPainterQB.AWG5014CModule.TriggerMode\n  Trigger engine may be triggered, continuously firing, gated, or sequenced.\n\n\nPainterQB.AWG5014CModule.TriggerTimer\n  Internal trigger rate.\n\n\nPainterQB.AWG5014CModule.VoltageOffset\n  Offset voltage for a given channel.\n\n\nPainterQB.AWG5014CModule.WaitingForTrigger\n  When inspected, will report if the instrument is waiting for a trigger.\n\n\nPainterQB.AWG5014CModule.Waveform\n  Name of a waveform loaded into a given channel.\n\n\nPainterQB.AWG5014CModule.WaveformType\n  Waveform type may be integer or real.\n\n\nPainterQB.AWG5014CModule.WavelistLength\n  The number of waveforms stored in the AWG.\n\n\n\n\nMacros [Exported]\n\n\n@allch(x::Expr)\n  Macro for performing an operation on every channel,\n\n\n\n\nFunctions [Internal]\n\n\nPainterQB.AWG5014CModule.nbytes\n  Returns the number of bytes per sample for a a given waveform type.\n\n\nPainterQB.AWG5014CModule.pulllowlevel\n  Takes care of the dirty work in pulling data from the AWG.\n\n\nPainterQB.AWG5014CModule.pushlowlevel\n  Takes care of the dirty work in pushing the data to the AWG.\n\n\n\n\nMethods [Internal]\n\n\nconfigure(ins::PainterQB.AWG5014CModule.AWG5014C,  ::Type{PainterQB.AWG5014CModule.Amplitude},  ampl::Real,  ch::Integer)\n  Configure Vpp for a given channel, between 0.05 V and 2 V.\n\n\nconfigure(ins::PainterQB.AWG5014CModule.AWG5014C,  ::Type{PainterQB.AWG5014CModule.Waveform},  name::ASCIIString,  ch::Integer)\n  Configure the waveform by name for a given channel.\n\n\nconfigure(ins::PainterQB.AWG5014CModule.AWG5014C,  ::Type{PainterQB.Output},  on::Bool)\n  Configure the global analog output state of the AWG.\n\n\nconfigure(ins::PainterQB.AWG5014CModule.AWG5014C,  ::Type{PainterQB.Phase},  phase::Real,  ch::Integer)\n  Set the output phase in degrees for a given channel.\n\n\nconfigure(ins::PainterQB.AWG5014CModule.AWG5014C,  ::Type{PainterQB.SampleRate},  rate::Real)\n  Configure the sample rate in Hz between 10 MHz and 10 GHz.\n\n\ngenerate_configure{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty{T}}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty{T}})\n  This method generates the following method in the module where\n\n\ngenerate_configure{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty{T}}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty{T}},  ::Type{PainterQB.NoArgs})\n  This method generates the following method in the module where\n\n\ngenerate_configure{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty{T}}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty{T}},  returntype...)\n  This method generates the following method in the module where\n\n\ngenerate_handlers{T\n:PainterQB.Instrument}(insType::Type{T\n:PainterQB.Instrument},  responseDict::Dict{K, V})\n  Each instrument can have a \nresponseDict\n. For each setting of the instrument,\n\n\ngenerate_inspect{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty{T}}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty{T}},  ::Type{PainterQB.NoArgs})\n  This method does/returns nothing.\n\n\ngenerate_inspect{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty{T}}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty{T}},  returntype...)\n  This method will\n\n\ngenerate_properties{S\n:PainterQB.InstrumentProperty{T}}(subtype::Symbol,  supertype::Type{S\n:PainterQB.InstrumentProperty{T}})\n  Creates and exports immutable singleton subtypes.\n\n\ninspect(ins::PainterQB.AWG5014CModule.AWG5014C,  ::Type{PainterQB.AWG5014CModule.Amplitude},  ch::Integer)\n  Inspect Vpp for a given channel.\n\n\ninspect(ins::PainterQB.AWG5014CModule.AWG5014C,  ::Type{PainterQB.AWG5014CModule.SequencerType})\n  Returns current sequencer type.\n\n\ninspect(ins::PainterQB.AWG5014CModule.AWG5014C,  ::Type{PainterQB.AWG5014CModule.WaitingForTrigger})\n  Inspect whether or not the instrument is waiting for a trigger.\n\n\ninspect(ins::PainterQB.AWG5014CModule.AWG5014C,  ::Type{PainterQB.AWG5014CModule.Waveform},  ch::Integer)\n  Inspect the waveform name for a given channel.\n\n\ninspect(ins::PainterQB.AWG5014CModule.AWG5014C,  ::Type{PainterQB.Output})\n  Inspect the global analog output state of the AWG.\n\n\ninspect(ins::PainterQB.AWG5014CModule.AWG5014C,  ::Type{PainterQB.Phase},  ch::Integer)\n  Get the output phase in degrees for a given channel.\n\n\ninspect(ins::PainterQB.AWG5014CModule.AWG5014C,  ::Type{PainterQB.SampleRate})\n  Get the sample rate in Hz. Output rate = sample rate / number of points.\n\n\n\n\nGlobals [Internal]\n\n\nbyteLimit\n  Maximum number of bytes that may be sent using the SCPI command WLIS:WAV:DATA.\n\n\nexceptions\n  Exception dictionary mapping signed integers to error strings.\n\n\nmaximumValue\n  Constant used for synthesizing/interpreting waveforms of integer type.\n\n\nminimumValue\n  Constant used for synthesizing/interpreting waveforms of integer type.\n\n\nnoError\n  Internal AWG code meaning no errors.\n\n\noffsetPlusPPOver2\n  Constant used for synthesizing/interpreting waveforms of integer type.\n\n\noffsetValue\n  Constant used for synthesizing/interpreting waveforms of integer type.\n\n\nMODULE: PainterQB.AlazarModule\n\n\n\n\nFunctions [Exported]\n\n\nPainterQB.AlazarModule.abort\n  Aborts an acquisition. Must be called in the case of a DSP acquisition; somehow\n\n\nPainterQB.AlazarModule.before_async_read\n  Performs setup for asynchronous acquisitions. Should be called after\n\n\nPainterQB.AlazarModule.bufferarray\n  Given and \nInstrumentAlazar\n and \nAlazarMode\n, returns a \nDMABufferArray\n\n\nPainterQB.AlazarModule.buffersizing\n  Given an \nInstrumentAlazar\n and an \nAlazarMode\n, this will tweak parameters\n\n\nPainterQB.AlazarModule.fft_fpga_setup\n  If necessary, performs \nAlazarFFTSetup\n, which should be called before\n\n\nPainterQB.AlazarModule.recordsizing\n  Calls C function \nAlazarSetRecordSize\n if necessary, given an \nInstrumentAlazar\n\n\nPainterQB.AlazarModule.wait_buffer\n  Waits for a buffer to be processed (or a timeout to elapse).\n\n\n\n\nMethods [Exported]\n\n\nbusy(a::PainterQB.AlazarModule.InstrumentAlazar)\n  Returns whether or not the \nInstrumentAlazar\n is busy (Bool).\n\n\nconfigure(a::PainterQB.AlazarModule.AlazarATS9360,  ::Type{PainterQB.SampleRate},  rate::Real)\n  Configure the sample rate to any multiple of 1 MHz (within 300 MHz and 1.8 GHz)\n\n\nconfigure(a::PainterQB.AlazarModule.InstrumentAlazar,  ::Type{PainterQB.AlazarModule.AuxSoftwareTriggerEnable},  b::Bool)\n  If an AUX IO output mode has been configured, then this will configure\n\n\nconfigure(a::PainterQB.AlazarModule.InstrumentAlazar,  ::Type{PainterQB.AlazarModule.LED},  ledState::Bool)\n  Configures the LED on the digitizer card chassis.\n\n\nconfigure(a::PainterQB.AlazarModule.InstrumentAlazar,  ::Type{PainterQB.AlazarModule.RecordCount},  count)\n  Wrapper for C function \nAlazarSetRecordCount\n. See the Alazar API.\n\n\nconfigure(a::PainterQB.AlazarModule.InstrumentAlazar,  ::Type{PainterQB.AlazarModule.Sleep},  sleepState)\n  Configures the sleep state of the digitizer card.\n\n\nconfigure(a::PainterQB.AlazarModule.InstrumentAlazar,  ::Type{PainterQB.AlazarModule.TriggerDelaySamples},  delay_samples)\n  Configure how many samples to wait after receiving a trigger event before capturing\n\n\nconfigure(a::PainterQB.AlazarModule.InstrumentAlazar,  ::Type{PainterQB.AlazarModule.TriggerTimeoutS},  timeout_s)\n  Wrapper for C function \nAlazarSetTriggerTimeOut\n, except we take seconds here\n\n\nconfigure(a::PainterQB.AlazarModule.InstrumentAlazar,  ::Type{PainterQB.AlazarModule.TriggerTimeoutTicks},  ticks)\n  Wrapper for C function \nAlazarSetTriggerTimeOut\n.\n\n\nconfigure(a::PainterQB.AlazarModule.InstrumentAlazar,  ::Type{PainterQB.TriggerLevel},  levelJ,  levelK)\n  Configure the trigger level for trigger engine J and K. This should be an\n\n\nconfigure(a::PainterQB.AlazarModule.InstrumentAlazar,  aux::Type{PainterQB.AlazarModule.AuxDigitalInput})\n  Configure a digitizer's AUX IO to act as a digital input.\n\n\nconfigure(a::PainterQB.AlazarModule.InstrumentAlazar,  aux::Type{PainterQB.AlazarModule.AuxDigitalOutput},  level::Integer)\n  Configure a digitizer's AUX IO port to act as a general purpose digital output.\n\n\nconfigure(a::PainterQB.AlazarModule.InstrumentAlazar,  aux::Type{PainterQB.AlazarModule.AuxOutputPacer},  divider::Integer)\n  Configure a digitizer's AUX IO port to output the sample clock, divided by an integer.\n\n\nconfigure(a::PainterQB.AlazarModule.InstrumentAlazar,  aux::Type{PainterQB.AlazarModule.AuxOutputTrigger})\n  Configure a digitizer's AUX IO to output a trigger signal synced to the sample clock.\n\n\nconfigure(a::PainterQB.AlazarModule.InstrumentAlazar,  ch::Type{PainterQB.AlazarModule.BothChannels})\n  Configures acquisition from both channels, simultaneously.\n\n\nconfigure{S\n:PainterQB.AlazarModule.AlazarDataPacking}(a::PainterQB.AlazarModule.InstrumentAlazar,  ::Type{PainterQB.AlazarModule.AlazarDataPacking},  pack::Type{S\n:PainterQB.AlazarModule.AlazarDataPacking},  ch::Type{PainterQB.AlazarModule.BothChannels})\n  Configures the data packing mode for both channels.\n\n\nconfigure{S\n:PainterQB.AlazarModule.AlazarDataPacking}(a::PainterQB.AlazarModule.InstrumentAlazar,  ::Type{PainterQB.AlazarModule.AlazarDataPacking},  pack::Type{S\n:PainterQB.AlazarModule.AlazarDataPacking},  ch::Type{PainterQB.AlazarModule.ChannelA})\n  Configures the data packing mode for channel A.\n\n\nconfigure{S\n:PainterQB.AlazarModule.AlazarDataPacking}(a::PainterQB.AlazarModule.InstrumentAlazar,  ::Type{PainterQB.AlazarModule.AlazarDataPacking},  pack::Type{S\n:PainterQB.AlazarModule.AlazarDataPacking},  ch::Type{PainterQB.AlazarModule.ChannelB})\n  Configures the data packing mode for channel B.\n\n\nconfigure{S\n:PainterQB.AlazarModule.DSPWindow{T}, T\n:PainterQB.AlazarModule.DSPWindow{T}}(a::PainterQB.AlazarModule.AlazarATS9360,  re::Type{S\n:PainterQB.AlazarModule.DSPWindow{T}},  im::Type{T\n:PainterQB.AlazarModule.DSPWindow{T}})\n  Configures the DSP windows. \nAlazarFFTSetWindowFunction\n is called towards\n\n\nconfigure{S\n:PainterQB.TriggerSlope, T\n:PainterQB.TriggerSlope}(a::PainterQB.AlazarModule.InstrumentAlazar,  slopeJ::Type{S\n:PainterQB.TriggerSlope},  slopeK::Type{T\n:PainterQB.TriggerSlope})\n  Configures whether to trigger on a rising or falling slope, for engine J and K.\n\n\nconfigure{S\n:PainterQB.TriggerSource, T\n:PainterQB.TriggerSource}(a::PainterQB.AlazarModule.InstrumentAlazar,  sourceJ::Type{S\n:PainterQB.TriggerSource},  sourceK::Type{T\n:PainterQB.TriggerSource})\n  Configure the trigger source for trigger engine J and K.\n\n\nconfigure{T\n:PainterQB.AlazarModule.AlazarChannel}(a::PainterQB.AlazarModule.InstrumentAlazar,  ch::Type{T\n:PainterQB.AlazarModule.AlazarChannel})\n  Configures the acquisition channel.\n\n\nconfigure{T\n:PainterQB.AlazarModule.AlazarTimestampReset}(a::PainterQB.AlazarModule.InstrumentAlazar,  t::Type{T\n:PainterQB.AlazarModule.AlazarTimestampReset})\n  Configures timestamp reset. From the Alazar API, the choices are\n\n\nconfigure{T\n:PainterQB.AlazarModule.AlazarTriggerEngine}(a::PainterQB.AlazarModule.InstrumentAlazar,  engine::Type{T\n:PainterQB.AlazarModule.AlazarTriggerEngine})\n  Configures the trigger engines, e.g. TriggerOnJ, TriggerOnJAndNotK, etc.\n\n\nconfigure{T\n:PainterQB.AlazarModule.AlazarTriggerRange}(a::PainterQB.AlazarModule.AlazarATS9360,  range::Type{T\n:PainterQB.AlazarModule.AlazarTriggerRange})\n  Does nothing but display info telling you that this parameter cannot be changed\n\n\nconfigure{T\n:PainterQB.AlazarModule.AlazarTriggerRange}(a::PainterQB.AlazarModule.InstrumentAlazar,  range::Type{T\n:PainterQB.AlazarModule.AlazarTriggerRange})\n  Configure the external trigger range.\n\n\nconfigure{T\n:PainterQB.ClockSlope}(a::PainterQB.AlazarModule.InstrumentAlazar,  slope::Type{T\n:PainterQB.ClockSlope})\n  Configures whether the clock ticks on a rising or falling slope.\n\n\nconfigure{T\n:PainterQB.Coupling}(a::PainterQB.AlazarModule.AlazarATS9360,  coupling::Type{T\n:PainterQB.Coupling})\n  Does nothing but display info telling you that this parameter cannot be changed\n\n\nconfigure{T\n:PainterQB.Coupling}(a::PainterQB.AlazarModule.InstrumentAlazar,  coupling::Type{T\n:PainterQB.Coupling})\n  Configure the external trigger coupling.\n\n\nconfigure{T\n:PainterQB.SampleRate}(a::PainterQB.AlazarModule.InstrumentAlazar,  rate::Type{T\n:PainterQB.SampleRate})\n  Configures one of the preset sample rates derived from the internal clock.\n\n\nconfigure{T\n:PainterQB.TriggerSlope}(a::PainterQB.AlazarModule.InstrumentAlazar,  aux::Type{PainterQB.AlazarModule.AuxInputTriggerEnable},  trigSlope::Type{T\n:PainterQB.TriggerSlope})\n  Configure a digitizer's AUX IO port to use the edge of a pulse as an AutoDMA\n\n\ndsp_getinfo(dspModule::PainterQB.AlazarModule.DSPModule)\n  Returns a DSPModuleInfo object that describes a DSPModule.\n\n\ndsp_getmodulehandles(a::PainterQB.AlazarModule.InstrumentAlazar)\n  Returns an Array of \ndsp_module_handle\n.\n\n\ndsp_modules(a::PainterQB.AlazarModule.InstrumentAlazar)\n  Returns an array of \nDSPModule\n.\n\n\ndsp_num_modules(a::PainterQB.AlazarModule.InstrumentAlazar)\n  Returns the number of \nDSPModule\n.\n\n\nforcetrigger(a::PainterQB.AlazarModule.InstrumentAlazar)\n  Force a software trigger.\n\n\nforcetriggerenable(a::PainterQB.AlazarModule.InstrumentAlazar)\n  Force a software \"trigger enable.\" This involves the AUX I/O connector (see\n\n\ninputcontrol(a::PainterQB.AlazarModule.InstrumentAlazar,  channel,  coupling,  inputRange,  impedance)\n  Controls coupling, input range, and impedance for applicable digitizer cards.\n\n\ninspect(a::PainterQB.AlazarModule.AlazarATS9360,  ::Type{PainterQB.AlazarModule.BufferAlignment})\n  Returns the buffer alignment requirement (samples / record / channel).\n\n\ninspect(a::PainterQB.AlazarModule.AlazarATS9360,  ::Type{PainterQB.AlazarModule.MaxBufferBytes})\n  Maximum number of bytes for a given DMA buffer.\n\n\ninspect(a::PainterQB.AlazarModule.AlazarATS9360,  ::Type{PainterQB.AlazarModule.MaxFFTSamples})\n  Maximum number of samples in an FPGA-based FFT. Can be obtained from \ndsp_getinfo\n\n\ninspect(a::PainterQB.AlazarModule.AlazarATS9360,  ::Type{PainterQB.AlazarModule.MinFFTSamples})\n  Minimum number of samples in an FPGA-based FFT. Set by the minimum record size.\n\n\ninspect(a::PainterQB.AlazarModule.AlazarATS9360,  ::Type{PainterQB.AlazarModule.MinSamplesPerRecord})\n  Minimum samples per record. Observed behavior deviates from Table 8 of the\n\n\ninspect(a::PainterQB.AlazarModule.AlazarATS9360,  ::Type{PainterQB.AlazarModule.PretriggerAlignment})\n  Returns the pretrigger alignment requirement (samples / record / channel).\n\n\ninspect(a::PainterQB.AlazarModule.InstrumentAlazar,  ::Type{PainterQB.AlazarModule.AlazarAux})\n  Inspect the AUX IO mode.\n\n\ninspect(a::PainterQB.AlazarModule.InstrumentAlazar,  ::Type{PainterQB.AlazarModule.AlazarChannel})\n  Returns which channel(s) will be acquired.\n\n\ninspect(a::PainterQB.AlazarModule.InstrumentAlazar,  ::Type{PainterQB.AlazarModule.ChannelCount})\n  Returns the number of channels to acquire.\n\n\ninspect(a::PainterQB.AlazarModule.InstrumentAlazar,  ::Type{PainterQB.AlazarModule.SampleMemoryPerChannel})\n  Returns the memory per channel in units of samples.\n\n\ninspect(a::PainterQB.AlazarModule.InstrumentAlazar,  ::Type{PainterQB.SampleRate})\n  Inspect the sample rate. As currently programmed, does not distinguish\n\n\ninspect{T\n:PainterQB.AlazarModule.AlazarChannel}(a::PainterQB.AlazarModule.InstrumentAlazar,  ::Type{PainterQB.AlazarModule.AlazarDataPacking},  ch::Type{T\n:PainterQB.AlazarModule.AlazarChannel})\n  Inspect the data packing mode for a given channel.\n\n\nmeasure(ch::PainterQB.AlazarModule.AlazarResponse{T})\n  Largely generic method for measuring \nAlazarResponse\n. Can be considered a\n\n\nmeasure(ch::PainterQB.AlazarModule.IQSoftwareResponse{T})\n  Assume two-channel IQ FFT acquisition.\n\n\npost_async_buffer(a::PainterQB.AlazarModule.InstrumentAlazar,  buffer,  bufferLength)\n  Post an asynchronous buffer to the digitizer for use in an acquisition.\n\n\nset_parameter(a::PainterQB.AlazarModule.InstrumentAlazar,  channelId,  parameterId,  value)\n  Julia wrapper for C function AlazarSetParameter, with error checking.\n\n\nset_parameter_ul(a::PainterQB.AlazarModule.InstrumentAlazar,  channelId,  parameterId,  value)\n  Julia wrapper for C function AlazarSetParameterUL, with error checking.\n\n\nset_triggeroperation(a::PainterQB.AlazarModule.InstrumentAlazar,  args...)\n  Configure the trigger operation. Usually not called directly.\n\n\nstartcapture(a::PainterQB.AlazarModule.InstrumentAlazar)\n  Should be called after \nbefore_async_read\n has been called and buffers are posted.\n\n\ntriggered(a::PainterQB.AlazarModule.InstrumentAlazar)\n  Reports whether or not the digitizer has been triggered.\n\n\n\n\nTypes [Exported]\n\n\nPainterQB.AlazarModule.AlazarATS9360\n  Concrete InstrumentAlazar subtype representing an ATS9360 digitizer.\n\n\nPainterQB.AlazarModule.DSPModule\n  Represents a DSP module of an AlazarTech digitizer.\n\n\nPainterQB.AlazarModule.DSPModuleInfo\n  Encapsulates DSP module information: type, version, and max record length.\n\n\nPainterQB.AlazarModule.DSPWindow{T}\n  Abstract parametric type representing a windowing function for DSP.\n\n\nPainterQB.AlazarModule.InstrumentAlazar\n  Abstract type representing an AlazarTech digitizer.\n\n\nPainterQB.AlazarModule.WindowBartlett{T}\n  Bartlett window. Implemented in AlazarDSP.\n\n\nPainterQB.AlazarModule.WindowBlackmanHarris{T}\n  Blackman-Harris window. Implemented in AlazarDSP.\n\n\nPainterQB.AlazarModule.WindowBlackman{T}\n  Blackman window. Implemented in AlazarDSP.\n\n\nPainterQB.AlazarModule.WindowHamming{T}\n  Hamming window. Implemented in AlazarDSP.\n\n\nPainterQB.AlazarModule.WindowHanning{T}\n  Hanning window. Implemented in AlazarDSP.\n\n\nPainterQB.AlazarModule.WindowNone{T}\n  Flat window (ones). Implemented in AlazarDSP.\n\n\nPainterQB.AlazarModule.WindowZeroes{T}\n  Flat window (zeroes!).\n\n\n\n\nTypealiass [Exported]\n\n\nWindowOnes\n  Type alias for \nWindowNone\n.\n\n\n\n\nGlobals [Exported]\n\n\ninf_records\n  Alazar API representation of an infinite number of records.\n\n\n\n\nFunctions [Internal]\n\n\nPainterQB.AlazarModule.adma\n  Returns the asynchronous DMA flags for a given \nAlazarMode\n. These are\n\n\nPainterQB.AlazarModule.dsp\n  Given a DSPWindow type, this returns the constant needed to use the AlazarDSP\n\n\nPainterQB.AlazarModule.generatewindowfunction\n  Given a \nDSPWindow\n, samples per record, and padding samples, this will prepare\n\n\nPainterQB.AlazarModule.initmodes\n  Should be called at the beginning of a measure method to initialize the\n\n\nPainterQB.AlazarModule.postprocess\n  Arrange for reinterpretation or conversion of the data stored in the\n\n\nPainterQB.AlazarModule.pretriggersamples\n  Given an \nAlazarMode\n, returns the number of pre-trigger samples.\n\n\nPainterQB.AlazarModule.processing\n  Specifies what to do with the buffers during measurement based on the response type.\n\n\nPainterQB.AlazarModule.rec_acq_param\n  Returns the value to pass as the recordsPerAcquisition parameter in the C\n\n\nPainterQB.AlazarModule.records_per_acquisition\n  Given an \nInstrumentAlazar\n and \nAlazarMode\n, return the records per acquisition.\n\n\nPainterQB.AlazarModule.records_per_buffer\n  Given an \nInstrumentAlazar\n and \nAlazarMode\n, return the records per buffer.\n\n\nPainterQB.AlazarModule.samples_per_buffer_measured\n  Given an \nInstrumentAlazar\n and \nAlazarMode\n, return the samples per buffer\n\n\nPainterQB.AlazarModule.samples_per_buffer_returned\n  Given an \nInstrumentAlazar\n and \nAlazarMode\n, return the samples per buffer\n\n\nPainterQB.AlazarModule.samples_per_record_measured\n  Given an \nInstrumentAlazar\n and \nAlazarMode\n, return the samples per record\n\n\nPainterQB.AlazarModule.samples_per_record_returned\n  Given an \nInstrumentAlazar\n and \nAlazarMode\n, return the samples per record\n\n\n\n\nMethods [Internal]\n\n\nauxmode(m::UInt32,  b::Bool)\n  Masks an AUX IO mode parameter to specify AUX IO software trigger enable.\n\n\nbits_per_sample(a::PainterQB.AlazarModule.AlazarATS9360)\n  Hard coded to return 0x0c. May need to change if we want to play with data packing.\n\n\nbits_per_sample(a::PainterQB.AlazarModule.InstrumentAlazar)\n  Returns the number of bits per sample. Queries the digitizer directly via\n\n\nboardhandle(sysid::Integer,  boardid::Integer)\n  Return a handle to an Alazar digitizer given a system ID and board ID.\n\n\nboardkind(handle::UInt32)\n  Returns the kind of digitizer; corresponds to a constant in AlazarConstants.jl\n\n\nbytes_per_sample(a::PainterQB.AlazarModule.AlazarATS9360)\n  Hard coded to return 2. May need to change if we want to play with data packing.\n\n\nbytes_per_sample(a::PainterQB.AlazarModule.InstrumentAlazar)\n  Returns the number of bytes per sample. Calls \nbitspersample\n and does ceiling\n\n\ngenerate_configure{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty{T}}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty{T}})\n  This method generates the following method in the module where\n\n\ngenerate_configure{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty{T}}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty{T}},  ::Type{PainterQB.NoArgs})\n  This method generates the following method in the module where\n\n\ngenerate_configure{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty{T}}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty{T}},  returntype...)\n  This method generates the following method in the module where\n\n\ngenerate_handlers{T\n:PainterQB.Instrument}(insType::Type{T\n:PainterQB.Instrument},  responseDict::Dict{K, V})\n  Each instrument can have a \nresponseDict\n. For each setting of the instrument,\n\n\ngenerate_inspect{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty{T}}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty{T}},  ::Type{PainterQB.NoArgs})\n  This method does/returns nothing.\n\n\ngenerate_inspect{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty{T}}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty{T}},  returntype...)\n  This method will\n\n\ngenerate_properties{S\n:PainterQB.InstrumentProperty{T}}(subtype::Symbol,  supertype::Type{S\n:PainterQB.InstrumentProperty{T}})\n  Creates and exports immutable singleton subtypes.\n\n\niqfft(sam_per_buf::Int64,  buf_completed::Int64,  rec_per_buf::Int64,  backing::SharedArray{T, N},  fft_array::SharedArray{T, N})\n  Convert and copy\n\n\nscaling{T\n:AbstractArray{T, N}}(resp::PainterQB.AlazarModule.FFTResponse{T\n:AbstractArray{T, N}})\n  Returns the axis scaling for an FFT response.\n\n\nscaling{T\n:AbstractArray{T, N}}(resp::PainterQB.AlazarModule.FFTResponse{T\n:AbstractArray{T, N}},  whichaxis::Integer)\n  Returns the axis scaling for an FFT response.\n\n\ntofloat!(sam_per_buf::Int64,  buf_completed::Int64,  backing::SharedArray{T, N})\n  Arrange multithreaded conversion of the Alazar 12-bit integer format to 16-bit\n\n\ntriglevel(a::PainterQB.AlazarModule.AlazarATS9360,  x)\n  Returns a UInt32 in the range 0--255 given a desired trigger level in Volts.\n\n\n\n\nTypes [Internal]\n\n\nPainterQB.AlazarModule.AlazarATS9440\n  Abstract type; not implemented.\n\n\n\n\nMacros [Internal]\n\n\n@eh2(expr)\n  Takes an Alazar API call and brackets it with some error checking.\n\n\n\n\nGlobals [Internal]\n\n\nlib_opened\n  Flag indicating whether the AlazarTech shared library has been opened.", 
            "title": "Index"
        }, 
        {
            "location": "/api/api/#api-index", 
            "text": "", 
            "title": "API-INDEX"
        }, 
        {
            "location": "/api/api/#module-painterqb", 
            "text": "", 
            "title": "MODULE: PainterQB"
        }, 
        {
            "location": "/api/api/#methods-exported", 
            "text": "aborttrigger(ins::PainterQB.InstrumentVISA)   Abort triggering with ABOR.  ask(ins::PainterQB.InstrumentVISA,  msg::ASCIIString)   Idiomatic \"write and read available\" function with optional delay.  ask(ins::PainterQB.InstrumentVISA,  msg::ASCIIString,  delay::Real)   Idiomatic \"write and read available\" function with optional delay.  binblockreadavailable(ins::PainterQB.InstrumentVISA)   Read an entire block of bytes with properly formatted IEEE header.  binblockwrite(ins::PainterQB.InstrumentVISA,  message::Union{ASCIIString, Array{UInt8, 1}},  data::Array{UInt8, 1})   Write an IEEE header block followed by an arbitary sequency of bytes and the terminator.  clearregisters(ins::PainterQB.InstrumentVISA)   Clear registers with *CLS.  findresources()   Finds VISA resources to which we can connect. Doesn't seem to find ethernet instruments.  findresources(expr::AbstractString)   Finds VISA resources to which we can connect. Doesn't seem to find ethernet instruments.  gpib(board,  primary)   Returns a  viSession  for the given GPIB board and primary address.  gpib(board,  primary,  secondary)   Returns a  viSession  for the given GPIB board, primary, and secondary address.  gpib(primary)   Returns a  viSession  for the given GPIB primary address using board 0.  identify(ins::PainterQB.InstrumentVISA)   Ask the *IDN? command.  inspect(ins::PainterQB.Instrument,  args::Tuple{Vararg{DataType}})   Allow inspecting mulitple properties at once.  inspect(ins::PainterQB.Instrument,  args::Tuple{Vararg{T}})   Splat tuples into new inspect commands.  measure(ch::PainterQB.RandomResponse)   Returns a random number in the unit interval.  measure(ch::PainterQB.TimeAResponse)   Returns how many seconds it takes to measure the response field  ch  holds.  measure{T}(ch::PainterQB.AveragingResponse{T})   Measures the response held by  ch   n_avg  times, and returns the average.  measure{T}(ch::PainterQB.TimerResponse{T})   Returns how many seconds have elapsed since the timer was initialized or reset.  quoted(str::ASCIIString)   Surround a string in quotation marks.  read(ins::PainterQB.InstrumentVISA)   Read from an instrument. Strips trailing carriage returns and new lines.  readavailable(ins::PainterQB.InstrumentVISA)   Keep reading from an instrument until the instrument says we are done.  reset(d::PainterQB.DelayStimulus)   Reset the DelayStimulus reference time to now.  reset(d::PainterQB.TimerResponse{T :AbstractFloat})   Reset the TimerResponse reference time to now.  reset(ins::PainterQB.InstrumentVISA)   Reset with the *RST command.  source(ch::PainterQB.DelayStimulus,  val::Real)   Wait until  val  seconds have elapsed since  ch  was initialized or reset.  source(ch::PainterQB.DummyStimulus)   Returns a random number in the unit interval.  source(ch::PainterQB.PropertyStimulus{T :PainterQB.InstrumentProperty{Number}},  val::Real)   Sourcing a PropertyStimulus configures an InstrumentProperty.  source(ch::PainterQB.ThreadStimulus,  nw::Int64)   Adds or removes threads to reach the desired number of worker threads.  source{T}(ch::PainterQB.ResponseStimulus{T},  val)   Sets the field named  :name  in the  Response  held by  ch  to  val .  sweep{T :Real, N}(dep::PainterQB.Response{T :Real},  indep::NTuple{N, Tuple{PainterQB.Stimulus, AbstractArray{T, N}}})   Measures a response as a function of an arbitrary number of stimuli.  sweep{T}(dep::PainterQB.Response{T},  indep::Tuple{PainterQB.Stimulus, AbstractArray{T, N}}...)   This method is slightly more convenient than the other sweep method  tcpip_instr(ip)   Returns a INSTR  viSession  for the given IPv4 address string.  tcpip_socket(ip,  port)   Returns a raw socket  viSession  for the given IPv4 address string.  test(ins::PainterQB.InstrumentVISA)   Test with the *TST? command.  trigger(ins::PainterQB.InstrumentVISA)   Bus trigger with *TRG.  unquoted(str::ASCIIString)   Strip a string of enclosing quotation marks.  wait(ins::PainterQB.InstrumentVISA)   Wait for completion of a sweep.  write(ins::PainterQB.InstrumentVISA,  msg::ASCIIString)   Write to an instrument. Appends the instrument's write terminator.", 
            "title": "Methods [Exported]"
        }, 
        {
            "location": "/api/api/#types-exported", 
            "text": "PainterQB.All   The All type is meant to be dispatched upon and not instantiated.  PainterQB.AveragingResponse{T}   Response that averages other responses. Not clear if this is a good idea yet.  PainterQB.ClockSlope   Clock may tick on a rising or falling slope.  PainterQB.ClockSource   Clock source can be internal or external.  PainterQB.Coupling   Signals may be AC or DC coupled.  PainterQB.DelayStimulus   A stimulus for delaying until time has passed since a reference time t0.  PainterQB.DummyStimulus   Random number response suitable for testing the measurement code without having  PainterQB.Frequency   Fixed frequency of a sourced signal.  PainterQB.FrequencyStart   Start frequency of a fixed range.  PainterQB.FrequencyStop   Stop frequency of a fixed range.  PainterQB.Instrument   Abstract supertype representing an instrument.  PainterQB.InstrumentException   Exception to be thrown by an instrument. Fields include the instrument in error  PainterQB.InstrumentProperty{T}   Abstract parametric supertype representing communications with an instrument.  PainterQB.InstrumentVISA   Abstract supertype of all Instruments addressable using a VISA library.  PainterQB.NoArgs   Used internally to indicate that a property takes no argument.  PainterQB.NumPoints   Number of points per sweep.  PainterQB.OscillatorSource   Oscillator source can be internal or external.  PainterQB.Output   Boolean output state of an instrument.  PainterQB.Power   Output power level.  PainterQB.PropertyStimulus{T :PainterQB.InstrumentProperty{Number}}   Wraps any Number-valued  InstrumentProperty  into a  Stimulus . Essentially,  PainterQB.RandomResponse   Random number response suitable for testing the measurement code without having  PainterQB.ResponseStimulus{T}   Esoteric stimulus to consider changing the fields of a  Response  as a stimulus.  PainterQB.SParameter   Scattering parameter, e.g. S11, S12, etc.  PainterQB.SampleRate   The sample rate for digitizing, synthesizing, etc.  PainterQB.ThreadStimulus   Changes the number of Julia worker threads. An Expr object is used to  PainterQB.TimeAResponse   A response for timing other responses.  PainterQB.TimerResponse{T :AbstractFloat}   A response for measuring how much time has passed since a reference time t0.  PainterQB.TriggerImpedance   Trigger input impedance may be 50 Ohm or 1 kOhm.  PainterQB.TriggerLevel   Trigger level.  PainterQB.TriggerSlope   Trigger engine can fire on a rising or falling slope.  PainterQB.TriggerSource   Trigger may be sourced from: internal, external, bus, etc.", 
            "title": "Types [Exported]"
        }, 
        {
            "location": "/api/api/#globals-exported", 
            "text": "resourcemanager   The default VISA resource manager.", 
            "title": "Globals [Exported]"
        }, 
        {
            "location": "/api/api/#methods-internal", 
            "text": "generate_configure{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty{T}}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty{T}})   This method generates the following method in the module where  generate_configure{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty{T}}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty{T}},  ::Type{PainterQB.NoArgs})   This method generates the following method in the module where  generate_configure{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty{T}}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty{T}},  returntype...)   This method generates the following method in the module where  generate_handlers{T :PainterQB.Instrument}(insType::Type{T :PainterQB.Instrument},  responseDict::Dict{K, V})   Each instrument can have a  responseDict . For each setting of the instrument,  generate_inspect{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty{T}}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty{T}},  ::Type{PainterQB.NoArgs})   This method does/returns nothing.  generate_inspect{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty{T}}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty{T}},  returntype...)   This method will  generate_properties{S :PainterQB.InstrumentProperty{T}}(subtype::Symbol,  supertype::Type{S :PainterQB.InstrumentProperty{T}})   Creates and exports immutable singleton subtypes.", 
            "title": "Methods [Internal]"
        }, 
        {
            "location": "/api/api/#globals-internal", 
            "text": "LIVE_DATA   Condition indicating more data for a live update.  LIVE_DIE   Condition indicating the end of a live update.  LIVE_NEW_MEAS   Condition indicating the start of a live update.", 
            "title": "Globals [Internal]"
        }, 
        {
            "location": "/api/api/#module-painterqbe5071cmodule", 
            "text": "", 
            "title": "MODULE: PainterQB.E5071CModule"
        }, 
        {
            "location": "/api/api/#types-exported_1", 
            "text": "PainterQB.E5071CModule.ElectricalMedium   Signals may propagate on coax or waveguide media.", 
            "title": "Types [Exported]"
        }, 
        {
            "location": "/api/api/#methods-internal_1", 
            "text": "generate_configure{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty{T}}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty{T}})   This method generates the following method in the module where  generate_configure{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty{T}}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty{T}},  ::Type{PainterQB.NoArgs})   This method generates the following method in the module where  generate_configure{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty{T}}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty{T}},  returntype...)   This method generates the following method in the module where  generate_handlers{T :PainterQB.Instrument}(insType::Type{T :PainterQB.Instrument},  responseDict::Dict{K, V})   Each instrument can have a  responseDict . For each setting of the instrument,  generate_inspect{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty{T}}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty{T}},  ::Type{PainterQB.NoArgs})   This method does/returns nothing.  generate_inspect{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty{T}}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty{T}},  returntype...)   This method will  generate_properties{S :PainterQB.InstrumentProperty{T}}(subtype::Symbol,  supertype::Type{S :PainterQB.InstrumentProperty{T}})   Creates and exports immutable singleton subtypes.", 
            "title": "Methods [Internal]"
        }, 
        {
            "location": "/api/api/#module-painterqbznb20module", 
            "text": "", 
            "title": "MODULE: PainterQB.ZNB20Module"
        }, 
        {
            "location": "/api/api/#methods-exported_1", 
            "text": "cd(ins::PainterQB.ZNB20Module.ZNB20,  dir::AbstractString)    MMEMory:CDIRectory  cp(ins::PainterQB.ZNB20Module.ZNB20,  src::AbstractString,  dest::AbstractString)    MMEMory:COPY  hidetrace(ins::PainterQB.ZNB20Module.ZNB20,  win::Int64,  wtrace::Int64)    DISPLAY:WINDOW#:TRACE#:DELETE  lstrace(ins::PainterQB.ZNB20Module.ZNB20,  ch::Int64)    CALCULATE#:PARAMETER:CATALOG?  mkdir(ins::PainterQB.ZNB20Module.ZNB20,  dir::AbstractString)    MMEMory:MDIRectory  mktrace(ins::PainterQB.ZNB20Module.ZNB20,  name::AbstractString,  parameter,  ch::Int64)    CALCulate#:PARameter:SDEFine  pwd(ins::PainterQB.ZNB20Module.ZNB20)    MMEMory:CDIRectory?  readdir(ins::PainterQB.ZNB20Module.ZNB20)    MMEMory:CATalog?  readdir(ins::PainterQB.ZNB20Module.ZNB20,  dir::AbstractString)    MMEMory:CATalog?  rm(ins::PainterQB.ZNB20Module.ZNB20,  file::AbstractString)    MMEMory:DELete  rmtrace(ins::PainterQB.ZNB20Module.ZNB20)    CALCulate:PARameter:DELete:ALL  rmtrace(ins::PainterQB.ZNB20Module.ZNB20,  ch::Int64)    CALCulate#:PARameter:DELete:CALL  rmtrace(ins::PainterQB.ZNB20Module.ZNB20,  name::AbstractString,  ch::Int64)    CALCULATE#:PARAMETER:DELETE  showtrace(ins::PainterQB.ZNB20Module.ZNB20,  name::AbstractString,  win::Int64,  wtrace::Int64)    DISPLAY:WINDOW#:TRACE#:FEED", 
            "title": "Methods [Exported]"
        }, 
        {
            "location": "/api/api/#types-exported_2", 
            "text": "PainterQB.ZNB20Module.AutoSweepTime   Configure or inspect. Does the instrument choose the minimum sweep time?  PainterQB.ZNB20Module.DisplayUpdate   Configure or inspect. Display updates during measurement.  PainterQB.ZNB20Module.SweepTime   Configure or inspect. Adjust time it takes to complete a sweep (all partial measurements).  PainterQB.ZNB20Module.Window    InstrumentProperty : Window.", 
            "title": "Types [Exported]"
        }, 
        {
            "location": "/api/api/#methods-internal_2", 
            "text": "configure(ins::PainterQB.ZNB20Module.ZNB20,  ::Type{PainterQB.NumPoints},  n::Int64)    SENSE#:SWEEP:POINTS  configure(ins::PainterQB.ZNB20Module.ZNB20,  ::Type{PainterQB.NumPoints},  n::Int64,  ch::Int64)    SENSE#:SWEEP:POINTS  configure(ins::PainterQB.ZNB20Module.ZNB20,  ::Type{PainterQB.ZNB20Module.AutoSweepTime},  b::Bool)    SENSE#:SWEEP:TIME:AUTO  configure(ins::PainterQB.ZNB20Module.ZNB20,  ::Type{PainterQB.ZNB20Module.AutoSweepTime},  b::Bool,  ch::Int64)    SENSE#:SWEEP:TIME:AUTO  configure(ins::PainterQB.ZNB20Module.ZNB20,  ::Type{PainterQB.ZNB20Module.DisplayUpdate},  b::Bool)    SYSTEM:DISPLAY:UPDATE  configure(ins::PainterQB.ZNB20Module.ZNB20,  ::Type{PainterQB.ZNB20Module.SweepTime},  time::Real)    SENSE#:SWEEP:TIME  configure(ins::PainterQB.ZNB20Module.ZNB20,  ::Type{PainterQB.ZNB20Module.SweepTime},  time::Real,  ch::Int64)    SENSE#:SWEEP:TIME  configure(ins::PainterQB.ZNB20Module.ZNB20,  ::Type{PainterQB.ZNB20Module.Window},  b::Bool,  win::Int64)    DISPLAY:WINDOW#:STATE  generate_configure{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty{T}}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty{T}})   This method generates the following method in the module where  generate_configure{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty{T}}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty{T}},  ::Type{PainterQB.NoArgs})   This method generates the following method in the module where  generate_configure{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty{T}}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty{T}},  returntype...)   This method generates the following method in the module where  generate_handlers{T :PainterQB.Instrument}(insType::Type{T :PainterQB.Instrument},  responseDict::Dict{K, V})   Each instrument can have a  responseDict . For each setting of the instrument,  generate_inspect{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty{T}}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty{T}},  ::Type{PainterQB.NoArgs})   This method does/returns nothing.  generate_inspect{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty{T}}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty{T}},  returntype...)   This method will  generate_properties{S :PainterQB.InstrumentProperty{T}}(subtype::Symbol,  supertype::Type{S :PainterQB.InstrumentProperty{T}})   Creates and exports immutable singleton subtypes.  inspect(ins::PainterQB.ZNB20Module.ZNB20,  ::Type{PainterQB.NumPoints})    SENSE#:SWEEP:POINTS  inspect(ins::PainterQB.ZNB20Module.ZNB20,  ::Type{PainterQB.NumPoints},  ch::Int64)    SENSE#:SWEEP:POINTS  inspect(ins::PainterQB.ZNB20Module.ZNB20,  ::Type{PainterQB.ZNB20Module.AutoSweepTime})    SENSE#:SWEEP:TIME:AUTO  inspect(ins::PainterQB.ZNB20Module.ZNB20,  ::Type{PainterQB.ZNB20Module.AutoSweepTime},  ch::Int64)    SENSE#:SWEEP:TIME:AUTO  inspect(ins::PainterQB.ZNB20Module.ZNB20,  ::Type{PainterQB.ZNB20Module.DisplayUpdate})    SYSTEM:DISPLAY:UPDATE  inspect(ins::PainterQB.ZNB20Module.ZNB20,  ::Type{PainterQB.ZNB20Module.SweepTime})    SENSE#:SWEEP:TIME  inspect(ins::PainterQB.ZNB20Module.ZNB20,  ::Type{PainterQB.ZNB20Module.SweepTime},  ch::Int64)    SENSE#:SWEEP:TIME  inspect(ins::PainterQB.ZNB20Module.ZNB20,  ::Type{PainterQB.ZNB20Module.Window},  win::Int64)   Determines if a window exists, by window number. See  lswindow .  inspect(ins::PainterQB.ZNB20Module.ZNB20,  ::Type{PainterQB.ZNB20Module.Window},  wname::AbstractString)   Determines if a window exists, by window name. See  lswindow .  lswindows(ins::PainterQB.ZNB20Module.ZNB20)    DISPLAY:CATALOG?", 
            "title": "Methods [Internal]"
        }, 
        {
            "location": "/api/api/#module-painterqbe8257dmodule", 
            "text": "", 
            "title": "MODULE: PainterQB.E8257DModule"
        }, 
        {
            "location": "/api/api/#functions-exported", 
            "text": "PainterQB.E8257DModule.cumulativeattenuatorswitches   Returns the number of attenuator switching events over the instrument lifetime.  PainterQB.E8257DModule.cumulativeontime   Returns the cumulative on-time over the instrument lifetime.  PainterQB.E8257DModule.cumulativepowerons   Returns the number of power on events over the instrument lifetime.  PainterQB.E8257DModule.revision   Reports the revision of the E8257D.  PainterQB.options   Reports the options available for the given E8257D.", 
            "title": "Functions [Exported]"
        }, 
        {
            "location": "/api/api/#types-exported_3", 
            "text": "PainterQB.E8257DModule.ALC   Boolean state of the ALC.  PainterQB.E8257DModule.ALCBandwidth   ALC bandwidth.  PainterQB.E8257DModule.ALCBandwidthAuto   Boolean state for automatic selection of the ALC bandwidth.  PainterQB.E8257DModule.ALCLevel   Level of the ALC when the attenuator hold is active.  PainterQB.E8257DModule.AttenuatorAuto   Boolean state for automatic operation of the attenuator.  PainterQB.E8257DModule.E8257D   Concrete type representing an E8257D.  PainterQB.E8257DModule.FlatnessCorrection   Boolean state for flatness correction.  PainterQB.E8257DModule.FrequencyReference   Boolean state of the frequency reference level.  PainterQB.E8257DModule.FrequencyReferenceLevel   Reference level for configuring/inspecting frequency.  PainterQB.E8257DModule.FrequencyStep   Step size for a frequency sweep.  PainterQB.E8257DModule.OutputBlanking   Boolean state for the output blanking.  PainterQB.E8257DModule.OutputBlankingAuto   Boolean state for automatic blanking of the output.  PainterQB.E8257DModule.OutputSettled   Has the output settled?  PainterQB.E8257DModule.PowerLimit   RF output power limit.  PainterQB.E8257DModule.PowerLimitAdjustable   Boolean for whether or not the RF output power limit can be adjusted.  PainterQB.E8257DModule.PowerReference   Boolean state of the power reference level.  PainterQB.E8257DModule.PowerReferenceLevel   Reference level for configuring/inspecting power.  PainterQB.E8257DModule.PowerStart   Start power in a sweep.  PainterQB.E8257DModule.PowerStep   Step size for a power sweep.  PainterQB.E8257DModule.PowerStop   Stop power in a sweep.", 
            "title": "Types [Exported]"
        }, 
        {
            "location": "/api/api/#methods-internal_3", 
            "text": "generate_configure{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty{T}}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty{T}})   This method generates the following method in the module where  generate_configure{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty{T}}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty{T}},  ::Type{PainterQB.NoArgs})   This method generates the following method in the module where  generate_configure{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty{T}}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty{T}},  returntype...)   This method generates the following method in the module where  generate_handlers{T :PainterQB.Instrument}(insType::Type{T :PainterQB.Instrument},  responseDict::Dict{K, V})   Each instrument can have a  responseDict . For each setting of the instrument,  generate_inspect{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty{T}}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty{T}},  ::Type{PainterQB.NoArgs})   This method does/returns nothing.  generate_inspect{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty{T}}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty{T}},  returntype...)   This method will  generate_properties{S :PainterQB.InstrumentProperty{T}}(subtype::Symbol,  supertype::Type{S :PainterQB.InstrumentProperty{T}})   Creates and exports immutable singleton subtypes.", 
            "title": "Methods [Internal]"
        }, 
        {
            "location": "/api/api/#module-painterqbawg5014cmodule", 
            "text": "", 
            "title": "MODULE: PainterQB.AWG5014CModule"
        }, 
        {
            "location": "/api/api/#functions-exported_1", 
            "text": "PainterQB.AWG5014CModule.applicationstate   Is an application running?  PainterQB.AWG5014CModule.clearwaveforms   Clear waveforms from all channels.  PainterQB.AWG5014CModule.deletewaveform   Delete a waveform by name.  PainterQB.AWG5014CModule.load_awg_settings   Load an AWG settings file.  PainterQB.AWG5014CModule.newwaveform   Create a new waveform by name, number of points, and waveform type.  PainterQB.AWG5014CModule.normalizewaveform   Normalize a waveform.  PainterQB.AWG5014CModule.pullfrom_awg   Pull data from the AWG, performing checks and generating errors as appropriate.  PainterQB.AWG5014CModule.pushto_awg   Push waveform data to the AWG, performing checks and generating errors as appropriate.  PainterQB.AWG5014CModule.resamplewaveform   Resample a waveform.  PainterQB.AWG5014CModule.runapplication   Run an application, e.g. SerialXpress  PainterQB.AWG5014CModule.save_awg_settings   Save an AWG settings file.  PainterQB.AWG5014CModule.validate   Validates data to be pushed to the AWG to check for internal consistency  PainterQB.AWG5014CModule.waveform   Uses Julia style indexing (begins at 1) to retrieve the name of a waveform  PainterQB.AWG5014CModule.waveformexists   Does a waveform identified by  name  exist?  PainterQB.AWG5014CModule.waveformispredefined   Returns whether or not a waveform is predefined (comes with instrument).  PainterQB.AWG5014CModule.waveformlength   Returns the length of a waveform.  PainterQB.AWG5014CModule.waveformtimestamp   Return the timestamp for when a waveform was last updated.  PainterQB.AWG5014CModule.waveformtype   Returns the type of the waveform. The AWG hardware", 
            "title": "Functions [Exported]"
        }, 
        {
            "location": "/api/api/#types-exported_4", 
            "text": "PainterQB.AWG5014CModule.AWG5014C   Concrete type representing an AWG5014C.  PainterQB.AWG5014CModule.AWG5014CData   Type for storing waveform data (including markers) in Float32 format.  PainterQB.AWG5014CModule.Amplitude   Amplitude for a given channel.  PainterQB.AWG5014CModule.AnalogOutputDelay   Analog output delay for a given channel.  PainterQB.AWG5014CModule.ChannelOutput   Boolean state of the output for a given channel.  PainterQB.AWG5014CModule.DCOutput   Boolean state of the DC output for a given channel (bottom-right of AWG).  PainterQB.AWG5014CModule.DCOutputLevel   DC output level for a given channel.  PainterQB.AWG5014CModule.EventImpedance   Event input impedance may be 50 Ohm or 1 kOhm.  PainterQB.AWG5014CModule.EventSlope   Event may fire on a rising or falling slope.  PainterQB.AWG5014CModule.EventTiming   Events may occur synchronously or asynchronously.  PainterQB.AWG5014CModule.ExtInputAddsToOutput   Add the signal from an external input to the given channel output.  PainterQB.AWG5014CModule.ExtOscDividerRate   Divider rate of the external oscillator; must be a power of 2 (1 ok).  PainterQB.AWG5014CModule.MarkerDelay   Marker delay for a given channel and marker. Marker can be 1 or 2.  PainterQB.AWG5014CModule.OutputFilterFrequency   Low-pass filter frequency for the output. INF = 9.9e37  PainterQB.AWG5014CModule.RefOscFrequency   Reference oscillator frequency.  PainterQB.AWG5014CModule.RefOscMultiplier   Reference oscillator multiplier.  PainterQB.AWG5014CModule.RepRate   Repetition rate (frequency of waveform). Changing this will change the  PainterQB.AWG5014CModule.RepRateHeld   Boolean hold state of the repetition rate. If held, the repetition rate will  PainterQB.AWG5014CModule.SCPIVersion   The SCPI version of the AWG.  PainterQB.AWG5014CModule.SequencerEventJumpTarget   Target index for the sequencer event jump operation.  PainterQB.AWG5014CModule.SequencerGOTOState   Boolean GOTO state of the sequencer.  PainterQB.AWG5014CModule.SequencerGOTOTarget   Target index for the GOTO command of the sequencer.  PainterQB.AWG5014CModule.SequencerInfiniteLoop   Boolean state of infinite loop on a sequencer element.  PainterQB.AWG5014CModule.SequencerLength   Length of the sequence. Can be destructive to existing sequences.  PainterQB.AWG5014CModule.SequencerLoopCount   Loop count of the sequencer, from 1 to 65536. Ignored if infinite loop.  PainterQB.AWG5014CModule.SequencerPosition   Current sequencer position.  PainterQB.AWG5014CModule.SequencerType   Sequencer may be hardware or software.  PainterQB.AWG5014CModule.TriggerMode   Trigger engine may be triggered, continuously firing, gated, or sequenced.  PainterQB.AWG5014CModule.TriggerTimer   Internal trigger rate.  PainterQB.AWG5014CModule.VoltageOffset   Offset voltage for a given channel.  PainterQB.AWG5014CModule.WaitingForTrigger   When inspected, will report if the instrument is waiting for a trigger.  PainterQB.AWG5014CModule.Waveform   Name of a waveform loaded into a given channel.  PainterQB.AWG5014CModule.WaveformType   Waveform type may be integer or real.  PainterQB.AWG5014CModule.WavelistLength   The number of waveforms stored in the AWG.", 
            "title": "Types [Exported]"
        }, 
        {
            "location": "/api/api/#macros-exported", 
            "text": "@allch(x::Expr)   Macro for performing an operation on every channel,", 
            "title": "Macros [Exported]"
        }, 
        {
            "location": "/api/api/#functions-internal", 
            "text": "PainterQB.AWG5014CModule.nbytes   Returns the number of bytes per sample for a a given waveform type.  PainterQB.AWG5014CModule.pulllowlevel   Takes care of the dirty work in pulling data from the AWG.  PainterQB.AWG5014CModule.pushlowlevel   Takes care of the dirty work in pushing the data to the AWG.", 
            "title": "Functions [Internal]"
        }, 
        {
            "location": "/api/api/#methods-internal_4", 
            "text": "configure(ins::PainterQB.AWG5014CModule.AWG5014C,  ::Type{PainterQB.AWG5014CModule.Amplitude},  ampl::Real,  ch::Integer)   Configure Vpp for a given channel, between 0.05 V and 2 V.  configure(ins::PainterQB.AWG5014CModule.AWG5014C,  ::Type{PainterQB.AWG5014CModule.Waveform},  name::ASCIIString,  ch::Integer)   Configure the waveform by name for a given channel.  configure(ins::PainterQB.AWG5014CModule.AWG5014C,  ::Type{PainterQB.Output},  on::Bool)   Configure the global analog output state of the AWG.  configure(ins::PainterQB.AWG5014CModule.AWG5014C,  ::Type{PainterQB.Phase},  phase::Real,  ch::Integer)   Set the output phase in degrees for a given channel.  configure(ins::PainterQB.AWG5014CModule.AWG5014C,  ::Type{PainterQB.SampleRate},  rate::Real)   Configure the sample rate in Hz between 10 MHz and 10 GHz.  generate_configure{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty{T}}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty{T}})   This method generates the following method in the module where  generate_configure{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty{T}}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty{T}},  ::Type{PainterQB.NoArgs})   This method generates the following method in the module where  generate_configure{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty{T}}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty{T}},  returntype...)   This method generates the following method in the module where  generate_handlers{T :PainterQB.Instrument}(insType::Type{T :PainterQB.Instrument},  responseDict::Dict{K, V})   Each instrument can have a  responseDict . For each setting of the instrument,  generate_inspect{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty{T}}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty{T}},  ::Type{PainterQB.NoArgs})   This method does/returns nothing.  generate_inspect{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty{T}}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty{T}},  returntype...)   This method will  generate_properties{S :PainterQB.InstrumentProperty{T}}(subtype::Symbol,  supertype::Type{S :PainterQB.InstrumentProperty{T}})   Creates and exports immutable singleton subtypes.  inspect(ins::PainterQB.AWG5014CModule.AWG5014C,  ::Type{PainterQB.AWG5014CModule.Amplitude},  ch::Integer)   Inspect Vpp for a given channel.  inspect(ins::PainterQB.AWG5014CModule.AWG5014C,  ::Type{PainterQB.AWG5014CModule.SequencerType})   Returns current sequencer type.  inspect(ins::PainterQB.AWG5014CModule.AWG5014C,  ::Type{PainterQB.AWG5014CModule.WaitingForTrigger})   Inspect whether or not the instrument is waiting for a trigger.  inspect(ins::PainterQB.AWG5014CModule.AWG5014C,  ::Type{PainterQB.AWG5014CModule.Waveform},  ch::Integer)   Inspect the waveform name for a given channel.  inspect(ins::PainterQB.AWG5014CModule.AWG5014C,  ::Type{PainterQB.Output})   Inspect the global analog output state of the AWG.  inspect(ins::PainterQB.AWG5014CModule.AWG5014C,  ::Type{PainterQB.Phase},  ch::Integer)   Get the output phase in degrees for a given channel.  inspect(ins::PainterQB.AWG5014CModule.AWG5014C,  ::Type{PainterQB.SampleRate})   Get the sample rate in Hz. Output rate = sample rate / number of points.", 
            "title": "Methods [Internal]"
        }, 
        {
            "location": "/api/api/#globals-internal_1", 
            "text": "byteLimit   Maximum number of bytes that may be sent using the SCPI command WLIS:WAV:DATA.  exceptions   Exception dictionary mapping signed integers to error strings.  maximumValue   Constant used for synthesizing/interpreting waveforms of integer type.  minimumValue   Constant used for synthesizing/interpreting waveforms of integer type.  noError   Internal AWG code meaning no errors.  offsetPlusPPOver2   Constant used for synthesizing/interpreting waveforms of integer type.  offsetValue   Constant used for synthesizing/interpreting waveforms of integer type.", 
            "title": "Globals [Internal]"
        }, 
        {
            "location": "/api/api/#module-painterqbalazarmodule", 
            "text": "", 
            "title": "MODULE: PainterQB.AlazarModule"
        }, 
        {
            "location": "/api/api/#functions-exported_2", 
            "text": "PainterQB.AlazarModule.abort   Aborts an acquisition. Must be called in the case of a DSP acquisition; somehow  PainterQB.AlazarModule.before_async_read   Performs setup for asynchronous acquisitions. Should be called after  PainterQB.AlazarModule.bufferarray   Given and  InstrumentAlazar  and  AlazarMode , returns a  DMABufferArray  PainterQB.AlazarModule.buffersizing   Given an  InstrumentAlazar  and an  AlazarMode , this will tweak parameters  PainterQB.AlazarModule.fft_fpga_setup   If necessary, performs  AlazarFFTSetup , which should be called before  PainterQB.AlazarModule.recordsizing   Calls C function  AlazarSetRecordSize  if necessary, given an  InstrumentAlazar  PainterQB.AlazarModule.wait_buffer   Waits for a buffer to be processed (or a timeout to elapse).", 
            "title": "Functions [Exported]"
        }, 
        {
            "location": "/api/api/#methods-exported_2", 
            "text": "busy(a::PainterQB.AlazarModule.InstrumentAlazar)   Returns whether or not the  InstrumentAlazar  is busy (Bool).  configure(a::PainterQB.AlazarModule.AlazarATS9360,  ::Type{PainterQB.SampleRate},  rate::Real)   Configure the sample rate to any multiple of 1 MHz (within 300 MHz and 1.8 GHz)  configure(a::PainterQB.AlazarModule.InstrumentAlazar,  ::Type{PainterQB.AlazarModule.AuxSoftwareTriggerEnable},  b::Bool)   If an AUX IO output mode has been configured, then this will configure  configure(a::PainterQB.AlazarModule.InstrumentAlazar,  ::Type{PainterQB.AlazarModule.LED},  ledState::Bool)   Configures the LED on the digitizer card chassis.  configure(a::PainterQB.AlazarModule.InstrumentAlazar,  ::Type{PainterQB.AlazarModule.RecordCount},  count)   Wrapper for C function  AlazarSetRecordCount . See the Alazar API.  configure(a::PainterQB.AlazarModule.InstrumentAlazar,  ::Type{PainterQB.AlazarModule.Sleep},  sleepState)   Configures the sleep state of the digitizer card.  configure(a::PainterQB.AlazarModule.InstrumentAlazar,  ::Type{PainterQB.AlazarModule.TriggerDelaySamples},  delay_samples)   Configure how many samples to wait after receiving a trigger event before capturing  configure(a::PainterQB.AlazarModule.InstrumentAlazar,  ::Type{PainterQB.AlazarModule.TriggerTimeoutS},  timeout_s)   Wrapper for C function  AlazarSetTriggerTimeOut , except we take seconds here  configure(a::PainterQB.AlazarModule.InstrumentAlazar,  ::Type{PainterQB.AlazarModule.TriggerTimeoutTicks},  ticks)   Wrapper for C function  AlazarSetTriggerTimeOut .  configure(a::PainterQB.AlazarModule.InstrumentAlazar,  ::Type{PainterQB.TriggerLevel},  levelJ,  levelK)   Configure the trigger level for trigger engine J and K. This should be an  configure(a::PainterQB.AlazarModule.InstrumentAlazar,  aux::Type{PainterQB.AlazarModule.AuxDigitalInput})   Configure a digitizer's AUX IO to act as a digital input.  configure(a::PainterQB.AlazarModule.InstrumentAlazar,  aux::Type{PainterQB.AlazarModule.AuxDigitalOutput},  level::Integer)   Configure a digitizer's AUX IO port to act as a general purpose digital output.  configure(a::PainterQB.AlazarModule.InstrumentAlazar,  aux::Type{PainterQB.AlazarModule.AuxOutputPacer},  divider::Integer)   Configure a digitizer's AUX IO port to output the sample clock, divided by an integer.  configure(a::PainterQB.AlazarModule.InstrumentAlazar,  aux::Type{PainterQB.AlazarModule.AuxOutputTrigger})   Configure a digitizer's AUX IO to output a trigger signal synced to the sample clock.  configure(a::PainterQB.AlazarModule.InstrumentAlazar,  ch::Type{PainterQB.AlazarModule.BothChannels})   Configures acquisition from both channels, simultaneously.  configure{S :PainterQB.AlazarModule.AlazarDataPacking}(a::PainterQB.AlazarModule.InstrumentAlazar,  ::Type{PainterQB.AlazarModule.AlazarDataPacking},  pack::Type{S :PainterQB.AlazarModule.AlazarDataPacking},  ch::Type{PainterQB.AlazarModule.BothChannels})   Configures the data packing mode for both channels.  configure{S :PainterQB.AlazarModule.AlazarDataPacking}(a::PainterQB.AlazarModule.InstrumentAlazar,  ::Type{PainterQB.AlazarModule.AlazarDataPacking},  pack::Type{S :PainterQB.AlazarModule.AlazarDataPacking},  ch::Type{PainterQB.AlazarModule.ChannelA})   Configures the data packing mode for channel A.  configure{S :PainterQB.AlazarModule.AlazarDataPacking}(a::PainterQB.AlazarModule.InstrumentAlazar,  ::Type{PainterQB.AlazarModule.AlazarDataPacking},  pack::Type{S :PainterQB.AlazarModule.AlazarDataPacking},  ch::Type{PainterQB.AlazarModule.ChannelB})   Configures the data packing mode for channel B.  configure{S :PainterQB.AlazarModule.DSPWindow{T}, T :PainterQB.AlazarModule.DSPWindow{T}}(a::PainterQB.AlazarModule.AlazarATS9360,  re::Type{S :PainterQB.AlazarModule.DSPWindow{T}},  im::Type{T :PainterQB.AlazarModule.DSPWindow{T}})   Configures the DSP windows.  AlazarFFTSetWindowFunction  is called towards  configure{S :PainterQB.TriggerSlope, T :PainterQB.TriggerSlope}(a::PainterQB.AlazarModule.InstrumentAlazar,  slopeJ::Type{S :PainterQB.TriggerSlope},  slopeK::Type{T :PainterQB.TriggerSlope})   Configures whether to trigger on a rising or falling slope, for engine J and K.  configure{S :PainterQB.TriggerSource, T :PainterQB.TriggerSource}(a::PainterQB.AlazarModule.InstrumentAlazar,  sourceJ::Type{S :PainterQB.TriggerSource},  sourceK::Type{T :PainterQB.TriggerSource})   Configure the trigger source for trigger engine J and K.  configure{T :PainterQB.AlazarModule.AlazarChannel}(a::PainterQB.AlazarModule.InstrumentAlazar,  ch::Type{T :PainterQB.AlazarModule.AlazarChannel})   Configures the acquisition channel.  configure{T :PainterQB.AlazarModule.AlazarTimestampReset}(a::PainterQB.AlazarModule.InstrumentAlazar,  t::Type{T :PainterQB.AlazarModule.AlazarTimestampReset})   Configures timestamp reset. From the Alazar API, the choices are  configure{T :PainterQB.AlazarModule.AlazarTriggerEngine}(a::PainterQB.AlazarModule.InstrumentAlazar,  engine::Type{T :PainterQB.AlazarModule.AlazarTriggerEngine})   Configures the trigger engines, e.g. TriggerOnJ, TriggerOnJAndNotK, etc.  configure{T :PainterQB.AlazarModule.AlazarTriggerRange}(a::PainterQB.AlazarModule.AlazarATS9360,  range::Type{T :PainterQB.AlazarModule.AlazarTriggerRange})   Does nothing but display info telling you that this parameter cannot be changed  configure{T :PainterQB.AlazarModule.AlazarTriggerRange}(a::PainterQB.AlazarModule.InstrumentAlazar,  range::Type{T :PainterQB.AlazarModule.AlazarTriggerRange})   Configure the external trigger range.  configure{T :PainterQB.ClockSlope}(a::PainterQB.AlazarModule.InstrumentAlazar,  slope::Type{T :PainterQB.ClockSlope})   Configures whether the clock ticks on a rising or falling slope.  configure{T :PainterQB.Coupling}(a::PainterQB.AlazarModule.AlazarATS9360,  coupling::Type{T :PainterQB.Coupling})   Does nothing but display info telling you that this parameter cannot be changed  configure{T :PainterQB.Coupling}(a::PainterQB.AlazarModule.InstrumentAlazar,  coupling::Type{T :PainterQB.Coupling})   Configure the external trigger coupling.  configure{T :PainterQB.SampleRate}(a::PainterQB.AlazarModule.InstrumentAlazar,  rate::Type{T :PainterQB.SampleRate})   Configures one of the preset sample rates derived from the internal clock.  configure{T :PainterQB.TriggerSlope}(a::PainterQB.AlazarModule.InstrumentAlazar,  aux::Type{PainterQB.AlazarModule.AuxInputTriggerEnable},  trigSlope::Type{T :PainterQB.TriggerSlope})   Configure a digitizer's AUX IO port to use the edge of a pulse as an AutoDMA  dsp_getinfo(dspModule::PainterQB.AlazarModule.DSPModule)   Returns a DSPModuleInfo object that describes a DSPModule.  dsp_getmodulehandles(a::PainterQB.AlazarModule.InstrumentAlazar)   Returns an Array of  dsp_module_handle .  dsp_modules(a::PainterQB.AlazarModule.InstrumentAlazar)   Returns an array of  DSPModule .  dsp_num_modules(a::PainterQB.AlazarModule.InstrumentAlazar)   Returns the number of  DSPModule .  forcetrigger(a::PainterQB.AlazarModule.InstrumentAlazar)   Force a software trigger.  forcetriggerenable(a::PainterQB.AlazarModule.InstrumentAlazar)   Force a software \"trigger enable.\" This involves the AUX I/O connector (see  inputcontrol(a::PainterQB.AlazarModule.InstrumentAlazar,  channel,  coupling,  inputRange,  impedance)   Controls coupling, input range, and impedance for applicable digitizer cards.  inspect(a::PainterQB.AlazarModule.AlazarATS9360,  ::Type{PainterQB.AlazarModule.BufferAlignment})   Returns the buffer alignment requirement (samples / record / channel).  inspect(a::PainterQB.AlazarModule.AlazarATS9360,  ::Type{PainterQB.AlazarModule.MaxBufferBytes})   Maximum number of bytes for a given DMA buffer.  inspect(a::PainterQB.AlazarModule.AlazarATS9360,  ::Type{PainterQB.AlazarModule.MaxFFTSamples})   Maximum number of samples in an FPGA-based FFT. Can be obtained from  dsp_getinfo  inspect(a::PainterQB.AlazarModule.AlazarATS9360,  ::Type{PainterQB.AlazarModule.MinFFTSamples})   Minimum number of samples in an FPGA-based FFT. Set by the minimum record size.  inspect(a::PainterQB.AlazarModule.AlazarATS9360,  ::Type{PainterQB.AlazarModule.MinSamplesPerRecord})   Minimum samples per record. Observed behavior deviates from Table 8 of the  inspect(a::PainterQB.AlazarModule.AlazarATS9360,  ::Type{PainterQB.AlazarModule.PretriggerAlignment})   Returns the pretrigger alignment requirement (samples / record / channel).  inspect(a::PainterQB.AlazarModule.InstrumentAlazar,  ::Type{PainterQB.AlazarModule.AlazarAux})   Inspect the AUX IO mode.  inspect(a::PainterQB.AlazarModule.InstrumentAlazar,  ::Type{PainterQB.AlazarModule.AlazarChannel})   Returns which channel(s) will be acquired.  inspect(a::PainterQB.AlazarModule.InstrumentAlazar,  ::Type{PainterQB.AlazarModule.ChannelCount})   Returns the number of channels to acquire.  inspect(a::PainterQB.AlazarModule.InstrumentAlazar,  ::Type{PainterQB.AlazarModule.SampleMemoryPerChannel})   Returns the memory per channel in units of samples.  inspect(a::PainterQB.AlazarModule.InstrumentAlazar,  ::Type{PainterQB.SampleRate})   Inspect the sample rate. As currently programmed, does not distinguish  inspect{T :PainterQB.AlazarModule.AlazarChannel}(a::PainterQB.AlazarModule.InstrumentAlazar,  ::Type{PainterQB.AlazarModule.AlazarDataPacking},  ch::Type{T :PainterQB.AlazarModule.AlazarChannel})   Inspect the data packing mode for a given channel.  measure(ch::PainterQB.AlazarModule.AlazarResponse{T})   Largely generic method for measuring  AlazarResponse . Can be considered a  measure(ch::PainterQB.AlazarModule.IQSoftwareResponse{T})   Assume two-channel IQ FFT acquisition.  post_async_buffer(a::PainterQB.AlazarModule.InstrumentAlazar,  buffer,  bufferLength)   Post an asynchronous buffer to the digitizer for use in an acquisition.  set_parameter(a::PainterQB.AlazarModule.InstrumentAlazar,  channelId,  parameterId,  value)   Julia wrapper for C function AlazarSetParameter, with error checking.  set_parameter_ul(a::PainterQB.AlazarModule.InstrumentAlazar,  channelId,  parameterId,  value)   Julia wrapper for C function AlazarSetParameterUL, with error checking.  set_triggeroperation(a::PainterQB.AlazarModule.InstrumentAlazar,  args...)   Configure the trigger operation. Usually not called directly.  startcapture(a::PainterQB.AlazarModule.InstrumentAlazar)   Should be called after  before_async_read  has been called and buffers are posted.  triggered(a::PainterQB.AlazarModule.InstrumentAlazar)   Reports whether or not the digitizer has been triggered.", 
            "title": "Methods [Exported]"
        }, 
        {
            "location": "/api/api/#types-exported_5", 
            "text": "PainterQB.AlazarModule.AlazarATS9360   Concrete InstrumentAlazar subtype representing an ATS9360 digitizer.  PainterQB.AlazarModule.DSPModule   Represents a DSP module of an AlazarTech digitizer.  PainterQB.AlazarModule.DSPModuleInfo   Encapsulates DSP module information: type, version, and max record length.  PainterQB.AlazarModule.DSPWindow{T}   Abstract parametric type representing a windowing function for DSP.  PainterQB.AlazarModule.InstrumentAlazar   Abstract type representing an AlazarTech digitizer.  PainterQB.AlazarModule.WindowBartlett{T}   Bartlett window. Implemented in AlazarDSP.  PainterQB.AlazarModule.WindowBlackmanHarris{T}   Blackman-Harris window. Implemented in AlazarDSP.  PainterQB.AlazarModule.WindowBlackman{T}   Blackman window. Implemented in AlazarDSP.  PainterQB.AlazarModule.WindowHamming{T}   Hamming window. Implemented in AlazarDSP.  PainterQB.AlazarModule.WindowHanning{T}   Hanning window. Implemented in AlazarDSP.  PainterQB.AlazarModule.WindowNone{T}   Flat window (ones). Implemented in AlazarDSP.  PainterQB.AlazarModule.WindowZeroes{T}   Flat window (zeroes!).", 
            "title": "Types [Exported]"
        }, 
        {
            "location": "/api/api/#typealiass-exported", 
            "text": "WindowOnes   Type alias for  WindowNone .", 
            "title": "Typealiass [Exported]"
        }, 
        {
            "location": "/api/api/#globals-exported_1", 
            "text": "inf_records   Alazar API representation of an infinite number of records.", 
            "title": "Globals [Exported]"
        }, 
        {
            "location": "/api/api/#functions-internal_1", 
            "text": "PainterQB.AlazarModule.adma   Returns the asynchronous DMA flags for a given  AlazarMode . These are  PainterQB.AlazarModule.dsp   Given a DSPWindow type, this returns the constant needed to use the AlazarDSP  PainterQB.AlazarModule.generatewindowfunction   Given a  DSPWindow , samples per record, and padding samples, this will prepare  PainterQB.AlazarModule.initmodes   Should be called at the beginning of a measure method to initialize the  PainterQB.AlazarModule.postprocess   Arrange for reinterpretation or conversion of the data stored in the  PainterQB.AlazarModule.pretriggersamples   Given an  AlazarMode , returns the number of pre-trigger samples.  PainterQB.AlazarModule.processing   Specifies what to do with the buffers during measurement based on the response type.  PainterQB.AlazarModule.rec_acq_param   Returns the value to pass as the recordsPerAcquisition parameter in the C  PainterQB.AlazarModule.records_per_acquisition   Given an  InstrumentAlazar  and  AlazarMode , return the records per acquisition.  PainterQB.AlazarModule.records_per_buffer   Given an  InstrumentAlazar  and  AlazarMode , return the records per buffer.  PainterQB.AlazarModule.samples_per_buffer_measured   Given an  InstrumentAlazar  and  AlazarMode , return the samples per buffer  PainterQB.AlazarModule.samples_per_buffer_returned   Given an  InstrumentAlazar  and  AlazarMode , return the samples per buffer  PainterQB.AlazarModule.samples_per_record_measured   Given an  InstrumentAlazar  and  AlazarMode , return the samples per record  PainterQB.AlazarModule.samples_per_record_returned   Given an  InstrumentAlazar  and  AlazarMode , return the samples per record", 
            "title": "Functions [Internal]"
        }, 
        {
            "location": "/api/api/#methods-internal_5", 
            "text": "auxmode(m::UInt32,  b::Bool)   Masks an AUX IO mode parameter to specify AUX IO software trigger enable.  bits_per_sample(a::PainterQB.AlazarModule.AlazarATS9360)   Hard coded to return 0x0c. May need to change if we want to play with data packing.  bits_per_sample(a::PainterQB.AlazarModule.InstrumentAlazar)   Returns the number of bits per sample. Queries the digitizer directly via  boardhandle(sysid::Integer,  boardid::Integer)   Return a handle to an Alazar digitizer given a system ID and board ID.  boardkind(handle::UInt32)   Returns the kind of digitizer; corresponds to a constant in AlazarConstants.jl  bytes_per_sample(a::PainterQB.AlazarModule.AlazarATS9360)   Hard coded to return 2. May need to change if we want to play with data packing.  bytes_per_sample(a::PainterQB.AlazarModule.InstrumentAlazar)   Returns the number of bytes per sample. Calls  bitspersample  and does ceiling  generate_configure{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty{T}}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty{T}})   This method generates the following method in the module where  generate_configure{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty{T}}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty{T}},  ::Type{PainterQB.NoArgs})   This method generates the following method in the module where  generate_configure{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty{T}}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty{T}},  returntype...)   This method generates the following method in the module where  generate_handlers{T :PainterQB.Instrument}(insType::Type{T :PainterQB.Instrument},  responseDict::Dict{K, V})   Each instrument can have a  responseDict . For each setting of the instrument,  generate_inspect{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty{T}}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty{T}},  ::Type{PainterQB.NoArgs})   This method does/returns nothing.  generate_inspect{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty{T}}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty{T}},  returntype...)   This method will  generate_properties{S :PainterQB.InstrumentProperty{T}}(subtype::Symbol,  supertype::Type{S :PainterQB.InstrumentProperty{T}})   Creates and exports immutable singleton subtypes.  iqfft(sam_per_buf::Int64,  buf_completed::Int64,  rec_per_buf::Int64,  backing::SharedArray{T, N},  fft_array::SharedArray{T, N})   Convert and copy  scaling{T :AbstractArray{T, N}}(resp::PainterQB.AlazarModule.FFTResponse{T :AbstractArray{T, N}})   Returns the axis scaling for an FFT response.  scaling{T :AbstractArray{T, N}}(resp::PainterQB.AlazarModule.FFTResponse{T :AbstractArray{T, N}},  whichaxis::Integer)   Returns the axis scaling for an FFT response.  tofloat!(sam_per_buf::Int64,  buf_completed::Int64,  backing::SharedArray{T, N})   Arrange multithreaded conversion of the Alazar 12-bit integer format to 16-bit  triglevel(a::PainterQB.AlazarModule.AlazarATS9360,  x)   Returns a UInt32 in the range 0--255 given a desired trigger level in Volts.", 
            "title": "Methods [Internal]"
        }, 
        {
            "location": "/api/api/#types-internal", 
            "text": "PainterQB.AlazarModule.AlazarATS9440   Abstract type; not implemented.", 
            "title": "Types [Internal]"
        }, 
        {
            "location": "/api/api/#macros-internal", 
            "text": "@eh2(expr)   Takes an Alazar API call and brackets it with some error checking.", 
            "title": "Macros [Internal]"
        }, 
        {
            "location": "/api/api/#globals-internal_2", 
            "text": "lib_opened   Flag indicating whether the AlazarTech shared library has been opened.", 
            "title": "Globals [Internal]"
        }, 
        {
            "location": "/api/PainterQB/", 
            "text": "PainterQB\n\n\nMethods [Exported]\n\n\n\n\n\n\naborttrigger(ins::PainterQB.InstrumentVISA) \n\u00b6\n\n\nAbort triggering with ABOR.\n\n\nsource:\n\n\nPainterQB\\src\\VISA.jl:122\n\n\n\n\n\n\nask(ins::PainterQB.InstrumentVISA,  msg::ASCIIString) \n\u00b6\n\n\nIdiomatic \"write and read available\" function with optional delay.\n\n\nsource:\n\n\nPainterQB\\src\\VISA.jl:73\n\n\n\n\n\n\nask(ins::PainterQB.InstrumentVISA,  msg::ASCIIString,  delay::Real) \n\u00b6\n\n\nIdiomatic \"write and read available\" function with optional delay.\n\n\nsource:\n\n\nPainterQB\\src\\VISA.jl:73\n\n\n\n\n\n\nbinblockreadavailable(ins::PainterQB.InstrumentVISA) \n\u00b6\n\n\nRead an entire block of bytes with properly formatted IEEE header.\n\n\nsource:\n\n\nPainterQB\\src\\VISA.jl:102\n\n\n\n\n\n\nbinblockwrite(ins::PainterQB.InstrumentVISA,  message::Union{ASCIIString, Array{UInt8, 1}},  data::Array{UInt8, 1}) \n\u00b6\n\n\nWrite an IEEE header block followed by an arbitary sequency of bytes and the terminator.\n\n\nsource:\n\n\nPainterQB\\src\\VISA.jl:97\n\n\n\n\n\n\nclearregisters(ins::PainterQB.InstrumentVISA) \n\u00b6\n\n\nClear registers with *CLS.\n\n\nsource:\n\n\nPainterQB\\src\\VISA.jl:116\n\n\n\n\n\n\nfindresources() \n\u00b6\n\n\nFinds VISA resources to which we can connect. Doesn't seem to find ethernet instruments.\n\n\nsource:\n\n\nPainterQB\\src\\VISA.jl:41\n\n\n\n\n\n\nfindresources(expr::AbstractString) \n\u00b6\n\n\nFinds VISA resources to which we can connect. Doesn't seem to find ethernet instruments.\n\n\nsource:\n\n\nPainterQB\\src\\VISA.jl:41\n\n\n\n\n\n\ngpib(board,  primary) \n\u00b6\n\n\nReturns a \nviSession\n for the given GPIB board and primary address.\nSee VISA spec for details on what a \nviSession\n is.\n\n\nsource:\n\n\nPainterQB\\src\\VISA.jl:53\n\n\n\n\n\n\ngpib(board,  primary,  secondary) \n\u00b6\n\n\nReturns a \nviSession\n for the given GPIB board, primary, and secondary address.\nSee VISA spec for details on what a \nviSession\n is.\n\n\nsource:\n\n\nPainterQB\\src\\VISA.jl:60\n\n\n\n\n\n\ngpib(primary) \n\u00b6\n\n\nReturns a \nviSession\n for the given GPIB primary address using board 0.\nSee VISA spec for details on what a \nviSession\n is.\n\n\nsource:\n\n\nPainterQB\\src\\VISA.jl:47\n\n\n\n\n\n\nidentify(ins::PainterQB.InstrumentVISA) \n\u00b6\n\n\nAsk the *IDN? command.\n\n\nsource:\n\n\nPainterQB\\src\\VISA.jl:113\n\n\n\n\n\n\ninspect(ins::PainterQB.Instrument,  args::Tuple{Vararg{DataType}}) \n\u00b6\n\n\nAllow inspecting mulitple properties at once.\n\n\nsource:\n\n\nPainterQB\\src\\Definitions.jl:222\n\n\n\n\n\n\ninspect(ins::PainterQB.Instrument,  args::Tuple{Vararg{T}}) \n\u00b6\n\n\nSplat tuples into new inspect commands.\n\n\nsource:\n\n\nPainterQB\\src\\Definitions.jl:218\n\n\n\n\n\n\nmeasure(ch::PainterQB.RandomResponse) \n\u00b6\n\n\nReturns a random number in the unit interval.\n\n\nsource:\n\n\nPainterQB\\src\\sourcemeasure\\Random.jl:8\n\n\n\n\n\n\nmeasure(ch::PainterQB.TimeAResponse) \n\u00b6\n\n\nReturns how many seconds it takes to measure the response field \nch\n holds.\n\n\nsource:\n\n\nPainterQB\\src\\sourcemeasure\\Time.jl:46\n\n\n\n\n\n\nmeasure{T}(ch::PainterQB.AveragingResponse{T}) \n\u00b6\n\n\nMeasures the response held by \nch\n \nn_avg\n times, and returns the average.\n\n\nsource:\n\n\nPainterQB\\src\\sourcemeasure\\Averaging.jl:11\n\n\n\n\n\n\nmeasure{T}(ch::PainterQB.TimerResponse{T}) \n\u00b6\n\n\nReturns how many seconds have elapsed since the timer was initialized or reset.\n\n\nsource:\n\n\nPainterQB\\src\\sourcemeasure\\Time.jl:38\n\n\n\n\n\n\nquoted(str::ASCIIString) \n\u00b6\n\n\nSurround a string in quotation marks.\n\n\nsource:\n\n\nPainterQB\\src\\VISA.jl:130\n\n\n\n\n\n\nread(ins::PainterQB.InstrumentVISA) \n\u00b6\n\n\nRead from an instrument. Strips trailing carriage returns and new lines.\nNote that this function will only read so many characters (buffered).\n\n\nsource:\n\n\nPainterQB\\src\\VISA.jl:83\n\n\n\n\n\n\nreadavailable(ins::PainterQB.InstrumentVISA) \n\u00b6\n\n\nKeep reading from an instrument until the instrument says we are done.\n\n\nsource:\n\n\nPainterQB\\src\\VISA.jl:91\n\n\n\n\n\n\nreset(d::PainterQB.DelayStimulus) \n\u00b6\n\n\nReset the DelayStimulus reference time to now.\n\n\nsource:\n\n\nPainterQB\\src\\sourcemeasure\\Time.jl:11\n\n\n\n\n\n\nreset(d::PainterQB.TimerResponse{T\n:AbstractFloat}) \n\u00b6\n\n\nReset the TimerResponse reference time to now.\n\n\nsource:\n\n\nPainterQB\\src\\sourcemeasure\\Time.jl:33\n\n\n\n\n\n\nreset(ins::PainterQB.InstrumentVISA) \n\u00b6\n\n\nReset with the *RST command.\n\n\nsource:\n\n\nPainterQB\\src\\VISA.jl:110\n\n\n\n\n\n\nsource(ch::PainterQB.DelayStimulus,  val::Real) \n\u00b6\n\n\nWait until \nval\n seconds have elapsed since \nch\n was initialized or reset.\n\n\nsource:\n\n\nPainterQB\\src\\sourcemeasure\\Time.jl:16\n\n\n\n\n\n\nsource(ch::PainterQB.DummyStimulus) \n\u00b6\n\n\nReturns a random number in the unit interval.\n\n\nsource:\n\n\nPainterQB\\src\\sourcemeasure\\Dummy.jl:8\n\n\n\n\n\n\nsource(ch::PainterQB.PropertyStimulus{T\n:PainterQB.InstrumentProperty{Number}},  val::Real) \n\u00b6\n\n\nSourcing a PropertyStimulus configures an InstrumentProperty.\n\n\nsource:\n\n\nPainterQB\\src\\sourcemeasure\\Property.jl:30\n\n\n\n\n\n\nsource(ch::PainterQB.ThreadStimulus,  nw::Int64) \n\u00b6\n\n\nAdds or removes threads to reach the desired number of worker threads.\n\n\nsource:\n\n\nPainterQB\\src\\sourcemeasure\\Thread.jl:32\n\n\n\n\n\n\nsource{T}(ch::PainterQB.ResponseStimulus{T},  val) \n\u00b6\n\n\nSets the field named \n:name\n in the \nResponse\n held by \nch\n to \nval\n.\n\n\nsource:\n\n\nPainterQB\\src\\sourcemeasure\\ResponseStim.jl:22\n\n\n\n\n\n\nsweep{T\n:Real, N}(dep::PainterQB.Response{T\n:Real},  indep::NTuple{N, Tuple{PainterQB.Stimulus, AbstractArray{T, N}}}) \n\u00b6\n\n\nMeasures a response as a function of an arbitrary number of stimuli.\nImplementation: N \nfor\n loops are built around a simple body programmatically,\ngiven N stimuli. The stimuli are sourced at the start of each for loop.\nThe body just measures the response with an optional time delay.\n\n\nsource:\n\n\nPainterQB\\src\\Sweep.jl:24\n\n\n\n\n\n\nsweep{T}(dep::PainterQB.Response{T},  indep::Tuple{PainterQB.Stimulus, AbstractArray{T, N}}...) \n\u00b6\n\n\nThis method is slightly more convenient than the other sweep method\nbut not type stable. The return type depends on the number of arguments.\nIf for some reason this were executed in a tight loop it might be good to\nannotate the return type in the calling function. For most purposes there should\nbe minimal performance penalty.\n\n\nsource:\n\n\nPainterQB\\src\\Sweep.jl:12\n\n\n\n\n\n\ntcpip_instr(ip) \n\u00b6\n\n\nReturns a INSTR \nviSession\n for the given IPv4 address string.\n\n\nsource:\n\n\nPainterQB\\src\\VISA.jl:64\n\n\n\n\n\n\ntcpip_socket(ip,  port) \n\u00b6\n\n\nReturns a raw socket \nviSession\n for the given IPv4 address string.\n\n\nsource:\n\n\nPainterQB\\src\\VISA.jl:67\n\n\n\n\n\n\ntest(ins::PainterQB.InstrumentVISA) \n\u00b6\n\n\nTest with the *TST? command.\n\n\nsource:\n\n\nPainterQB\\src\\VISA.jl:107\n\n\n\n\n\n\ntrigger(ins::PainterQB.InstrumentVISA) \n\u00b6\n\n\nBus trigger with *TRG.\n\n\nsource:\n\n\nPainterQB\\src\\VISA.jl:119\n\n\n\n\n\n\nunquoted(str::ASCIIString) \n\u00b6\n\n\nStrip a string of enclosing quotation marks.\n\n\nsource:\n\n\nPainterQB\\src\\VISA.jl:133\n\n\n\n\n\n\nwait(ins::PainterQB.InstrumentVISA) \n\u00b6\n\n\nWait for completion of a sweep.\n\n\nsource:\n\n\nPainterQB\\src\\VISA.jl:125\n\n\n\n\n\n\nwrite(ins::PainterQB.InstrumentVISA,  msg::ASCIIString) \n\u00b6\n\n\nWrite to an instrument. Appends the instrument's write terminator.\n\n\nsource:\n\n\nPainterQB\\src\\VISA.jl:87\n\n\nTypes [Exported]\n\n\n\n\n\n\nPainterQB.All \n\u00b6\n\n\nThe All type is meant to be dispatched upon and not instantiated.\n\n\nsource:\n\n\nPainterQB\\src\\Definitions.jl:214\n\n\n\n\n\n\nPainterQB.AveragingResponse{T} \n\u00b6\n\n\nResponse that averages other responses. Not clear if this is a good idea yet.\n\n\nsource:\n\n\nPainterQB\\src\\sourcemeasure\\Averaging.jl:4\n\n\n\n\n\n\nPainterQB.ClockSlope \n\u00b6\n\n\nClock may tick on a rising or falling slope.\n\n\nsource:\n\n\nPainterQB\\src\\Definitions.jl:71\n\n\n\n\n\n\nPainterQB.ClockSource \n\u00b6\n\n\nClock source can be internal or external.\n\n\nsource:\n\n\nPainterQB\\src\\Definitions.jl:74\n\n\n\n\n\n\nPainterQB.Coupling \n\u00b6\n\n\nSignals may be AC or DC coupled.\n\n\nsource:\n\n\nPainterQB\\src\\Definitions.jl:77\n\n\n\n\n\n\nPainterQB.DelayStimulus \n\u00b6\n\n\nA stimulus for delaying until time has passed since a reference time t0.\n\n\nsource:\n\n\nPainterQB\\src\\sourcemeasure\\Time.jl:5\n\n\n\n\n\n\nPainterQB.DummyStimulus \n\u00b6\n\n\nRandom number response suitable for testing the measurement code without having\na physical instrument.\n\n\nsource:\n\n\nPainterQB\\src\\sourcemeasure\\Dummy.jl:5\n\n\n\n\n\n\nPainterQB.Frequency \n\u00b6\n\n\nFixed frequency of a sourced signal.\n\n\nsource:\n\n\nPainterQB\\src\\Definitions.jl:106\n\n\n\n\n\n\nPainterQB.FrequencyStart \n\u00b6\n\n\nStart frequency of a fixed range.\n\n\nsource:\n\n\nPainterQB\\src\\Definitions.jl:109\n\n\n\n\n\n\nPainterQB.FrequencyStop \n\u00b6\n\n\nStop frequency of a fixed range.\n\n\nsource:\n\n\nPainterQB\\src\\Definitions.jl:112\n\n\n\n\n\n\nPainterQB.Instrument \n\u00b6\n\n\nAbstract supertype representing an instrument.\n\n\nsource:\n\n\nPainterQB\\src\\Definitions.jl:53\n\n\n\n\n\n\nPainterQB.InstrumentException \n\u00b6\n\n\nException to be thrown by an instrument. Fields include the instrument in error\n\nins::Instrument\n, the error code \nval::Int64\n, and a \nhumanReadable\n Unicode\nstring.\n\n\nsource:\n\n\nPainterQB\\src\\Definitions.jl:131\n\n\n\n\n\n\nPainterQB.InstrumentProperty{T} \n\u00b6\n\n\nAbstract parametric supertype representing communications with an instrument.\n\n\nEach \nabstract\n subtype one level down should represent a logical state of the\ninstrument configuration, e.g. \nTriggerSource\n may be have concrete\nsubtypes \nExternalTrigger\n or \nInternalTrigger\n.\n\n\nTo retrieve what one has to send the AWG from the type signature, we have\ndefined a function \ncode\n.\n\n\nsource:\n\n\nPainterQB\\src\\Definitions.jl:65\n\n\n\n\n\n\nPainterQB.InstrumentVISA \n\u00b6\n\n\nAbstract supertype of all Instruments addressable using a VISA library.\nConcrete types are expected to have fields:\n\n\nvi::ViSession\n\n\nwriteTerminator::ASCIIString\n\n\nsource:\n\n\nPainterQB\\src\\VISA.jl:36\n\n\n\n\n\n\nPainterQB.NoArgs \n\u00b6\n\n\nUsed internally to indicate that a property takes no argument.\n\n\nsource:\n\n\nPainterQB\\src\\Definitions.jl:68\n\n\n\n\n\n\nPainterQB.NumPoints \n\u00b6\n\n\nNumber of points per sweep.\n\n\nsource:\n\n\nPainterQB\\src\\Definitions.jl:115\n\n\n\n\n\n\nPainterQB.OscillatorSource \n\u00b6\n\n\nOscillator source can be internal or external.\n\n\nsource:\n\n\nPainterQB\\src\\Definitions.jl:82\n\n\n\n\n\n\nPainterQB.Output \n\u00b6\n\n\nBoolean output state of an instrument.\n\n\nsource:\n\n\nPainterQB\\src\\Definitions.jl:118\n\n\n\n\n\n\nPainterQB.Power \n\u00b6\n\n\nOutput power level.\n\n\nsource:\n\n\nPainterQB\\src\\Definitions.jl:121\n\n\n\n\n\n\nPainterQB.PropertyStimulus{T\n:PainterQB.InstrumentProperty{Number}} \n\u00b6\n\n\nWraps any Number-valued \nInstrumentProperty\n into a \nStimulus\n. Essentially,\nsourcing a PropertyStimulus does nothing more than calling \nconfigure\n with\nthe associated property and value. Additional parameters to be passed to\n\nconfigure\n may be specified at the time the \nPropertyStimulus\n is constructed.\n\n\nsource:\n\n\nPainterQB\\src\\sourcemeasure\\Property.jl:9\n\n\n\n\n\n\nPainterQB.RandomResponse \n\u00b6\n\n\nRandom number response suitable for testing the measurement code without having\na physical instrument.\n\n\nsource:\n\n\nPainterQB\\src\\sourcemeasure\\Random.jl:5\n\n\n\n\n\n\nPainterQB.ResponseStimulus{T} \n\u00b6\n\n\nEsoteric stimulus to consider changing the fields of a \nResponse\n as a stimulus.\nSounds absurd at first, but could be useful if the fields of a \nResponse\n affect\nhow that \nResponse\n is measured. For instance, this may be useful to change\n\nn_avg\n in the \nAveragingResponse\n to see the effect of averaging.\n\n\nsource:\n\n\nPainterQB\\src\\sourcemeasure\\ResponseStim.jl:9\n\n\n\n\n\n\nPainterQB.SParameter \n\u00b6\n\n\nScattering parameter, e.g. S11, S12, etc.\n\n\nsource:\n\n\nPainterQB\\src\\Definitions.jl:90\n\n\n\n\n\n\nPainterQB.SampleRate \n\u00b6\n\n\nThe sample rate for digitizing, synthesizing, etc.\n\n\nsource:\n\n\nPainterQB\\src\\Definitions.jl:85\n\n\n\n\n\n\nPainterQB.ThreadStimulus \n\u00b6\n\n\nChanges the number of Julia worker threads. An Expr object is used to\ninitialize new threads.\n\n\nsource:\n\n\nPainterQB\\src\\sourcemeasure\\Thread.jl:5\n\n\n\n\n\n\nPainterQB.TimeAResponse \n\u00b6\n\n\nA response for timing other responses.\n\n\nsource:\n\n\nPainterQB\\src\\sourcemeasure\\Time.jl:41\n\n\n\n\n\n\nPainterQB.TimerResponse{T\n:AbstractFloat} \n\u00b6\n\n\nA response for measuring how much time has passed since a reference time t0.\n\n\nsource:\n\n\nPainterQB\\src\\sourcemeasure\\Time.jl:27\n\n\n\n\n\n\nPainterQB.TriggerImpedance \n\u00b6\n\n\nTrigger input impedance may be 50 Ohm or 1 kOhm.\n\n\nsource:\n\n\nPainterQB\\src\\Definitions.jl:97\n\n\n\n\n\n\nPainterQB.TriggerLevel \n\u00b6\n\n\nTrigger level.\n\n\nsource:\n\n\nPainterQB\\src\\Definitions.jl:124\n\n\n\n\n\n\nPainterQB.TriggerSlope \n\u00b6\n\n\nTrigger engine can fire on a rising or falling slope.\n\n\nsource:\n\n\nPainterQB\\src\\Definitions.jl:100\n\n\n\n\n\n\nPainterQB.TriggerSource \n\u00b6\n\n\nTrigger may be sourced from: internal, external, bus, etc.\n\n\nsource:\n\n\nPainterQB\\src\\Definitions.jl:103\n\n\nGlobals [Exported]\n\n\n\n\n\n\nresourcemanager \n\u00b6\n\n\nThe default VISA resource manager.\n\n\nsource:\n\n\nPainterQB\\src\\VISA.jl:7\n\n\nMethods [Internal]\n\n\n\n\n\n\ngenerate_configure{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty{T}}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty{T}}) \n\u00b6\n\n\nThis method generates the following method in the module where\n\ngenerate_configure\n is defined:\n\n\nconfigure(ins::InsType, ::Type{PropertySubtype}, infixes...)\n\n\n\n\nsource:\n\n\nPainterQB\\src\\Metaprogramming.jl:82\n\n\n\n\n\n\ngenerate_configure{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty{T}}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty{T}},  ::Type{PainterQB.NoArgs}) \n\u00b6\n\n\nThis method generates the following method in the module where\n\ngenerate_configure\n is defined:\n\n\nconfigure(ins::InsType, ::Type{PropertySubtype}, infixes...)\n\n\n\n\nThis particular method will be deprecated soon.\n\n\nsource:\n\n\nPainterQB\\src\\Metaprogramming.jl:122\n\n\n\n\n\n\ngenerate_configure{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty{T}}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty{T}},  returntype...) \n\u00b6\n\n\nThis method generates the following method in the module where\n\ngenerate_configure\n is defined:\n\n\nconfigure(ins::InsType, Property, values..., infixes...)\n\n\n\n\nsource:\n\n\nPainterQB\\src\\Metaprogramming.jl:151\n\n\n\n\n\n\ngenerate_handlers{T\n:PainterQB.Instrument}(insType::Type{T\n:PainterQB.Instrument},  responseDict::Dict{K, V}) \n\u00b6\n\n\nEach instrument can have a \nresponseDict\n. For each setting of the instrument,\nfor instance the \nClockSource\n, we need to know the correspondence between a\nlogical state \nExternalClock\n and how the instrument encodes that logical state\n(e.g. \"EXT\").\n\n\nThe \nresponseDict\n is actually a dictionary of dictionaries. The first level keys\nare like \nClockSource\n and the second level keys are like \"EXT\", with the value\nbeing \n:ExternalClock\n. Undoubtedly\nthis nested dictionary is \"nasty\" (in the technical parlance) but the dictionary\nis only used for code\ncreation and is not used at run-time (if the code works as intended).\n\n\nThis method makes a lot of other functions. Given some response from an instrument,\nwe require a function to map that response back on to the appropiate logical state.\n\n\nClockSource(ins::AWG5014C, res::AbstractString)\n\nreturns an \nInternalClock\n or \nExternalClock\n type as appropriate,\nbased on the logical meaning of the response.\n\n\nWe also want a function to generate logical states without having to know the way\nthey are encoded by the instrument.\n\n\ncode(ins::AWG5014C, ::Type{InternalClock})\n returns \"INT\",\nwith \"INT\" encoding how to pass this logical state to the instrument \nins\n.\n\n\nsource:\n\n\nPainterQB\\src\\Metaprogramming.jl:218\n\n\n\n\n\n\ngenerate_inspect{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty{T}}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty{T}},  ::Type{PainterQB.NoArgs}) \n\u00b6\n\n\nThis method does/returns nothing.\n\n\nsource:\n\n\nPainterQB\\src\\Metaprogramming.jl:14\n\n\n\n\n\n\ngenerate_inspect{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty{T}}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty{T}},  returntype...) \n\u00b6\n\n\nThis method will\ngenerate the following method in the module where \ngenerate_inspect\n is defined:\n\n\ninspect(ins::instype, ::Type{proptype}, infixes::Int...)\n\n\nThe \ninfixes\n variable argument allows for numbers to be inserted within the\ncommands, for instance in \nOUTP#:FILT:FREQ\n, where the \n#\n sign should be\nreplaced by an integer. The replacements are done in the order of the arguments.\nError checking is done on the number of arguments.\n\n\nFor a given property, \ninspect\n will return either an InstrumentProperty subtype,\na number, a boolean, or a string as appropriate.\n\n\nsource:\n\n\nPainterQB\\src\\Metaprogramming.jl:33\n\n\n\n\n\n\ngenerate_properties{S\n:PainterQB.InstrumentProperty{T}}(subtype::Symbol,  supertype::Type{S\n:PainterQB.InstrumentProperty{T}}) \n\u00b6\n\n\nCreates and exports immutable singleton subtypes.\n\n\nsource:\n\n\nPainterQB\\src\\Metaprogramming.jl:183\n\n\nGlobals [Internal]\n\n\n\n\n\n\nLIVE_DATA \n\u00b6\n\n\nCondition indicating more data for a live update.\n\n\nsource:\n\n\nPainterQB\\src\\LiveUpdate.jl:17\n\n\n\n\n\n\nLIVE_DIE \n\u00b6\n\n\nCondition indicating the end of a live update.\nDefinition in the source code resembles a meditation on the human condition...\n\n\nsource:\n\n\nPainterQB\\src\\LiveUpdate.jl:23\n\n\n\n\n\n\nLIVE_NEW_MEAS \n\u00b6\n\n\nCondition indicating the start of a live update.\n\n\nsource:\n\n\nPainterQB\\src\\LiveUpdate.jl:14", 
            "title": "PainterQB"
        }, 
        {
            "location": "/api/PainterQB/#painterqb", 
            "text": "", 
            "title": "PainterQB"
        }, 
        {
            "location": "/api/PainterQB/#methods-exported", 
            "text": "aborttrigger(ins::PainterQB.InstrumentVISA)  \u00b6  Abort triggering with ABOR.  source:  PainterQB\\src\\VISA.jl:122    ask(ins::PainterQB.InstrumentVISA,  msg::ASCIIString)  \u00b6  Idiomatic \"write and read available\" function with optional delay.  source:  PainterQB\\src\\VISA.jl:73    ask(ins::PainterQB.InstrumentVISA,  msg::ASCIIString,  delay::Real)  \u00b6  Idiomatic \"write and read available\" function with optional delay.  source:  PainterQB\\src\\VISA.jl:73    binblockreadavailable(ins::PainterQB.InstrumentVISA)  \u00b6  Read an entire block of bytes with properly formatted IEEE header.  source:  PainterQB\\src\\VISA.jl:102    binblockwrite(ins::PainterQB.InstrumentVISA,  message::Union{ASCIIString, Array{UInt8, 1}},  data::Array{UInt8, 1})  \u00b6  Write an IEEE header block followed by an arbitary sequency of bytes and the terminator.  source:  PainterQB\\src\\VISA.jl:97    clearregisters(ins::PainterQB.InstrumentVISA)  \u00b6  Clear registers with *CLS.  source:  PainterQB\\src\\VISA.jl:116    findresources()  \u00b6  Finds VISA resources to which we can connect. Doesn't seem to find ethernet instruments.  source:  PainterQB\\src\\VISA.jl:41    findresources(expr::AbstractString)  \u00b6  Finds VISA resources to which we can connect. Doesn't seem to find ethernet instruments.  source:  PainterQB\\src\\VISA.jl:41    gpib(board,  primary)  \u00b6  Returns a  viSession  for the given GPIB board and primary address.\nSee VISA spec for details on what a  viSession  is.  source:  PainterQB\\src\\VISA.jl:53    gpib(board,  primary,  secondary)  \u00b6  Returns a  viSession  for the given GPIB board, primary, and secondary address.\nSee VISA spec for details on what a  viSession  is.  source:  PainterQB\\src\\VISA.jl:60    gpib(primary)  \u00b6  Returns a  viSession  for the given GPIB primary address using board 0.\nSee VISA spec for details on what a  viSession  is.  source:  PainterQB\\src\\VISA.jl:47    identify(ins::PainterQB.InstrumentVISA)  \u00b6  Ask the *IDN? command.  source:  PainterQB\\src\\VISA.jl:113    inspect(ins::PainterQB.Instrument,  args::Tuple{Vararg{DataType}})  \u00b6  Allow inspecting mulitple properties at once.  source:  PainterQB\\src\\Definitions.jl:222    inspect(ins::PainterQB.Instrument,  args::Tuple{Vararg{T}})  \u00b6  Splat tuples into new inspect commands.  source:  PainterQB\\src\\Definitions.jl:218    measure(ch::PainterQB.RandomResponse)  \u00b6  Returns a random number in the unit interval.  source:  PainterQB\\src\\sourcemeasure\\Random.jl:8    measure(ch::PainterQB.TimeAResponse)  \u00b6  Returns how many seconds it takes to measure the response field  ch  holds.  source:  PainterQB\\src\\sourcemeasure\\Time.jl:46    measure{T}(ch::PainterQB.AveragingResponse{T})  \u00b6  Measures the response held by  ch   n_avg  times, and returns the average.  source:  PainterQB\\src\\sourcemeasure\\Averaging.jl:11    measure{T}(ch::PainterQB.TimerResponse{T})  \u00b6  Returns how many seconds have elapsed since the timer was initialized or reset.  source:  PainterQB\\src\\sourcemeasure\\Time.jl:38    quoted(str::ASCIIString)  \u00b6  Surround a string in quotation marks.  source:  PainterQB\\src\\VISA.jl:130    read(ins::PainterQB.InstrumentVISA)  \u00b6  Read from an instrument. Strips trailing carriage returns and new lines.\nNote that this function will only read so many characters (buffered).  source:  PainterQB\\src\\VISA.jl:83    readavailable(ins::PainterQB.InstrumentVISA)  \u00b6  Keep reading from an instrument until the instrument says we are done.  source:  PainterQB\\src\\VISA.jl:91    reset(d::PainterQB.DelayStimulus)  \u00b6  Reset the DelayStimulus reference time to now.  source:  PainterQB\\src\\sourcemeasure\\Time.jl:11    reset(d::PainterQB.TimerResponse{T :AbstractFloat})  \u00b6  Reset the TimerResponse reference time to now.  source:  PainterQB\\src\\sourcemeasure\\Time.jl:33    reset(ins::PainterQB.InstrumentVISA)  \u00b6  Reset with the *RST command.  source:  PainterQB\\src\\VISA.jl:110    source(ch::PainterQB.DelayStimulus,  val::Real)  \u00b6  Wait until  val  seconds have elapsed since  ch  was initialized or reset.  source:  PainterQB\\src\\sourcemeasure\\Time.jl:16    source(ch::PainterQB.DummyStimulus)  \u00b6  Returns a random number in the unit interval.  source:  PainterQB\\src\\sourcemeasure\\Dummy.jl:8    source(ch::PainterQB.PropertyStimulus{T :PainterQB.InstrumentProperty{Number}},  val::Real)  \u00b6  Sourcing a PropertyStimulus configures an InstrumentProperty.  source:  PainterQB\\src\\sourcemeasure\\Property.jl:30    source(ch::PainterQB.ThreadStimulus,  nw::Int64)  \u00b6  Adds or removes threads to reach the desired number of worker threads.  source:  PainterQB\\src\\sourcemeasure\\Thread.jl:32    source{T}(ch::PainterQB.ResponseStimulus{T},  val)  \u00b6  Sets the field named  :name  in the  Response  held by  ch  to  val .  source:  PainterQB\\src\\sourcemeasure\\ResponseStim.jl:22    sweep{T :Real, N}(dep::PainterQB.Response{T :Real},  indep::NTuple{N, Tuple{PainterQB.Stimulus, AbstractArray{T, N}}})  \u00b6  Measures a response as a function of an arbitrary number of stimuli.\nImplementation: N  for  loops are built around a simple body programmatically,\ngiven N stimuli. The stimuli are sourced at the start of each for loop.\nThe body just measures the response with an optional time delay.  source:  PainterQB\\src\\Sweep.jl:24    sweep{T}(dep::PainterQB.Response{T},  indep::Tuple{PainterQB.Stimulus, AbstractArray{T, N}}...)  \u00b6  This method is slightly more convenient than the other sweep method\nbut not type stable. The return type depends on the number of arguments.\nIf for some reason this were executed in a tight loop it might be good to\nannotate the return type in the calling function. For most purposes there should\nbe minimal performance penalty.  source:  PainterQB\\src\\Sweep.jl:12    tcpip_instr(ip)  \u00b6  Returns a INSTR  viSession  for the given IPv4 address string.  source:  PainterQB\\src\\VISA.jl:64    tcpip_socket(ip,  port)  \u00b6  Returns a raw socket  viSession  for the given IPv4 address string.  source:  PainterQB\\src\\VISA.jl:67    test(ins::PainterQB.InstrumentVISA)  \u00b6  Test with the *TST? command.  source:  PainterQB\\src\\VISA.jl:107    trigger(ins::PainterQB.InstrumentVISA)  \u00b6  Bus trigger with *TRG.  source:  PainterQB\\src\\VISA.jl:119    unquoted(str::ASCIIString)  \u00b6  Strip a string of enclosing quotation marks.  source:  PainterQB\\src\\VISA.jl:133    wait(ins::PainterQB.InstrumentVISA)  \u00b6  Wait for completion of a sweep.  source:  PainterQB\\src\\VISA.jl:125    write(ins::PainterQB.InstrumentVISA,  msg::ASCIIString)  \u00b6  Write to an instrument. Appends the instrument's write terminator.  source:  PainterQB\\src\\VISA.jl:87", 
            "title": "Methods [Exported]"
        }, 
        {
            "location": "/api/PainterQB/#types-exported", 
            "text": "PainterQB.All  \u00b6  The All type is meant to be dispatched upon and not instantiated.  source:  PainterQB\\src\\Definitions.jl:214    PainterQB.AveragingResponse{T}  \u00b6  Response that averages other responses. Not clear if this is a good idea yet.  source:  PainterQB\\src\\sourcemeasure\\Averaging.jl:4    PainterQB.ClockSlope  \u00b6  Clock may tick on a rising or falling slope.  source:  PainterQB\\src\\Definitions.jl:71    PainterQB.ClockSource  \u00b6  Clock source can be internal or external.  source:  PainterQB\\src\\Definitions.jl:74    PainterQB.Coupling  \u00b6  Signals may be AC or DC coupled.  source:  PainterQB\\src\\Definitions.jl:77    PainterQB.DelayStimulus  \u00b6  A stimulus for delaying until time has passed since a reference time t0.  source:  PainterQB\\src\\sourcemeasure\\Time.jl:5    PainterQB.DummyStimulus  \u00b6  Random number response suitable for testing the measurement code without having\na physical instrument.  source:  PainterQB\\src\\sourcemeasure\\Dummy.jl:5    PainterQB.Frequency  \u00b6  Fixed frequency of a sourced signal.  source:  PainterQB\\src\\Definitions.jl:106    PainterQB.FrequencyStart  \u00b6  Start frequency of a fixed range.  source:  PainterQB\\src\\Definitions.jl:109    PainterQB.FrequencyStop  \u00b6  Stop frequency of a fixed range.  source:  PainterQB\\src\\Definitions.jl:112    PainterQB.Instrument  \u00b6  Abstract supertype representing an instrument.  source:  PainterQB\\src\\Definitions.jl:53    PainterQB.InstrumentException  \u00b6  Exception to be thrown by an instrument. Fields include the instrument in error ins::Instrument , the error code  val::Int64 , and a  humanReadable  Unicode\nstring.  source:  PainterQB\\src\\Definitions.jl:131    PainterQB.InstrumentProperty{T}  \u00b6  Abstract parametric supertype representing communications with an instrument.  Each  abstract  subtype one level down should represent a logical state of the\ninstrument configuration, e.g.  TriggerSource  may be have concrete\nsubtypes  ExternalTrigger  or  InternalTrigger .  To retrieve what one has to send the AWG from the type signature, we have\ndefined a function  code .  source:  PainterQB\\src\\Definitions.jl:65    PainterQB.InstrumentVISA  \u00b6  Abstract supertype of all Instruments addressable using a VISA library.\nConcrete types are expected to have fields:  vi::ViSession  writeTerminator::ASCIIString  source:  PainterQB\\src\\VISA.jl:36    PainterQB.NoArgs  \u00b6  Used internally to indicate that a property takes no argument.  source:  PainterQB\\src\\Definitions.jl:68    PainterQB.NumPoints  \u00b6  Number of points per sweep.  source:  PainterQB\\src\\Definitions.jl:115    PainterQB.OscillatorSource  \u00b6  Oscillator source can be internal or external.  source:  PainterQB\\src\\Definitions.jl:82    PainterQB.Output  \u00b6  Boolean output state of an instrument.  source:  PainterQB\\src\\Definitions.jl:118    PainterQB.Power  \u00b6  Output power level.  source:  PainterQB\\src\\Definitions.jl:121    PainterQB.PropertyStimulus{T :PainterQB.InstrumentProperty{Number}}  \u00b6  Wraps any Number-valued  InstrumentProperty  into a  Stimulus . Essentially,\nsourcing a PropertyStimulus does nothing more than calling  configure  with\nthe associated property and value. Additional parameters to be passed to configure  may be specified at the time the  PropertyStimulus  is constructed.  source:  PainterQB\\src\\sourcemeasure\\Property.jl:9    PainterQB.RandomResponse  \u00b6  Random number response suitable for testing the measurement code without having\na physical instrument.  source:  PainterQB\\src\\sourcemeasure\\Random.jl:5    PainterQB.ResponseStimulus{T}  \u00b6  Esoteric stimulus to consider changing the fields of a  Response  as a stimulus.\nSounds absurd at first, but could be useful if the fields of a  Response  affect\nhow that  Response  is measured. For instance, this may be useful to change n_avg  in the  AveragingResponse  to see the effect of averaging.  source:  PainterQB\\src\\sourcemeasure\\ResponseStim.jl:9    PainterQB.SParameter  \u00b6  Scattering parameter, e.g. S11, S12, etc.  source:  PainterQB\\src\\Definitions.jl:90    PainterQB.SampleRate  \u00b6  The sample rate for digitizing, synthesizing, etc.  source:  PainterQB\\src\\Definitions.jl:85    PainterQB.ThreadStimulus  \u00b6  Changes the number of Julia worker threads. An Expr object is used to\ninitialize new threads.  source:  PainterQB\\src\\sourcemeasure\\Thread.jl:5    PainterQB.TimeAResponse  \u00b6  A response for timing other responses.  source:  PainterQB\\src\\sourcemeasure\\Time.jl:41    PainterQB.TimerResponse{T :AbstractFloat}  \u00b6  A response for measuring how much time has passed since a reference time t0.  source:  PainterQB\\src\\sourcemeasure\\Time.jl:27    PainterQB.TriggerImpedance  \u00b6  Trigger input impedance may be 50 Ohm or 1 kOhm.  source:  PainterQB\\src\\Definitions.jl:97    PainterQB.TriggerLevel  \u00b6  Trigger level.  source:  PainterQB\\src\\Definitions.jl:124    PainterQB.TriggerSlope  \u00b6  Trigger engine can fire on a rising or falling slope.  source:  PainterQB\\src\\Definitions.jl:100    PainterQB.TriggerSource  \u00b6  Trigger may be sourced from: internal, external, bus, etc.  source:  PainterQB\\src\\Definitions.jl:103", 
            "title": "Types [Exported]"
        }, 
        {
            "location": "/api/PainterQB/#globals-exported", 
            "text": "resourcemanager  \u00b6  The default VISA resource manager.  source:  PainterQB\\src\\VISA.jl:7", 
            "title": "Globals [Exported]"
        }, 
        {
            "location": "/api/PainterQB/#methods-internal", 
            "text": "generate_configure{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty{T}}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty{T}})  \u00b6  This method generates the following method in the module where generate_configure  is defined:  configure(ins::InsType, ::Type{PropertySubtype}, infixes...)  source:  PainterQB\\src\\Metaprogramming.jl:82    generate_configure{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty{T}}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty{T}},  ::Type{PainterQB.NoArgs})  \u00b6  This method generates the following method in the module where generate_configure  is defined:  configure(ins::InsType, ::Type{PropertySubtype}, infixes...)  This particular method will be deprecated soon.  source:  PainterQB\\src\\Metaprogramming.jl:122    generate_configure{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty{T}}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty{T}},  returntype...)  \u00b6  This method generates the following method in the module where generate_configure  is defined:  configure(ins::InsType, Property, values..., infixes...)  source:  PainterQB\\src\\Metaprogramming.jl:151    generate_handlers{T :PainterQB.Instrument}(insType::Type{T :PainterQB.Instrument},  responseDict::Dict{K, V})  \u00b6  Each instrument can have a  responseDict . For each setting of the instrument,\nfor instance the  ClockSource , we need to know the correspondence between a\nlogical state  ExternalClock  and how the instrument encodes that logical state\n(e.g. \"EXT\").  The  responseDict  is actually a dictionary of dictionaries. The first level keys\nare like  ClockSource  and the second level keys are like \"EXT\", with the value\nbeing  :ExternalClock . Undoubtedly\nthis nested dictionary is \"nasty\" (in the technical parlance) but the dictionary\nis only used for code\ncreation and is not used at run-time (if the code works as intended).  This method makes a lot of other functions. Given some response from an instrument,\nwe require a function to map that response back on to the appropiate logical state.  ClockSource(ins::AWG5014C, res::AbstractString) \nreturns an  InternalClock  or  ExternalClock  type as appropriate,\nbased on the logical meaning of the response.  We also want a function to generate logical states without having to know the way\nthey are encoded by the instrument.  code(ins::AWG5014C, ::Type{InternalClock})  returns \"INT\",\nwith \"INT\" encoding how to pass this logical state to the instrument  ins .  source:  PainterQB\\src\\Metaprogramming.jl:218    generate_inspect{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty{T}}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty{T}},  ::Type{PainterQB.NoArgs})  \u00b6  This method does/returns nothing.  source:  PainterQB\\src\\Metaprogramming.jl:14    generate_inspect{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty{T}}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty{T}},  returntype...)  \u00b6  This method will\ngenerate the following method in the module where  generate_inspect  is defined:  inspect(ins::instype, ::Type{proptype}, infixes::Int...)  The  infixes  variable argument allows for numbers to be inserted within the\ncommands, for instance in  OUTP#:FILT:FREQ , where the  #  sign should be\nreplaced by an integer. The replacements are done in the order of the arguments.\nError checking is done on the number of arguments.  For a given property,  inspect  will return either an InstrumentProperty subtype,\na number, a boolean, or a string as appropriate.  source:  PainterQB\\src\\Metaprogramming.jl:33    generate_properties{S :PainterQB.InstrumentProperty{T}}(subtype::Symbol,  supertype::Type{S :PainterQB.InstrumentProperty{T}})  \u00b6  Creates and exports immutable singleton subtypes.  source:  PainterQB\\src\\Metaprogramming.jl:183", 
            "title": "Methods [Internal]"
        }, 
        {
            "location": "/api/PainterQB/#globals-internal", 
            "text": "LIVE_DATA  \u00b6  Condition indicating more data for a live update.  source:  PainterQB\\src\\LiveUpdate.jl:17    LIVE_DIE  \u00b6  Condition indicating the end of a live update.\nDefinition in the source code resembles a meditation on the human condition...  source:  PainterQB\\src\\LiveUpdate.jl:23    LIVE_NEW_MEAS  \u00b6  Condition indicating the start of a live update.  source:  PainterQB\\src\\LiveUpdate.jl:14", 
            "title": "Globals [Internal]"
        }, 
        {
            "location": "/api/E8257D/", 
            "text": "PainterQB.E8257DModule\n\n\nFunctions [Exported]\n\n\n\n\n\n\nPainterQB.E8257DModule.cumulativeattenuatorswitches \n\u00b6\n\n\nReturns the number of attenuator switching events over the instrument lifetime.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\E8257D.jl:198\n\n\n\n\n\n\nPainterQB.E8257DModule.cumulativeontime \n\u00b6\n\n\nReturns the cumulative on-time over the instrument lifetime.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\E8257D.jl:208\n\n\n\n\n\n\nPainterQB.E8257DModule.cumulativepowerons \n\u00b6\n\n\nReturns the number of power on events over the instrument lifetime.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\E8257D.jl:203\n\n\n\n\n\n\nPainterQB.E8257DModule.revision \n\u00b6\n\n\nReports the revision of the E8257D.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\E8257D.jl:224\n\n\n\n\n\n\nPainterQB.options \n\u00b6\n\n\nReports the options available for the given E8257D.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\E8257D.jl:219\n\n\nTypes [Exported]\n\n\n\n\n\n\nPainterQB.E8257DModule.ALC \n\u00b6\n\n\nBoolean state of the ALC.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\E8257D.jl:83\n\n\n\n\n\n\nPainterQB.E8257DModule.ALCBandwidth \n\u00b6\n\n\nALC bandwidth.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\E8257D.jl:77\n\n\n\n\n\n\nPainterQB.E8257DModule.ALCBandwidthAuto \n\u00b6\n\n\nBoolean state for automatic selection of the ALC bandwidth.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\E8257D.jl:80\n\n\n\n\n\n\nPainterQB.E8257DModule.ALCLevel \n\u00b6\n\n\nLevel of the ALC when the attenuator hold is active.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\E8257D.jl:86\n\n\n\n\n\n\nPainterQB.E8257DModule.AttenuatorAuto \n\u00b6\n\n\nBoolean state for automatic operation of the attenuator.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\E8257D.jl:89\n\n\n\n\n\n\nPainterQB.E8257DModule.E8257D \n\u00b6\n\n\nConcrete type representing an E8257D.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\E8257D.jl:47\n\n\n\n\n\n\nPainterQB.E8257DModule.FlatnessCorrection \n\u00b6\n\n\nBoolean state for flatness correction.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\E8257D.jl:92\n\n\n\n\n\n\nPainterQB.E8257DModule.FrequencyReference \n\u00b6\n\n\nBoolean state of the frequency reference level.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\E8257D.jl:103\n\n\n\n\n\n\nPainterQB.E8257DModule.FrequencyReferenceLevel \n\u00b6\n\n\nReference level for configuring/inspecting frequency.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\E8257D.jl:106\n\n\n\n\n\n\nPainterQB.E8257DModule.FrequencyStep \n\u00b6\n\n\nStep size for a frequency sweep.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\E8257D.jl:97\n\n\n\n\n\n\nPainterQB.E8257DModule.OutputBlanking \n\u00b6\n\n\nBoolean state for the output blanking.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\E8257D.jl:109\n\n\n\n\n\n\nPainterQB.E8257DModule.OutputBlankingAuto \n\u00b6\n\n\nBoolean state for automatic blanking of the output.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\E8257D.jl:112\n\n\n\n\n\n\nPainterQB.E8257DModule.OutputSettled \n\u00b6\n\n\nHas the output settled?\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\E8257D.jl:115\n\n\n\n\n\n\nPainterQB.E8257DModule.PowerLimit \n\u00b6\n\n\nRF output power limit.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\E8257D.jl:118\n\n\n\n\n\n\nPainterQB.E8257DModule.PowerLimitAdjustable \n\u00b6\n\n\nBoolean for whether or not the RF output power limit can be adjusted.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\E8257D.jl:121\n\n\n\n\n\n\nPainterQB.E8257DModule.PowerReference \n\u00b6\n\n\nBoolean state of the power reference level.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\E8257D.jl:135\n\n\n\n\n\n\nPainterQB.E8257DModule.PowerReferenceLevel \n\u00b6\n\n\nReference level for configuring/inspecting power.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\E8257D.jl:138\n\n\n\n\n\n\nPainterQB.E8257DModule.PowerStart \n\u00b6\n\n\nStart power in a sweep.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\E8257D.jl:124\n\n\n\n\n\n\nPainterQB.E8257DModule.PowerStep \n\u00b6\n\n\nStep size for a power sweep.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\E8257D.jl:130\n\n\n\n\n\n\nPainterQB.E8257DModule.PowerStop \n\u00b6\n\n\nStop power in a sweep.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\E8257D.jl:127\n\n\nMethods [Internal]\n\n\n\n\n\n\ngenerate_configure{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty{T}}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty{T}}) \n\u00b6\n\n\nThis method generates the following method in the module where\n\ngenerate_configure\n is defined:\n\n\nconfigure(ins::InsType, ::Type{PropertySubtype}, infixes...)\n\n\n\n\nsource:\n\n\nPainterQB\\src\\Metaprogramming.jl:82\n\n\n\n\n\n\ngenerate_configure{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty{T}}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty{T}},  ::Type{PainterQB.NoArgs}) \n\u00b6\n\n\nThis method generates the following method in the module where\n\ngenerate_configure\n is defined:\n\n\nconfigure(ins::InsType, ::Type{PropertySubtype}, infixes...)\n\n\n\n\nThis particular method will be deprecated soon.\n\n\nsource:\n\n\nPainterQB\\src\\Metaprogramming.jl:122\n\n\n\n\n\n\ngenerate_configure{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty{T}}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty{T}},  returntype...) \n\u00b6\n\n\nThis method generates the following method in the module where\n\ngenerate_configure\n is defined:\n\n\nconfigure(ins::InsType, Property, values..., infixes...)\n\n\n\n\nsource:\n\n\nPainterQB\\src\\Metaprogramming.jl:151\n\n\n\n\n\n\ngenerate_handlers{T\n:PainterQB.Instrument}(insType::Type{T\n:PainterQB.Instrument},  responseDict::Dict{K, V}) \n\u00b6\n\n\nEach instrument can have a \nresponseDict\n. For each setting of the instrument,\nfor instance the \nClockSource\n, we need to know the correspondence between a\nlogical state \nExternalClock\n and how the instrument encodes that logical state\n(e.g. \"EXT\").\n\n\nThe \nresponseDict\n is actually a dictionary of dictionaries. The first level keys\nare like \nClockSource\n and the second level keys are like \"EXT\", with the value\nbeing \n:ExternalClock\n. Undoubtedly\nthis nested dictionary is \"nasty\" (in the technical parlance) but the dictionary\nis only used for code\ncreation and is not used at run-time (if the code works as intended).\n\n\nThis method makes a lot of other functions. Given some response from an instrument,\nwe require a function to map that response back on to the appropiate logical state.\n\n\nClockSource(ins::AWG5014C, res::AbstractString)\n\nreturns an \nInternalClock\n or \nExternalClock\n type as appropriate,\nbased on the logical meaning of the response.\n\n\nWe also want a function to generate logical states without having to know the way\nthey are encoded by the instrument.\n\n\ncode(ins::AWG5014C, ::Type{InternalClock})\n returns \"INT\",\nwith \"INT\" encoding how to pass this logical state to the instrument \nins\n.\n\n\nsource:\n\n\nPainterQB\\src\\Metaprogramming.jl:218\n\n\n\n\n\n\ngenerate_inspect{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty{T}}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty{T}},  ::Type{PainterQB.NoArgs}) \n\u00b6\n\n\nThis method does/returns nothing.\n\n\nsource:\n\n\nPainterQB\\src\\Metaprogramming.jl:14\n\n\n\n\n\n\ngenerate_inspect{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty{T}}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty{T}},  returntype...) \n\u00b6\n\n\nThis method will\ngenerate the following method in the module where \ngenerate_inspect\n is defined:\n\n\ninspect(ins::instype, ::Type{proptype}, infixes::Int...)\n\n\nThe \ninfixes\n variable argument allows for numbers to be inserted within the\ncommands, for instance in \nOUTP#:FILT:FREQ\n, where the \n#\n sign should be\nreplaced by an integer. The replacements are done in the order of the arguments.\nError checking is done on the number of arguments.\n\n\nFor a given property, \ninspect\n will return either an InstrumentProperty subtype,\na number, a boolean, or a string as appropriate.\n\n\nsource:\n\n\nPainterQB\\src\\Metaprogramming.jl:33\n\n\n\n\n\n\ngenerate_properties{S\n:PainterQB.InstrumentProperty{T}}(subtype::Symbol,  supertype::Type{S\n:PainterQB.InstrumentProperty{T}}) \n\u00b6\n\n\nCreates and exports immutable singleton subtypes.\n\n\nsource:\n\n\nPainterQB\\src\\Metaprogramming.jl:183", 
            "title": "E8257D"
        }, 
        {
            "location": "/api/E8257D/#painterqbe8257dmodule", 
            "text": "", 
            "title": "PainterQB.E8257DModule"
        }, 
        {
            "location": "/api/E8257D/#functions-exported", 
            "text": "PainterQB.E8257DModule.cumulativeattenuatorswitches  \u00b6  Returns the number of attenuator switching events over the instrument lifetime.  source:  PainterQB\\src\\instruments\\E8257D.jl:198    PainterQB.E8257DModule.cumulativeontime  \u00b6  Returns the cumulative on-time over the instrument lifetime.  source:  PainterQB\\src\\instruments\\E8257D.jl:208    PainterQB.E8257DModule.cumulativepowerons  \u00b6  Returns the number of power on events over the instrument lifetime.  source:  PainterQB\\src\\instruments\\E8257D.jl:203    PainterQB.E8257DModule.revision  \u00b6  Reports the revision of the E8257D.  source:  PainterQB\\src\\instruments\\E8257D.jl:224    PainterQB.options  \u00b6  Reports the options available for the given E8257D.  source:  PainterQB\\src\\instruments\\E8257D.jl:219", 
            "title": "Functions [Exported]"
        }, 
        {
            "location": "/api/E8257D/#types-exported", 
            "text": "PainterQB.E8257DModule.ALC  \u00b6  Boolean state of the ALC.  source:  PainterQB\\src\\instruments\\E8257D.jl:83    PainterQB.E8257DModule.ALCBandwidth  \u00b6  ALC bandwidth.  source:  PainterQB\\src\\instruments\\E8257D.jl:77    PainterQB.E8257DModule.ALCBandwidthAuto  \u00b6  Boolean state for automatic selection of the ALC bandwidth.  source:  PainterQB\\src\\instruments\\E8257D.jl:80    PainterQB.E8257DModule.ALCLevel  \u00b6  Level of the ALC when the attenuator hold is active.  source:  PainterQB\\src\\instruments\\E8257D.jl:86    PainterQB.E8257DModule.AttenuatorAuto  \u00b6  Boolean state for automatic operation of the attenuator.  source:  PainterQB\\src\\instruments\\E8257D.jl:89    PainterQB.E8257DModule.E8257D  \u00b6  Concrete type representing an E8257D.  source:  PainterQB\\src\\instruments\\E8257D.jl:47    PainterQB.E8257DModule.FlatnessCorrection  \u00b6  Boolean state for flatness correction.  source:  PainterQB\\src\\instruments\\E8257D.jl:92    PainterQB.E8257DModule.FrequencyReference  \u00b6  Boolean state of the frequency reference level.  source:  PainterQB\\src\\instruments\\E8257D.jl:103    PainterQB.E8257DModule.FrequencyReferenceLevel  \u00b6  Reference level for configuring/inspecting frequency.  source:  PainterQB\\src\\instruments\\E8257D.jl:106    PainterQB.E8257DModule.FrequencyStep  \u00b6  Step size for a frequency sweep.  source:  PainterQB\\src\\instruments\\E8257D.jl:97    PainterQB.E8257DModule.OutputBlanking  \u00b6  Boolean state for the output blanking.  source:  PainterQB\\src\\instruments\\E8257D.jl:109    PainterQB.E8257DModule.OutputBlankingAuto  \u00b6  Boolean state for automatic blanking of the output.  source:  PainterQB\\src\\instruments\\E8257D.jl:112    PainterQB.E8257DModule.OutputSettled  \u00b6  Has the output settled?  source:  PainterQB\\src\\instruments\\E8257D.jl:115    PainterQB.E8257DModule.PowerLimit  \u00b6  RF output power limit.  source:  PainterQB\\src\\instruments\\E8257D.jl:118    PainterQB.E8257DModule.PowerLimitAdjustable  \u00b6  Boolean for whether or not the RF output power limit can be adjusted.  source:  PainterQB\\src\\instruments\\E8257D.jl:121    PainterQB.E8257DModule.PowerReference  \u00b6  Boolean state of the power reference level.  source:  PainterQB\\src\\instruments\\E8257D.jl:135    PainterQB.E8257DModule.PowerReferenceLevel  \u00b6  Reference level for configuring/inspecting power.  source:  PainterQB\\src\\instruments\\E8257D.jl:138    PainterQB.E8257DModule.PowerStart  \u00b6  Start power in a sweep.  source:  PainterQB\\src\\instruments\\E8257D.jl:124    PainterQB.E8257DModule.PowerStep  \u00b6  Step size for a power sweep.  source:  PainterQB\\src\\instruments\\E8257D.jl:130    PainterQB.E8257DModule.PowerStop  \u00b6  Stop power in a sweep.  source:  PainterQB\\src\\instruments\\E8257D.jl:127", 
            "title": "Types [Exported]"
        }, 
        {
            "location": "/api/E8257D/#methods-internal", 
            "text": "generate_configure{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty{T}}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty{T}})  \u00b6  This method generates the following method in the module where generate_configure  is defined:  configure(ins::InsType, ::Type{PropertySubtype}, infixes...)  source:  PainterQB\\src\\Metaprogramming.jl:82    generate_configure{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty{T}}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty{T}},  ::Type{PainterQB.NoArgs})  \u00b6  This method generates the following method in the module where generate_configure  is defined:  configure(ins::InsType, ::Type{PropertySubtype}, infixes...)  This particular method will be deprecated soon.  source:  PainterQB\\src\\Metaprogramming.jl:122    generate_configure{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty{T}}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty{T}},  returntype...)  \u00b6  This method generates the following method in the module where generate_configure  is defined:  configure(ins::InsType, Property, values..., infixes...)  source:  PainterQB\\src\\Metaprogramming.jl:151    generate_handlers{T :PainterQB.Instrument}(insType::Type{T :PainterQB.Instrument},  responseDict::Dict{K, V})  \u00b6  Each instrument can have a  responseDict . For each setting of the instrument,\nfor instance the  ClockSource , we need to know the correspondence between a\nlogical state  ExternalClock  and how the instrument encodes that logical state\n(e.g. \"EXT\").  The  responseDict  is actually a dictionary of dictionaries. The first level keys\nare like  ClockSource  and the second level keys are like \"EXT\", with the value\nbeing  :ExternalClock . Undoubtedly\nthis nested dictionary is \"nasty\" (in the technical parlance) but the dictionary\nis only used for code\ncreation and is not used at run-time (if the code works as intended).  This method makes a lot of other functions. Given some response from an instrument,\nwe require a function to map that response back on to the appropiate logical state.  ClockSource(ins::AWG5014C, res::AbstractString) \nreturns an  InternalClock  or  ExternalClock  type as appropriate,\nbased on the logical meaning of the response.  We also want a function to generate logical states without having to know the way\nthey are encoded by the instrument.  code(ins::AWG5014C, ::Type{InternalClock})  returns \"INT\",\nwith \"INT\" encoding how to pass this logical state to the instrument  ins .  source:  PainterQB\\src\\Metaprogramming.jl:218    generate_inspect{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty{T}}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty{T}},  ::Type{PainterQB.NoArgs})  \u00b6  This method does/returns nothing.  source:  PainterQB\\src\\Metaprogramming.jl:14    generate_inspect{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty{T}}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty{T}},  returntype...)  \u00b6  This method will\ngenerate the following method in the module where  generate_inspect  is defined:  inspect(ins::instype, ::Type{proptype}, infixes::Int...)  The  infixes  variable argument allows for numbers to be inserted within the\ncommands, for instance in  OUTP#:FILT:FREQ , where the  #  sign should be\nreplaced by an integer. The replacements are done in the order of the arguments.\nError checking is done on the number of arguments.  For a given property,  inspect  will return either an InstrumentProperty subtype,\na number, a boolean, or a string as appropriate.  source:  PainterQB\\src\\Metaprogramming.jl:33    generate_properties{S :PainterQB.InstrumentProperty{T}}(subtype::Symbol,  supertype::Type{S :PainterQB.InstrumentProperty{T}})  \u00b6  Creates and exports immutable singleton subtypes.  source:  PainterQB\\src\\Metaprogramming.jl:183", 
            "title": "Methods [Internal]"
        }, 
        {
            "location": "/api/E5071C/", 
            "text": "PainterQB.E5071CModule\n\n\nTypes [Exported]\n\n\n\n\n\n\nPainterQB.E5071CModule.ElectricalMedium \n\u00b6\n\n\nSignals may propagate on coax or waveguide media.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\VNAs\\E5071C.jl:73\n\n\nMethods [Internal]\n\n\n\n\n\n\ngenerate_configure{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty{T}}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty{T}}) \n\u00b6\n\n\nThis method generates the following method in the module where\n\ngenerate_configure\n is defined:\n\n\nconfigure(ins::InsType, ::Type{PropertySubtype}, infixes...)\n\n\n\n\nsource:\n\n\nPainterQB\\src\\Metaprogramming.jl:82\n\n\n\n\n\n\ngenerate_configure{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty{T}}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty{T}},  ::Type{PainterQB.NoArgs}) \n\u00b6\n\n\nThis method generates the following method in the module where\n\ngenerate_configure\n is defined:\n\n\nconfigure(ins::InsType, ::Type{PropertySubtype}, infixes...)\n\n\n\n\nThis particular method will be deprecated soon.\n\n\nsource:\n\n\nPainterQB\\src\\Metaprogramming.jl:122\n\n\n\n\n\n\ngenerate_configure{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty{T}}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty{T}},  returntype...) \n\u00b6\n\n\nThis method generates the following method in the module where\n\ngenerate_configure\n is defined:\n\n\nconfigure(ins::InsType, Property, values..., infixes...)\n\n\n\n\nsource:\n\n\nPainterQB\\src\\Metaprogramming.jl:151\n\n\n\n\n\n\ngenerate_handlers{T\n:PainterQB.Instrument}(insType::Type{T\n:PainterQB.Instrument},  responseDict::Dict{K, V}) \n\u00b6\n\n\nEach instrument can have a \nresponseDict\n. For each setting of the instrument,\nfor instance the \nClockSource\n, we need to know the correspondence between a\nlogical state \nExternalClock\n and how the instrument encodes that logical state\n(e.g. \"EXT\").\n\n\nThe \nresponseDict\n is actually a dictionary of dictionaries. The first level keys\nare like \nClockSource\n and the second level keys are like \"EXT\", with the value\nbeing \n:ExternalClock\n. Undoubtedly\nthis nested dictionary is \"nasty\" (in the technical parlance) but the dictionary\nis only used for code\ncreation and is not used at run-time (if the code works as intended).\n\n\nThis method makes a lot of other functions. Given some response from an instrument,\nwe require a function to map that response back on to the appropiate logical state.\n\n\nClockSource(ins::AWG5014C, res::AbstractString)\n\nreturns an \nInternalClock\n or \nExternalClock\n type as appropriate,\nbased on the logical meaning of the response.\n\n\nWe also want a function to generate logical states without having to know the way\nthey are encoded by the instrument.\n\n\ncode(ins::AWG5014C, ::Type{InternalClock})\n returns \"INT\",\nwith \"INT\" encoding how to pass this logical state to the instrument \nins\n.\n\n\nsource:\n\n\nPainterQB\\src\\Metaprogramming.jl:218\n\n\n\n\n\n\ngenerate_inspect{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty{T}}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty{T}},  ::Type{PainterQB.NoArgs}) \n\u00b6\n\n\nThis method does/returns nothing.\n\n\nsource:\n\n\nPainterQB\\src\\Metaprogramming.jl:14\n\n\n\n\n\n\ngenerate_inspect{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty{T}}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty{T}},  returntype...) \n\u00b6\n\n\nThis method will\ngenerate the following method in the module where \ngenerate_inspect\n is defined:\n\n\ninspect(ins::instype, ::Type{proptype}, infixes::Int...)\n\n\nThe \ninfixes\n variable argument allows for numbers to be inserted within the\ncommands, for instance in \nOUTP#:FILT:FREQ\n, where the \n#\n sign should be\nreplaced by an integer. The replacements are done in the order of the arguments.\nError checking is done on the number of arguments.\n\n\nFor a given property, \ninspect\n will return either an InstrumentProperty subtype,\na number, a boolean, or a string as appropriate.\n\n\nsource:\n\n\nPainterQB\\src\\Metaprogramming.jl:33\n\n\n\n\n\n\ngenerate_properties{S\n:PainterQB.InstrumentProperty{T}}(subtype::Symbol,  supertype::Type{S\n:PainterQB.InstrumentProperty{T}}) \n\u00b6\n\n\nCreates and exports immutable singleton subtypes.\n\n\nsource:\n\n\nPainterQB\\src\\Metaprogramming.jl:183", 
            "title": "E5071C"
        }, 
        {
            "location": "/api/E5071C/#painterqbe5071cmodule", 
            "text": "", 
            "title": "PainterQB.E5071CModule"
        }, 
        {
            "location": "/api/E5071C/#types-exported", 
            "text": "PainterQB.E5071CModule.ElectricalMedium  \u00b6  Signals may propagate on coax or waveguide media.  source:  PainterQB\\src\\instruments\\VNAs\\E5071C.jl:73", 
            "title": "Types [Exported]"
        }, 
        {
            "location": "/api/E5071C/#methods-internal", 
            "text": "generate_configure{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty{T}}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty{T}})  \u00b6  This method generates the following method in the module where generate_configure  is defined:  configure(ins::InsType, ::Type{PropertySubtype}, infixes...)  source:  PainterQB\\src\\Metaprogramming.jl:82    generate_configure{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty{T}}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty{T}},  ::Type{PainterQB.NoArgs})  \u00b6  This method generates the following method in the module where generate_configure  is defined:  configure(ins::InsType, ::Type{PropertySubtype}, infixes...)  This particular method will be deprecated soon.  source:  PainterQB\\src\\Metaprogramming.jl:122    generate_configure{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty{T}}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty{T}},  returntype...)  \u00b6  This method generates the following method in the module where generate_configure  is defined:  configure(ins::InsType, Property, values..., infixes...)  source:  PainterQB\\src\\Metaprogramming.jl:151    generate_handlers{T :PainterQB.Instrument}(insType::Type{T :PainterQB.Instrument},  responseDict::Dict{K, V})  \u00b6  Each instrument can have a  responseDict . For each setting of the instrument,\nfor instance the  ClockSource , we need to know the correspondence between a\nlogical state  ExternalClock  and how the instrument encodes that logical state\n(e.g. \"EXT\").  The  responseDict  is actually a dictionary of dictionaries. The first level keys\nare like  ClockSource  and the second level keys are like \"EXT\", with the value\nbeing  :ExternalClock . Undoubtedly\nthis nested dictionary is \"nasty\" (in the technical parlance) but the dictionary\nis only used for code\ncreation and is not used at run-time (if the code works as intended).  This method makes a lot of other functions. Given some response from an instrument,\nwe require a function to map that response back on to the appropiate logical state.  ClockSource(ins::AWG5014C, res::AbstractString) \nreturns an  InternalClock  or  ExternalClock  type as appropriate,\nbased on the logical meaning of the response.  We also want a function to generate logical states without having to know the way\nthey are encoded by the instrument.  code(ins::AWG5014C, ::Type{InternalClock})  returns \"INT\",\nwith \"INT\" encoding how to pass this logical state to the instrument  ins .  source:  PainterQB\\src\\Metaprogramming.jl:218    generate_inspect{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty{T}}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty{T}},  ::Type{PainterQB.NoArgs})  \u00b6  This method does/returns nothing.  source:  PainterQB\\src\\Metaprogramming.jl:14    generate_inspect{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty{T}}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty{T}},  returntype...)  \u00b6  This method will\ngenerate the following method in the module where  generate_inspect  is defined:  inspect(ins::instype, ::Type{proptype}, infixes::Int...)  The  infixes  variable argument allows for numbers to be inserted within the\ncommands, for instance in  OUTP#:FILT:FREQ , where the  #  sign should be\nreplaced by an integer. The replacements are done in the order of the arguments.\nError checking is done on the number of arguments.  For a given property,  inspect  will return either an InstrumentProperty subtype,\na number, a boolean, or a string as appropriate.  source:  PainterQB\\src\\Metaprogramming.jl:33    generate_properties{S :PainterQB.InstrumentProperty{T}}(subtype::Symbol,  supertype::Type{S :PainterQB.InstrumentProperty{T}})  \u00b6  Creates and exports immutable singleton subtypes.  source:  PainterQB\\src\\Metaprogramming.jl:183", 
            "title": "Methods [Internal]"
        }, 
        {
            "location": "/api/ZNB20/", 
            "text": "PainterQB.ZNB20Module\n\n\nMethods [Exported]\n\n\n\n\n\n\ncd(ins::PainterQB.ZNB20Module.ZNB20,  dir::AbstractString) \n\u00b6\n\n\nMMEMory:CDIRectory\n\n\nChange directories. Pass \"~\" for default.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\VNAs\\ZNB20.jl:184\n\n\n\n\n\n\ncp(ins::PainterQB.ZNB20Module.ZNB20,  src::AbstractString,  dest::AbstractString) \n\u00b6\n\n\nMMEMory:COPY\n\n\nCopy a file.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\VNAs\\ZNB20.jl:197\n\n\n\n\n\n\nhidetrace(ins::PainterQB.ZNB20Module.ZNB20,  win::Int64,  wtrace::Int64) \n\u00b6\n\n\nDISPLAY:WINDOW#:TRACE#:DELETE\n\n\nReleases the assignment of window trace \nwtrace\n to window \nwin\n.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\VNAs\\ZNB20.jl:206\n\n\n\n\n\n\nlstrace(ins::PainterQB.ZNB20Module.ZNB20,  ch::Int64) \n\u00b6\n\n\nCALCULATE#:PARAMETER:CATALOG?\n\n\nReport the traces assigned to a given channel.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\VNAs\\ZNB20.jl:215\n\n\n\n\n\n\nmkdir(ins::PainterQB.ZNB20Module.ZNB20,  dir::AbstractString) \n\u00b6\n\n\nMMEMory:MDIRectory\n\n\nMake a directory.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\VNAs\\ZNB20.jl:240\n\n\n\n\n\n\nmktrace(ins::PainterQB.ZNB20Module.ZNB20,  name::AbstractString,  parameter,  ch::Int64) \n\u00b6\n\n\nCALCulate#:PARameter:SDEFine\n\n\nCreate a new trace with \nname\n and measurement \nparameter\n on channel \nch\n.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\VNAs\\ZNB20.jl:249\n\n\n\n\n\n\npwd(ins::PainterQB.ZNB20Module.ZNB20) \n\u00b6\n\n\nMMEMory:CDIRectory?\n\n\nPrint the working directory.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\VNAs\\ZNB20.jl:260\n\n\n\n\n\n\nreaddir(ins::PainterQB.ZNB20Module.ZNB20) \n\u00b6\n\n\nMMEMory:CATalog?\n\n\nRead the directory contents.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\VNAs\\ZNB20.jl:269\n\n\n\n\n\n\nreaddir(ins::PainterQB.ZNB20Module.ZNB20,  dir::AbstractString) \n\u00b6\n\n\nMMEMory:CATalog?\n\n\nRead the directory contents.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\VNAs\\ZNB20.jl:269\n\n\n\n\n\n\nrm(ins::PainterQB.ZNB20Module.ZNB20,  file::AbstractString) \n\u00b6\n\n\nMMEMory:DELete\n\n\nRemove a file.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\VNAs\\ZNB20.jl:282\n\n\n\n\n\n\nrmtrace(ins::PainterQB.ZNB20Module.ZNB20) \n\u00b6\n\n\nCALCulate:PARameter:DELete:ALL\n\n\nDeletes all traces in all channels.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\VNAs\\ZNB20.jl:310\n\n\n\n\n\n\nrmtrace(ins::PainterQB.ZNB20Module.ZNB20,  ch::Int64) \n\u00b6\n\n\nCALCulate#:PARameter:DELete:CALL\n\n\nDeletes all traces in the given channel.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\VNAs\\ZNB20.jl:301\n\n\n\n\n\n\nrmtrace(ins::PainterQB.ZNB20Module.ZNB20,  name::AbstractString,  ch::Int64) \n\u00b6\n\n\nCALCULATE#:PARAMETER:DELETE\n\n\nRemove trace with name \nname\n from channel \nch\n.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\VNAs\\ZNB20.jl:292\n\n\n\n\n\n\nshowtrace(ins::PainterQB.ZNB20Module.ZNB20,  name::AbstractString,  win::Int64,  wtrace::Int64) \n\u00b6\n\n\nDISPLAY:WINDOW#:TRACE#:FEED\n\n\nShow a trace named \nname\n in window \nwin::Int\n as\nwindow trace number \nwtrace::Int\n.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\VNAs\\ZNB20.jl:321\n\n\nTypes [Exported]\n\n\n\n\n\n\nPainterQB.ZNB20Module.AutoSweepTime \n\u00b6\n\n\nConfigure or inspect. Does the instrument choose the minimum sweep time?\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\VNAs\\ZNB20.jl:62\n\n\n\n\n\n\nPainterQB.ZNB20Module.DisplayUpdate \n\u00b6\n\n\nConfigure or inspect. Display updates during measurement.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\VNAs\\ZNB20.jl:65\n\n\n\n\n\n\nPainterQB.ZNB20Module.SweepTime \n\u00b6\n\n\nConfigure or inspect. Adjust time it takes to complete a sweep (all partial measurements).\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\VNAs\\ZNB20.jl:68\n\n\n\n\n\n\nPainterQB.ZNB20Module.Window \n\u00b6\n\n\nInstrumentProperty\n: Window.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\VNAs\\ZNB20.jl:71\n\n\nMethods [Internal]\n\n\n\n\n\n\nconfigure(ins::PainterQB.ZNB20Module.ZNB20,  ::Type{PainterQB.NumPoints},  n::Int64) \n\u00b6\n\n\nSENSE#:SWEEP:POINTS\n\n\nDefine measurement points per sweep. Channel \nch\n defaults to 1.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\VNAs\\ZNB20.jl:100\n\n\n\n\n\n\nconfigure(ins::PainterQB.ZNB20Module.ZNB20,  ::Type{PainterQB.NumPoints},  n::Int64,  ch::Int64) \n\u00b6\n\n\nSENSE#:SWEEP:POINTS\n\n\nDefine measurement points per sweep. Channel \nch\n defaults to 1.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\VNAs\\ZNB20.jl:100\n\n\n\n\n\n\nconfigure(ins::PainterQB.ZNB20Module.ZNB20,  ::Type{PainterQB.ZNB20Module.AutoSweepTime},  b::Bool) \n\u00b6\n\n\nSENSE#:SWEEP:TIME:AUTO\n\n\nDetermines whether or not the instrument chooses the minimum sweep time,\nincluding all partial measurements. Channel \nch\n defaults to 1.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\VNAs\\ZNB20.jl:83\n\n\n\n\n\n\nconfigure(ins::PainterQB.ZNB20Module.ZNB20,  ::Type{PainterQB.ZNB20Module.AutoSweepTime},  b::Bool,  ch::Int64) \n\u00b6\n\n\nSENSE#:SWEEP:TIME:AUTO\n\n\nDetermines whether or not the instrument chooses the minimum sweep time,\nincluding all partial measurements. Channel \nch\n defaults to 1.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\VNAs\\ZNB20.jl:83\n\n\n\n\n\n\nconfigure(ins::PainterQB.ZNB20Module.ZNB20,  ::Type{PainterQB.ZNB20Module.DisplayUpdate},  b::Bool) \n\u00b6\n\n\nSYSTEM:DISPLAY:UPDATE\n\n\nSwitches display update on / off.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\VNAs\\ZNB20.jl:91\n\n\n\n\n\n\nconfigure(ins::PainterQB.ZNB20Module.ZNB20,  ::Type{PainterQB.ZNB20Module.SweepTime},  time::Real) \n\u00b6\n\n\nSENSE#:SWEEP:TIME\n\n\nDefine the time to complete a sweep, including all partial measurements.\nChannel \nch\n defaults to 1.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\VNAs\\ZNB20.jl:111\n\n\n\n\n\n\nconfigure(ins::PainterQB.ZNB20Module.ZNB20,  ::Type{PainterQB.ZNB20Module.SweepTime},  time::Real,  ch::Int64) \n\u00b6\n\n\nSENSE#:SWEEP:TIME\n\n\nDefine the time to complete a sweep, including all partial measurements.\nChannel \nch\n defaults to 1.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\VNAs\\ZNB20.jl:111\n\n\n\n\n\n\nconfigure(ins::PainterQB.ZNB20Module.ZNB20,  ::Type{PainterQB.ZNB20Module.Window},  b::Bool,  win::Int64) \n\u00b6\n\n\nDISPLAY:WINDOW#:STATE\n\n\nTurn a window on or off.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\VNAs\\ZNB20.jl:119\n\n\n\n\n\n\ngenerate_configure{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty{T}}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty{T}}) \n\u00b6\n\n\nThis method generates the following method in the module where\n\ngenerate_configure\n is defined:\n\n\nconfigure(ins::InsType, ::Type{PropertySubtype}, infixes...)\n\n\n\n\nsource:\n\n\nPainterQB\\src\\Metaprogramming.jl:82\n\n\n\n\n\n\ngenerate_configure{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty{T}}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty{T}},  ::Type{PainterQB.NoArgs}) \n\u00b6\n\n\nThis method generates the following method in the module where\n\ngenerate_configure\n is defined:\n\n\nconfigure(ins::InsType, ::Type{PropertySubtype}, infixes...)\n\n\n\n\nThis particular method will be deprecated soon.\n\n\nsource:\n\n\nPainterQB\\src\\Metaprogramming.jl:122\n\n\n\n\n\n\ngenerate_configure{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty{T}}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty{T}},  returntype...) \n\u00b6\n\n\nThis method generates the following method in the module where\n\ngenerate_configure\n is defined:\n\n\nconfigure(ins::InsType, Property, values..., infixes...)\n\n\n\n\nsource:\n\n\nPainterQB\\src\\Metaprogramming.jl:151\n\n\n\n\n\n\ngenerate_handlers{T\n:PainterQB.Instrument}(insType::Type{T\n:PainterQB.Instrument},  responseDict::Dict{K, V}) \n\u00b6\n\n\nEach instrument can have a \nresponseDict\n. For each setting of the instrument,\nfor instance the \nClockSource\n, we need to know the correspondence between a\nlogical state \nExternalClock\n and how the instrument encodes that logical state\n(e.g. \"EXT\").\n\n\nThe \nresponseDict\n is actually a dictionary of dictionaries. The first level keys\nare like \nClockSource\n and the second level keys are like \"EXT\", with the value\nbeing \n:ExternalClock\n. Undoubtedly\nthis nested dictionary is \"nasty\" (in the technical parlance) but the dictionary\nis only used for code\ncreation and is not used at run-time (if the code works as intended).\n\n\nThis method makes a lot of other functions. Given some response from an instrument,\nwe require a function to map that response back on to the appropiate logical state.\n\n\nClockSource(ins::AWG5014C, res::AbstractString)\n\nreturns an \nInternalClock\n or \nExternalClock\n type as appropriate,\nbased on the logical meaning of the response.\n\n\nWe also want a function to generate logical states without having to know the way\nthey are encoded by the instrument.\n\n\ncode(ins::AWG5014C, ::Type{InternalClock})\n returns \"INT\",\nwith \"INT\" encoding how to pass this logical state to the instrument \nins\n.\n\n\nsource:\n\n\nPainterQB\\src\\Metaprogramming.jl:218\n\n\n\n\n\n\ngenerate_inspect{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty{T}}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty{T}},  ::Type{PainterQB.NoArgs}) \n\u00b6\n\n\nThis method does/returns nothing.\n\n\nsource:\n\n\nPainterQB\\src\\Metaprogramming.jl:14\n\n\n\n\n\n\ngenerate_inspect{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty{T}}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty{T}},  returntype...) \n\u00b6\n\n\nThis method will\ngenerate the following method in the module where \ngenerate_inspect\n is defined:\n\n\ninspect(ins::instype, ::Type{proptype}, infixes::Int...)\n\n\nThe \ninfixes\n variable argument allows for numbers to be inserted within the\ncommands, for instance in \nOUTP#:FILT:FREQ\n, where the \n#\n sign should be\nreplaced by an integer. The replacements are done in the order of the arguments.\nError checking is done on the number of arguments.\n\n\nFor a given property, \ninspect\n will return either an InstrumentProperty subtype,\na number, a boolean, or a string as appropriate.\n\n\nsource:\n\n\nPainterQB\\src\\Metaprogramming.jl:33\n\n\n\n\n\n\ngenerate_properties{S\n:PainterQB.InstrumentProperty{T}}(subtype::Symbol,  supertype::Type{S\n:PainterQB.InstrumentProperty{T}}) \n\u00b6\n\n\nCreates and exports immutable singleton subtypes.\n\n\nsource:\n\n\nPainterQB\\src\\Metaprogramming.jl:183\n\n\n\n\n\n\ninspect(ins::PainterQB.ZNB20Module.ZNB20,  ::Type{PainterQB.NumPoints}) \n\u00b6\n\n\nSENSE#:SWEEP:POINTS\n\n\nHow many measurement points per sweep? Channel \nch\n defaults to 1.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\VNAs\\ZNB20.jl:147\n\n\n\n\n\n\ninspect(ins::PainterQB.ZNB20Module.ZNB20,  ::Type{PainterQB.NumPoints},  ch::Int64) \n\u00b6\n\n\nSENSE#:SWEEP:POINTS\n\n\nHow many measurement points per sweep? Channel \nch\n defaults to 1.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\VNAs\\ZNB20.jl:147\n\n\n\n\n\n\ninspect(ins::PainterQB.ZNB20Module.ZNB20,  ::Type{PainterQB.ZNB20Module.AutoSweepTime}) \n\u00b6\n\n\nSENSE#:SWEEP:TIME:AUTO\n\n\nDoes the instrument choose the minimum sweep time,\nincluding all partial measurements? Channel \nch\n defaults to 1.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\VNAs\\ZNB20.jl:130\n\n\n\n\n\n\ninspect(ins::PainterQB.ZNB20Module.ZNB20,  ::Type{PainterQB.ZNB20Module.AutoSweepTime},  ch::Int64) \n\u00b6\n\n\nSENSE#:SWEEP:TIME:AUTO\n\n\nDoes the instrument choose the minimum sweep time,\nincluding all partial measurements? Channel \nch\n defaults to 1.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\VNAs\\ZNB20.jl:130\n\n\n\n\n\n\ninspect(ins::PainterQB.ZNB20Module.ZNB20,  ::Type{PainterQB.ZNB20Module.DisplayUpdate}) \n\u00b6\n\n\nSYSTEM:DISPLAY:UPDATE\n\n\nIs the display updating?\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\VNAs\\ZNB20.jl:138\n\n\n\n\n\n\ninspect(ins::PainterQB.ZNB20Module.ZNB20,  ::Type{PainterQB.ZNB20Module.SweepTime}) \n\u00b6\n\n\nSENSE#:SWEEP:TIME\n\n\nDefine the time to complete a sweep, including all partial measurements.\nChannel \nch\n defaults to 1.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\VNAs\\ZNB20.jl:158\n\n\n\n\n\n\ninspect(ins::PainterQB.ZNB20Module.ZNB20,  ::Type{PainterQB.ZNB20Module.SweepTime},  ch::Int64) \n\u00b6\n\n\nSENSE#:SWEEP:TIME\n\n\nDefine the time to complete a sweep, including all partial measurements.\nChannel \nch\n defaults to 1.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\VNAs\\ZNB20.jl:158\n\n\n\n\n\n\ninspect(ins::PainterQB.ZNB20Module.ZNB20,  ::Type{PainterQB.ZNB20Module.Window},  win::Int64) \n\u00b6\n\n\nDetermines if a window exists, by window number. See \nlswindow\n.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\VNAs\\ZNB20.jl:163\n\n\n\n\n\n\ninspect(ins::PainterQB.ZNB20Module.ZNB20,  ::Type{PainterQB.ZNB20Module.Window},  wname::AbstractString) \n\u00b6\n\n\nDetermines if a window exists, by window name. See \nlswindow\n.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\VNAs\\ZNB20.jl:171\n\n\n\n\n\n\nlswindows(ins::PainterQB.ZNB20Module.ZNB20) \n\u00b6\n\n\nDISPLAY:CATALOG?\n\n\nReport the windows and their names in a tuple: (\narrNums::Array{Int64,1}\n,\n    \narrNames::Array{SubString{ASCIIString},1})\n).\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\VNAs\\ZNB20.jl:226", 
            "title": "ZNB20"
        }, 
        {
            "location": "/api/ZNB20/#painterqbznb20module", 
            "text": "", 
            "title": "PainterQB.ZNB20Module"
        }, 
        {
            "location": "/api/ZNB20/#methods-exported", 
            "text": "cd(ins::PainterQB.ZNB20Module.ZNB20,  dir::AbstractString)  \u00b6  MMEMory:CDIRectory  Change directories. Pass \"~\" for default.  source:  PainterQB\\src\\instruments\\VNAs\\ZNB20.jl:184    cp(ins::PainterQB.ZNB20Module.ZNB20,  src::AbstractString,  dest::AbstractString)  \u00b6  MMEMory:COPY  Copy a file.  source:  PainterQB\\src\\instruments\\VNAs\\ZNB20.jl:197    hidetrace(ins::PainterQB.ZNB20Module.ZNB20,  win::Int64,  wtrace::Int64)  \u00b6  DISPLAY:WINDOW#:TRACE#:DELETE  Releases the assignment of window trace  wtrace  to window  win .  source:  PainterQB\\src\\instruments\\VNAs\\ZNB20.jl:206    lstrace(ins::PainterQB.ZNB20Module.ZNB20,  ch::Int64)  \u00b6  CALCULATE#:PARAMETER:CATALOG?  Report the traces assigned to a given channel.  source:  PainterQB\\src\\instruments\\VNAs\\ZNB20.jl:215    mkdir(ins::PainterQB.ZNB20Module.ZNB20,  dir::AbstractString)  \u00b6  MMEMory:MDIRectory  Make a directory.  source:  PainterQB\\src\\instruments\\VNAs\\ZNB20.jl:240    mktrace(ins::PainterQB.ZNB20Module.ZNB20,  name::AbstractString,  parameter,  ch::Int64)  \u00b6  CALCulate#:PARameter:SDEFine  Create a new trace with  name  and measurement  parameter  on channel  ch .  source:  PainterQB\\src\\instruments\\VNAs\\ZNB20.jl:249    pwd(ins::PainterQB.ZNB20Module.ZNB20)  \u00b6  MMEMory:CDIRectory?  Print the working directory.  source:  PainterQB\\src\\instruments\\VNAs\\ZNB20.jl:260    readdir(ins::PainterQB.ZNB20Module.ZNB20)  \u00b6  MMEMory:CATalog?  Read the directory contents.  source:  PainterQB\\src\\instruments\\VNAs\\ZNB20.jl:269    readdir(ins::PainterQB.ZNB20Module.ZNB20,  dir::AbstractString)  \u00b6  MMEMory:CATalog?  Read the directory contents.  source:  PainterQB\\src\\instruments\\VNAs\\ZNB20.jl:269    rm(ins::PainterQB.ZNB20Module.ZNB20,  file::AbstractString)  \u00b6  MMEMory:DELete  Remove a file.  source:  PainterQB\\src\\instruments\\VNAs\\ZNB20.jl:282    rmtrace(ins::PainterQB.ZNB20Module.ZNB20)  \u00b6  CALCulate:PARameter:DELete:ALL  Deletes all traces in all channels.  source:  PainterQB\\src\\instruments\\VNAs\\ZNB20.jl:310    rmtrace(ins::PainterQB.ZNB20Module.ZNB20,  ch::Int64)  \u00b6  CALCulate#:PARameter:DELete:CALL  Deletes all traces in the given channel.  source:  PainterQB\\src\\instruments\\VNAs\\ZNB20.jl:301    rmtrace(ins::PainterQB.ZNB20Module.ZNB20,  name::AbstractString,  ch::Int64)  \u00b6  CALCULATE#:PARAMETER:DELETE  Remove trace with name  name  from channel  ch .  source:  PainterQB\\src\\instruments\\VNAs\\ZNB20.jl:292    showtrace(ins::PainterQB.ZNB20Module.ZNB20,  name::AbstractString,  win::Int64,  wtrace::Int64)  \u00b6  DISPLAY:WINDOW#:TRACE#:FEED  Show a trace named  name  in window  win::Int  as\nwindow trace number  wtrace::Int .  source:  PainterQB\\src\\instruments\\VNAs\\ZNB20.jl:321", 
            "title": "Methods [Exported]"
        }, 
        {
            "location": "/api/ZNB20/#types-exported", 
            "text": "PainterQB.ZNB20Module.AutoSweepTime  \u00b6  Configure or inspect. Does the instrument choose the minimum sweep time?  source:  PainterQB\\src\\instruments\\VNAs\\ZNB20.jl:62    PainterQB.ZNB20Module.DisplayUpdate  \u00b6  Configure or inspect. Display updates during measurement.  source:  PainterQB\\src\\instruments\\VNAs\\ZNB20.jl:65    PainterQB.ZNB20Module.SweepTime  \u00b6  Configure or inspect. Adjust time it takes to complete a sweep (all partial measurements).  source:  PainterQB\\src\\instruments\\VNAs\\ZNB20.jl:68    PainterQB.ZNB20Module.Window  \u00b6  InstrumentProperty : Window.  source:  PainterQB\\src\\instruments\\VNAs\\ZNB20.jl:71", 
            "title": "Types [Exported]"
        }, 
        {
            "location": "/api/ZNB20/#methods-internal", 
            "text": "configure(ins::PainterQB.ZNB20Module.ZNB20,  ::Type{PainterQB.NumPoints},  n::Int64)  \u00b6  SENSE#:SWEEP:POINTS  Define measurement points per sweep. Channel  ch  defaults to 1.  source:  PainterQB\\src\\instruments\\VNAs\\ZNB20.jl:100    configure(ins::PainterQB.ZNB20Module.ZNB20,  ::Type{PainterQB.NumPoints},  n::Int64,  ch::Int64)  \u00b6  SENSE#:SWEEP:POINTS  Define measurement points per sweep. Channel  ch  defaults to 1.  source:  PainterQB\\src\\instruments\\VNAs\\ZNB20.jl:100    configure(ins::PainterQB.ZNB20Module.ZNB20,  ::Type{PainterQB.ZNB20Module.AutoSweepTime},  b::Bool)  \u00b6  SENSE#:SWEEP:TIME:AUTO  Determines whether or not the instrument chooses the minimum sweep time,\nincluding all partial measurements. Channel  ch  defaults to 1.  source:  PainterQB\\src\\instruments\\VNAs\\ZNB20.jl:83    configure(ins::PainterQB.ZNB20Module.ZNB20,  ::Type{PainterQB.ZNB20Module.AutoSweepTime},  b::Bool,  ch::Int64)  \u00b6  SENSE#:SWEEP:TIME:AUTO  Determines whether or not the instrument chooses the minimum sweep time,\nincluding all partial measurements. Channel  ch  defaults to 1.  source:  PainterQB\\src\\instruments\\VNAs\\ZNB20.jl:83    configure(ins::PainterQB.ZNB20Module.ZNB20,  ::Type{PainterQB.ZNB20Module.DisplayUpdate},  b::Bool)  \u00b6  SYSTEM:DISPLAY:UPDATE  Switches display update on / off.  source:  PainterQB\\src\\instruments\\VNAs\\ZNB20.jl:91    configure(ins::PainterQB.ZNB20Module.ZNB20,  ::Type{PainterQB.ZNB20Module.SweepTime},  time::Real)  \u00b6  SENSE#:SWEEP:TIME  Define the time to complete a sweep, including all partial measurements.\nChannel  ch  defaults to 1.  source:  PainterQB\\src\\instruments\\VNAs\\ZNB20.jl:111    configure(ins::PainterQB.ZNB20Module.ZNB20,  ::Type{PainterQB.ZNB20Module.SweepTime},  time::Real,  ch::Int64)  \u00b6  SENSE#:SWEEP:TIME  Define the time to complete a sweep, including all partial measurements.\nChannel  ch  defaults to 1.  source:  PainterQB\\src\\instruments\\VNAs\\ZNB20.jl:111    configure(ins::PainterQB.ZNB20Module.ZNB20,  ::Type{PainterQB.ZNB20Module.Window},  b::Bool,  win::Int64)  \u00b6  DISPLAY:WINDOW#:STATE  Turn a window on or off.  source:  PainterQB\\src\\instruments\\VNAs\\ZNB20.jl:119    generate_configure{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty{T}}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty{T}})  \u00b6  This method generates the following method in the module where generate_configure  is defined:  configure(ins::InsType, ::Type{PropertySubtype}, infixes...)  source:  PainterQB\\src\\Metaprogramming.jl:82    generate_configure{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty{T}}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty{T}},  ::Type{PainterQB.NoArgs})  \u00b6  This method generates the following method in the module where generate_configure  is defined:  configure(ins::InsType, ::Type{PropertySubtype}, infixes...)  This particular method will be deprecated soon.  source:  PainterQB\\src\\Metaprogramming.jl:122    generate_configure{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty{T}}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty{T}},  returntype...)  \u00b6  This method generates the following method in the module where generate_configure  is defined:  configure(ins::InsType, Property, values..., infixes...)  source:  PainterQB\\src\\Metaprogramming.jl:151    generate_handlers{T :PainterQB.Instrument}(insType::Type{T :PainterQB.Instrument},  responseDict::Dict{K, V})  \u00b6  Each instrument can have a  responseDict . For each setting of the instrument,\nfor instance the  ClockSource , we need to know the correspondence between a\nlogical state  ExternalClock  and how the instrument encodes that logical state\n(e.g. \"EXT\").  The  responseDict  is actually a dictionary of dictionaries. The first level keys\nare like  ClockSource  and the second level keys are like \"EXT\", with the value\nbeing  :ExternalClock . Undoubtedly\nthis nested dictionary is \"nasty\" (in the technical parlance) but the dictionary\nis only used for code\ncreation and is not used at run-time (if the code works as intended).  This method makes a lot of other functions. Given some response from an instrument,\nwe require a function to map that response back on to the appropiate logical state.  ClockSource(ins::AWG5014C, res::AbstractString) \nreturns an  InternalClock  or  ExternalClock  type as appropriate,\nbased on the logical meaning of the response.  We also want a function to generate logical states without having to know the way\nthey are encoded by the instrument.  code(ins::AWG5014C, ::Type{InternalClock})  returns \"INT\",\nwith \"INT\" encoding how to pass this logical state to the instrument  ins .  source:  PainterQB\\src\\Metaprogramming.jl:218    generate_inspect{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty{T}}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty{T}},  ::Type{PainterQB.NoArgs})  \u00b6  This method does/returns nothing.  source:  PainterQB\\src\\Metaprogramming.jl:14    generate_inspect{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty{T}}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty{T}},  returntype...)  \u00b6  This method will\ngenerate the following method in the module where  generate_inspect  is defined:  inspect(ins::instype, ::Type{proptype}, infixes::Int...)  The  infixes  variable argument allows for numbers to be inserted within the\ncommands, for instance in  OUTP#:FILT:FREQ , where the  #  sign should be\nreplaced by an integer. The replacements are done in the order of the arguments.\nError checking is done on the number of arguments.  For a given property,  inspect  will return either an InstrumentProperty subtype,\na number, a boolean, or a string as appropriate.  source:  PainterQB\\src\\Metaprogramming.jl:33    generate_properties{S :PainterQB.InstrumentProperty{T}}(subtype::Symbol,  supertype::Type{S :PainterQB.InstrumentProperty{T}})  \u00b6  Creates and exports immutable singleton subtypes.  source:  PainterQB\\src\\Metaprogramming.jl:183    inspect(ins::PainterQB.ZNB20Module.ZNB20,  ::Type{PainterQB.NumPoints})  \u00b6  SENSE#:SWEEP:POINTS  How many measurement points per sweep? Channel  ch  defaults to 1.  source:  PainterQB\\src\\instruments\\VNAs\\ZNB20.jl:147    inspect(ins::PainterQB.ZNB20Module.ZNB20,  ::Type{PainterQB.NumPoints},  ch::Int64)  \u00b6  SENSE#:SWEEP:POINTS  How many measurement points per sweep? Channel  ch  defaults to 1.  source:  PainterQB\\src\\instruments\\VNAs\\ZNB20.jl:147    inspect(ins::PainterQB.ZNB20Module.ZNB20,  ::Type{PainterQB.ZNB20Module.AutoSweepTime})  \u00b6  SENSE#:SWEEP:TIME:AUTO  Does the instrument choose the minimum sweep time,\nincluding all partial measurements? Channel  ch  defaults to 1.  source:  PainterQB\\src\\instruments\\VNAs\\ZNB20.jl:130    inspect(ins::PainterQB.ZNB20Module.ZNB20,  ::Type{PainterQB.ZNB20Module.AutoSweepTime},  ch::Int64)  \u00b6  SENSE#:SWEEP:TIME:AUTO  Does the instrument choose the minimum sweep time,\nincluding all partial measurements? Channel  ch  defaults to 1.  source:  PainterQB\\src\\instruments\\VNAs\\ZNB20.jl:130    inspect(ins::PainterQB.ZNB20Module.ZNB20,  ::Type{PainterQB.ZNB20Module.DisplayUpdate})  \u00b6  SYSTEM:DISPLAY:UPDATE  Is the display updating?  source:  PainterQB\\src\\instruments\\VNAs\\ZNB20.jl:138    inspect(ins::PainterQB.ZNB20Module.ZNB20,  ::Type{PainterQB.ZNB20Module.SweepTime})  \u00b6  SENSE#:SWEEP:TIME  Define the time to complete a sweep, including all partial measurements.\nChannel  ch  defaults to 1.  source:  PainterQB\\src\\instruments\\VNAs\\ZNB20.jl:158    inspect(ins::PainterQB.ZNB20Module.ZNB20,  ::Type{PainterQB.ZNB20Module.SweepTime},  ch::Int64)  \u00b6  SENSE#:SWEEP:TIME  Define the time to complete a sweep, including all partial measurements.\nChannel  ch  defaults to 1.  source:  PainterQB\\src\\instruments\\VNAs\\ZNB20.jl:158    inspect(ins::PainterQB.ZNB20Module.ZNB20,  ::Type{PainterQB.ZNB20Module.Window},  win::Int64)  \u00b6  Determines if a window exists, by window number. See  lswindow .  source:  PainterQB\\src\\instruments\\VNAs\\ZNB20.jl:163    inspect(ins::PainterQB.ZNB20Module.ZNB20,  ::Type{PainterQB.ZNB20Module.Window},  wname::AbstractString)  \u00b6  Determines if a window exists, by window name. See  lswindow .  source:  PainterQB\\src\\instruments\\VNAs\\ZNB20.jl:171    lswindows(ins::PainterQB.ZNB20Module.ZNB20)  \u00b6  DISPLAY:CATALOG?  Report the windows and their names in a tuple: ( arrNums::Array{Int64,1} ,\n     arrNames::Array{SubString{ASCIIString},1}) ).  source:  PainterQB\\src\\instruments\\VNAs\\ZNB20.jl:226", 
            "title": "Methods [Internal]"
        }, 
        {
            "location": "/api/AWG5014C/", 
            "text": "PainterQB.AWG5014CModule\n\n\nFunctions [Exported]\n\n\n\n\n\n\nPainterQB.AWG5014CModule.applicationstate \n\u00b6\n\n\nIs an application running?\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:541\n\n\n\n\n\n\nPainterQB.AWG5014CModule.clearwaveforms \n\u00b6\n\n\nClear waveforms from all channels.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:565\n\n\n\n\n\n\nPainterQB.AWG5014CModule.deletewaveform \n\u00b6\n\n\nDelete a waveform by name.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:572\n\n\n\n\n\n\nPainterQB.AWG5014CModule.load_awg_settings \n\u00b6\n\n\nLoad an AWG settings file.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:548\n\n\n\n\n\n\nPainterQB.AWG5014CModule.newwaveform \n\u00b6\n\n\nCreate a new waveform by name, number of points, and waveform type.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:580\n\n\n\n\n\n\nPainterQB.AWG5014CModule.normalizewaveform \n\u00b6\n\n\nNormalize a waveform.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:587\n\n\n\n\n\n\nPainterQB.AWG5014CModule.pullfrom_awg \n\u00b6\n\n\nPull data from the AWG, performing checks and generating errors as appropriate.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:761\n\n\n\n\n\n\nPainterQB.AWG5014CModule.pushto_awg \n\u00b6\n\n\nPush waveform data to the AWG, performing checks and generating errors as appropriate.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:687\n\n\n\n\n\n\nPainterQB.AWG5014CModule.resamplewaveform \n\u00b6\n\n\nResample a waveform.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:594\n\n\n\n\n\n\nPainterQB.AWG5014CModule.runapplication \n\u00b6\n\n\nRun an application, e.g. SerialXpress\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:534\n\n\n\n\n\n\nPainterQB.AWG5014CModule.save_awg_settings \n\u00b6\n\n\nSave an AWG settings file.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:555\n\n\n\n\n\n\nPainterQB.AWG5014CModule.validate \n\u00b6\n\n\nValidates data to be pushed to the AWG to check for internal consistency\nand appropriate range.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:742\n\n\n\n\n\n\nPainterQB.AWG5014CModule.waveform \n\u00b6\n\n\nUses Julia style indexing (begins at 1) to retrieve the name of a waveform\nfrom the waveform list.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:631\n\n\n\n\n\n\nPainterQB.AWG5014CModule.waveformexists \n\u00b6\n\n\nDoes a waveform identified by \nname\n exist?\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:607\n\n\n\n\n\n\nPainterQB.AWG5014CModule.waveformispredefined \n\u00b6\n\n\nReturns whether or not a waveform is predefined (comes with instrument).\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:614\n\n\n\n\n\n\nPainterQB.AWG5014CModule.waveformlength \n\u00b6\n\n\nReturns the length of a waveform.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:621\n\n\n\n\n\n\nPainterQB.AWG5014CModule.waveformtimestamp \n\u00b6\n\n\nReturn the timestamp for when a waveform was last updated.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:638\n\n\n\n\n\n\nPainterQB.AWG5014CModule.waveformtype \n\u00b6\n\n\nReturns the type of the waveform. The AWG hardware\nultimately uses an \nIntWaveform\n but \nRealWaveform\n is more convenient.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:648\n\n\nTypes [Exported]\n\n\n\n\n\n\nPainterQB.AWG5014CModule.AWG5014C \n\u00b6\n\n\nConcrete type representing an AWG5014C.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:95\n\n\n\n\n\n\nPainterQB.AWG5014CModule.AWG5014CData \n\u00b6\n\n\nType for storing waveform data (including markers) in Float32 format.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:114\n\n\n\n\n\n\nPainterQB.AWG5014CModule.Amplitude \n\u00b6\n\n\nAmplitude for a given channel.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:238\n\n\n\n\n\n\nPainterQB.AWG5014CModule.AnalogOutputDelay \n\u00b6\n\n\nAnalog output delay for a given channel.\nThe effect of this command can be seen only in non-sequence mode.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:245\n\n\n\n\n\n\nPainterQB.AWG5014CModule.ChannelOutput \n\u00b6\n\n\nBoolean state of the output for a given channel.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:249\n\n\n\n\n\n\nPainterQB.AWG5014CModule.DCOutput \n\u00b6\n\n\nBoolean state of the DC output for a given channel (bottom-right of AWG).\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:254\n\n\n\n\n\n\nPainterQB.AWG5014CModule.DCOutputLevel \n\u00b6\n\n\nDC output level for a given channel.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:259\n\n\n\n\n\n\nPainterQB.AWG5014CModule.EventImpedance \n\u00b6\n\n\nEvent input impedance may be 50 Ohm or 1 kOhm.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:134\n\n\n\n\n\n\nPainterQB.AWG5014CModule.EventSlope \n\u00b6\n\n\nEvent may fire on a rising or falling slope.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:137\n\n\n\n\n\n\nPainterQB.AWG5014CModule.EventTiming \n\u00b6\n\n\nEvents may occur synchronously or asynchronously.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:140\n\n\n\n\n\n\nPainterQB.AWG5014CModule.ExtInputAddsToOutput \n\u00b6\n\n\nAdd the signal from an external input to the given channel output.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:264\n\n\n\n\n\n\nPainterQB.AWG5014CModule.ExtOscDividerRate \n\u00b6\n\n\nDivider rate of the external oscillator; must be a power of 2 (1 ok).\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:269\n\n\n\n\n\n\nPainterQB.AWG5014CModule.MarkerDelay \n\u00b6\n\n\nMarker delay for a given channel and marker. Marker can be 1 or 2.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:274\n\n\n\n\n\n\nPainterQB.AWG5014CModule.OutputFilterFrequency \n\u00b6\n\n\nLow-pass filter frequency for the output. INF = 9.9e37\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:279\n\n\n\n\n\n\nPainterQB.AWG5014CModule.RefOscFrequency \n\u00b6\n\n\nReference oscillator frequency.\n\n\nValid values are 10 MHz, 20 MHz and 100 MHz. Used when:\n\n\n\n\nClock Source is Internal\n\n\nReference Input is External\n\n\nExternal Reference Type is Fixed.\n\n\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:294\n\n\n\n\n\n\nPainterQB.AWG5014CModule.RefOscMultiplier \n\u00b6\n\n\nReference oscillator multiplier.\n\n\nUsed when:\n- Clock Source is Internal\n- Reference Source is External\n- External Reference Type is Variable.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:304\n\n\n\n\n\n\nPainterQB.AWG5014CModule.RepRate \n\u00b6\n\n\nRepetition rate (frequency of waveform). Changing this will change the\nsampling rate.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:307\n\n\n\n\n\n\nPainterQB.AWG5014CModule.RepRateHeld \n\u00b6\n\n\nBoolean hold state of the repetition rate. If held, the repetition rate will\nnot change when the size of the waveform changes.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:313\n\n\n\n\n\n\nPainterQB.AWG5014CModule.SCPIVersion \n\u00b6\n\n\nThe SCPI version of the AWG.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:316\n\n\n\n\n\n\nPainterQB.AWG5014CModule.SequencerEventJumpTarget \n\u00b6\n\n\nTarget index for the sequencer event jump operation.\nNote that this will take effect only when\nSEQuence:ELEMent[n]:JTARget:TYPE is set to INDex.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:324\n\n\n\n\n\n\nPainterQB.AWG5014CModule.SequencerGOTOState \n\u00b6\n\n\nBoolean GOTO state of the sequencer.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:331\n\n\n\n\n\n\nPainterQB.AWG5014CModule.SequencerGOTOTarget \n\u00b6\n\n\nTarget index for the GOTO command of the sequencer.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:327\n\n\n\n\n\n\nPainterQB.AWG5014CModule.SequencerInfiniteLoop \n\u00b6\n\n\nBoolean state of infinite loop on a sequencer element.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:334\n\n\n\n\n\n\nPainterQB.AWG5014CModule.SequencerLength \n\u00b6\n\n\nLength of the sequence. Can be destructive to existing sequences.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:337\n\n\n\n\n\n\nPainterQB.AWG5014CModule.SequencerLoopCount \n\u00b6\n\n\nLoop count of the sequencer, from 1 to 65536. Ignored if infinite loop.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:340\n\n\n\n\n\n\nPainterQB.AWG5014CModule.SequencerPosition \n\u00b6\n\n\nCurrent sequencer position.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:343\n\n\n\n\n\n\nPainterQB.AWG5014CModule.SequencerType \n\u00b6\n\n\nSequencer may be hardware or software.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:145\n\n\n\n\n\n\nPainterQB.AWG5014CModule.TriggerMode \n\u00b6\n\n\nTrigger engine may be triggered, continuously firing, gated, or sequenced.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:148\n\n\n\n\n\n\nPainterQB.AWG5014CModule.TriggerTimer \n\u00b6\n\n\nInternal trigger rate.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:346\n\n\n\n\n\n\nPainterQB.AWG5014CModule.VoltageOffset \n\u00b6\n\n\nOffset voltage for a given channel.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:358\n\n\n\n\n\n\nPainterQB.AWG5014CModule.WaitingForTrigger \n\u00b6\n\n\nWhen inspected, will report if the instrument is waiting for a trigger.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:349\n\n\n\n\n\n\nPainterQB.AWG5014CModule.Waveform \n\u00b6\n\n\nName of a waveform loaded into a given channel.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:352\n\n\n\n\n\n\nPainterQB.AWG5014CModule.WaveformType \n\u00b6\n\n\nWaveform type may be integer or real.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:151\n\n\n\n\n\n\nPainterQB.AWG5014CModule.WavelistLength \n\u00b6\n\n\nThe number of waveforms stored in the AWG.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:355\n\n\nMacros [Exported]\n\n\n\n\n\n\n@allch(x::Expr) \n\u00b6\n\n\nMacro for performing an operation on every channel,\nprovided the channel is the last argument of the function to be called.\n\n\nExample: \n@allch configure(awg,Waveform,\"*Sine10\")\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:447\n\n\nFunctions [Internal]\n\n\n\n\n\n\nPainterQB.AWG5014CModule.nbytes \n\u00b6\n\n\nReturns the number of bytes per sample for a a given waveform type.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:747\n\n\n\n\n\n\nPainterQB.AWG5014CModule.pulllowlevel \n\u00b6\n\n\nTakes care of the dirty work in pulling data from the AWG.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:827\n\n\n\n\n\n\nPainterQB.AWG5014CModule.pushlowlevel \n\u00b6\n\n\nTakes care of the dirty work in pushing the data to the AWG.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:716\n\n\nMethods [Internal]\n\n\n\n\n\n\nconfigure(ins::PainterQB.AWG5014CModule.AWG5014C,  ::Type{PainterQB.AWG5014CModule.Amplitude},  ampl::Real,  ch::Integer) \n\u00b6\n\n\nConfigure Vpp for a given channel, between 0.05 V and 2 V.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:498\n\n\n\n\n\n\nconfigure(ins::PainterQB.AWG5014CModule.AWG5014C,  ::Type{PainterQB.AWG5014CModule.Waveform},  name::ASCIIString,  ch::Integer) \n\u00b6\n\n\nConfigure the waveform by name for a given channel.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:485\n\n\n\n\n\n\nconfigure(ins::PainterQB.AWG5014CModule.AWG5014C,  ::Type{PainterQB.Output},  on::Bool) \n\u00b6\n\n\nConfigure the global analog output state of the AWG.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:405\n\n\n\n\n\n\nconfigure(ins::PainterQB.AWG5014CModule.AWG5014C,  ::Type{PainterQB.Phase},  phase::Real,  ch::Integer) \n\u00b6\n\n\nSet the output phase in degrees for a given channel.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:466\n\n\n\n\n\n\nconfigure(ins::PainterQB.AWG5014CModule.AWG5014C,  ::Type{PainterQB.SampleRate},  rate::Real) \n\u00b6\n\n\nConfigure the sample rate in Hz between 10 MHz and 10 GHz.\nOutput rate = sample rate / number of points.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:514\n\n\n\n\n\n\ngenerate_configure{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty{T}}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty{T}}) \n\u00b6\n\n\nThis method generates the following method in the module where\n\ngenerate_configure\n is defined:\n\n\nconfigure(ins::InsType, ::Type{PropertySubtype}, infixes...)\n\n\n\n\nsource:\n\n\nPainterQB\\src\\Metaprogramming.jl:82\n\n\n\n\n\n\ngenerate_configure{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty{T}}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty{T}},  ::Type{PainterQB.NoArgs}) \n\u00b6\n\n\nThis method generates the following method in the module where\n\ngenerate_configure\n is defined:\n\n\nconfigure(ins::InsType, ::Type{PropertySubtype}, infixes...)\n\n\n\n\nThis particular method will be deprecated soon.\n\n\nsource:\n\n\nPainterQB\\src\\Metaprogramming.jl:122\n\n\n\n\n\n\ngenerate_configure{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty{T}}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty{T}},  returntype...) \n\u00b6\n\n\nThis method generates the following method in the module where\n\ngenerate_configure\n is defined:\n\n\nconfigure(ins::InsType, Property, values..., infixes...)\n\n\n\n\nsource:\n\n\nPainterQB\\src\\Metaprogramming.jl:151\n\n\n\n\n\n\ngenerate_handlers{T\n:PainterQB.Instrument}(insType::Type{T\n:PainterQB.Instrument},  responseDict::Dict{K, V}) \n\u00b6\n\n\nEach instrument can have a \nresponseDict\n. For each setting of the instrument,\nfor instance the \nClockSource\n, we need to know the correspondence between a\nlogical state \nExternalClock\n and how the instrument encodes that logical state\n(e.g. \"EXT\").\n\n\nThe \nresponseDict\n is actually a dictionary of dictionaries. The first level keys\nare like \nClockSource\n and the second level keys are like \"EXT\", with the value\nbeing \n:ExternalClock\n. Undoubtedly\nthis nested dictionary is \"nasty\" (in the technical parlance) but the dictionary\nis only used for code\ncreation and is not used at run-time (if the code works as intended).\n\n\nThis method makes a lot of other functions. Given some response from an instrument,\nwe require a function to map that response back on to the appropiate logical state.\n\n\nClockSource(ins::AWG5014C, res::AbstractString)\n\nreturns an \nInternalClock\n or \nExternalClock\n type as appropriate,\nbased on the logical meaning of the response.\n\n\nWe also want a function to generate logical states without having to know the way\nthey are encoded by the instrument.\n\n\ncode(ins::AWG5014C, ::Type{InternalClock})\n returns \"INT\",\nwith \"INT\" encoding how to pass this logical state to the instrument \nins\n.\n\n\nsource:\n\n\nPainterQB\\src\\Metaprogramming.jl:218\n\n\n\n\n\n\ngenerate_inspect{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty{T}}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty{T}},  ::Type{PainterQB.NoArgs}) \n\u00b6\n\n\nThis method does/returns nothing.\n\n\nsource:\n\n\nPainterQB\\src\\Metaprogramming.jl:14\n\n\n\n\n\n\ngenerate_inspect{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty{T}}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty{T}},  returntype...) \n\u00b6\n\n\nThis method will\ngenerate the following method in the module where \ngenerate_inspect\n is defined:\n\n\ninspect(ins::instype, ::Type{proptype}, infixes::Int...)\n\n\nThe \ninfixes\n variable argument allows for numbers to be inserted within the\ncommands, for instance in \nOUTP#:FILT:FREQ\n, where the \n#\n sign should be\nreplaced by an integer. The replacements are done in the order of the arguments.\nError checking is done on the number of arguments.\n\n\nFor a given property, \ninspect\n will return either an InstrumentProperty subtype,\na number, a boolean, or a string as appropriate.\n\n\nsource:\n\n\nPainterQB\\src\\Metaprogramming.jl:33\n\n\n\n\n\n\ngenerate_properties{S\n:PainterQB.InstrumentProperty{T}}(subtype::Symbol,  supertype::Type{S\n:PainterQB.InstrumentProperty{T}}) \n\u00b6\n\n\nCreates and exports immutable singleton subtypes.\n\n\nsource:\n\n\nPainterQB\\src\\Metaprogramming.jl:183\n\n\n\n\n\n\ninspect(ins::PainterQB.AWG5014CModule.AWG5014C,  ::Type{PainterQB.AWG5014CModule.Amplitude},  ch::Integer) \n\u00b6\n\n\nInspect Vpp for a given channel.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:505\n\n\n\n\n\n\ninspect(ins::PainterQB.AWG5014CModule.AWG5014C,  ::Type{PainterQB.AWG5014CModule.SequencerType}) \n\u00b6\n\n\nReturns current sequencer type.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:525\n\n\n\n\n\n\ninspect(ins::PainterQB.AWG5014CModule.AWG5014C,  ::Type{PainterQB.AWG5014CModule.WaitingForTrigger}) \n\u00b6\n\n\nInspect whether or not the instrument is waiting for a trigger.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:415\n\n\n\n\n\n\ninspect(ins::PainterQB.AWG5014CModule.AWG5014C,  ::Type{PainterQB.AWG5014CModule.Waveform},  ch::Integer) \n\u00b6\n\n\nInspect the waveform name for a given channel.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:491\n\n\n\n\n\n\ninspect(ins::PainterQB.AWG5014CModule.AWG5014C,  ::Type{PainterQB.Output}) \n\u00b6\n\n\nInspect the global analog output state of the AWG.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:410\n\n\n\n\n\n\ninspect(ins::PainterQB.AWG5014CModule.AWG5014C,  ::Type{PainterQB.Phase},  ch::Integer) \n\u00b6\n\n\nGet the output phase in degrees for a given channel.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:460\n\n\n\n\n\n\ninspect(ins::PainterQB.AWG5014CModule.AWG5014C,  ::Type{PainterQB.SampleRate}) \n\u00b6\n\n\nGet the sample rate in Hz. Output rate = sample rate / number of points.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:520\n\n\nGlobals [Internal]\n\n\n\n\n\n\nbyteLimit \n\u00b6\n\n\nMaximum number of bytes that may be sent using the SCPI command WLIS:WAV:DATA.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:67\n\n\n\n\n\n\nexceptions \n\u00b6\n\n\nException dictionary mapping signed integers to error strings.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:124\n\n\n\n\n\n\nmaximumValue \n\u00b6\n\n\nConstant used for synthesizing/interpreting waveforms of integer type.\nThis represents the maximum value (register size?).\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:92\n\n\n\n\n\n\nminimumValue \n\u00b6\n\n\nConstant used for synthesizing/interpreting waveforms of integer type.\nThis represents the minimum value.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:74\n\n\n\n\n\n\nnoError \n\u00b6\n\n\nInternal AWG code meaning no errors.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:121\n\n\n\n\n\n\noffsetPlusPPOver2 \n\u00b6\n\n\nConstant used for synthesizing/interpreting waveforms of integer type.\nThis represents zero plus Vpp/2.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:86\n\n\n\n\n\n\noffsetValue \n\u00b6\n\n\nConstant used for synthesizing/interpreting waveforms of integer type.\nThis represents zero for a waveform.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:80", 
            "title": "AWG5014C"
        }, 
        {
            "location": "/api/AWG5014C/#painterqbawg5014cmodule", 
            "text": "", 
            "title": "PainterQB.AWG5014CModule"
        }, 
        {
            "location": "/api/AWG5014C/#functions-exported", 
            "text": "PainterQB.AWG5014CModule.applicationstate  \u00b6  Is an application running?  source:  PainterQB\\src\\instruments\\AWG5014C.jl:541    PainterQB.AWG5014CModule.clearwaveforms  \u00b6  Clear waveforms from all channels.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:565    PainterQB.AWG5014CModule.deletewaveform  \u00b6  Delete a waveform by name.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:572    PainterQB.AWG5014CModule.load_awg_settings  \u00b6  Load an AWG settings file.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:548    PainterQB.AWG5014CModule.newwaveform  \u00b6  Create a new waveform by name, number of points, and waveform type.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:580    PainterQB.AWG5014CModule.normalizewaveform  \u00b6  Normalize a waveform.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:587    PainterQB.AWG5014CModule.pullfrom_awg  \u00b6  Pull data from the AWG, performing checks and generating errors as appropriate.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:761    PainterQB.AWG5014CModule.pushto_awg  \u00b6  Push waveform data to the AWG, performing checks and generating errors as appropriate.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:687    PainterQB.AWG5014CModule.resamplewaveform  \u00b6  Resample a waveform.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:594    PainterQB.AWG5014CModule.runapplication  \u00b6  Run an application, e.g. SerialXpress  source:  PainterQB\\src\\instruments\\AWG5014C.jl:534    PainterQB.AWG5014CModule.save_awg_settings  \u00b6  Save an AWG settings file.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:555    PainterQB.AWG5014CModule.validate  \u00b6  Validates data to be pushed to the AWG to check for internal consistency\nand appropriate range.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:742    PainterQB.AWG5014CModule.waveform  \u00b6  Uses Julia style indexing (begins at 1) to retrieve the name of a waveform\nfrom the waveform list.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:631    PainterQB.AWG5014CModule.waveformexists  \u00b6  Does a waveform identified by  name  exist?  source:  PainterQB\\src\\instruments\\AWG5014C.jl:607    PainterQB.AWG5014CModule.waveformispredefined  \u00b6  Returns whether or not a waveform is predefined (comes with instrument).  source:  PainterQB\\src\\instruments\\AWG5014C.jl:614    PainterQB.AWG5014CModule.waveformlength  \u00b6  Returns the length of a waveform.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:621    PainterQB.AWG5014CModule.waveformtimestamp  \u00b6  Return the timestamp for when a waveform was last updated.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:638    PainterQB.AWG5014CModule.waveformtype  \u00b6  Returns the type of the waveform. The AWG hardware\nultimately uses an  IntWaveform  but  RealWaveform  is more convenient.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:648", 
            "title": "Functions [Exported]"
        }, 
        {
            "location": "/api/AWG5014C/#types-exported", 
            "text": "PainterQB.AWG5014CModule.AWG5014C  \u00b6  Concrete type representing an AWG5014C.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:95    PainterQB.AWG5014CModule.AWG5014CData  \u00b6  Type for storing waveform data (including markers) in Float32 format.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:114    PainterQB.AWG5014CModule.Amplitude  \u00b6  Amplitude for a given channel.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:238    PainterQB.AWG5014CModule.AnalogOutputDelay  \u00b6  Analog output delay for a given channel.\nThe effect of this command can be seen only in non-sequence mode.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:245    PainterQB.AWG5014CModule.ChannelOutput  \u00b6  Boolean state of the output for a given channel.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:249    PainterQB.AWG5014CModule.DCOutput  \u00b6  Boolean state of the DC output for a given channel (bottom-right of AWG).  source:  PainterQB\\src\\instruments\\AWG5014C.jl:254    PainterQB.AWG5014CModule.DCOutputLevel  \u00b6  DC output level for a given channel.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:259    PainterQB.AWG5014CModule.EventImpedance  \u00b6  Event input impedance may be 50 Ohm or 1 kOhm.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:134    PainterQB.AWG5014CModule.EventSlope  \u00b6  Event may fire on a rising or falling slope.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:137    PainterQB.AWG5014CModule.EventTiming  \u00b6  Events may occur synchronously or asynchronously.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:140    PainterQB.AWG5014CModule.ExtInputAddsToOutput  \u00b6  Add the signal from an external input to the given channel output.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:264    PainterQB.AWG5014CModule.ExtOscDividerRate  \u00b6  Divider rate of the external oscillator; must be a power of 2 (1 ok).  source:  PainterQB\\src\\instruments\\AWG5014C.jl:269    PainterQB.AWG5014CModule.MarkerDelay  \u00b6  Marker delay for a given channel and marker. Marker can be 1 or 2.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:274    PainterQB.AWG5014CModule.OutputFilterFrequency  \u00b6  Low-pass filter frequency for the output. INF = 9.9e37  source:  PainterQB\\src\\instruments\\AWG5014C.jl:279    PainterQB.AWG5014CModule.RefOscFrequency  \u00b6  Reference oscillator frequency.  Valid values are 10 MHz, 20 MHz and 100 MHz. Used when:   Clock Source is Internal  Reference Input is External  External Reference Type is Fixed.   source:  PainterQB\\src\\instruments\\AWG5014C.jl:294    PainterQB.AWG5014CModule.RefOscMultiplier  \u00b6  Reference oscillator multiplier.  Used when:\n- Clock Source is Internal\n- Reference Source is External\n- External Reference Type is Variable.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:304    PainterQB.AWG5014CModule.RepRate  \u00b6  Repetition rate (frequency of waveform). Changing this will change the\nsampling rate.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:307    PainterQB.AWG5014CModule.RepRateHeld  \u00b6  Boolean hold state of the repetition rate. If held, the repetition rate will\nnot change when the size of the waveform changes.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:313    PainterQB.AWG5014CModule.SCPIVersion  \u00b6  The SCPI version of the AWG.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:316    PainterQB.AWG5014CModule.SequencerEventJumpTarget  \u00b6  Target index for the sequencer event jump operation.\nNote that this will take effect only when\nSEQuence:ELEMent[n]:JTARget:TYPE is set to INDex.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:324    PainterQB.AWG5014CModule.SequencerGOTOState  \u00b6  Boolean GOTO state of the sequencer.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:331    PainterQB.AWG5014CModule.SequencerGOTOTarget  \u00b6  Target index for the GOTO command of the sequencer.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:327    PainterQB.AWG5014CModule.SequencerInfiniteLoop  \u00b6  Boolean state of infinite loop on a sequencer element.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:334    PainterQB.AWG5014CModule.SequencerLength  \u00b6  Length of the sequence. Can be destructive to existing sequences.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:337    PainterQB.AWG5014CModule.SequencerLoopCount  \u00b6  Loop count of the sequencer, from 1 to 65536. Ignored if infinite loop.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:340    PainterQB.AWG5014CModule.SequencerPosition  \u00b6  Current sequencer position.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:343    PainterQB.AWG5014CModule.SequencerType  \u00b6  Sequencer may be hardware or software.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:145    PainterQB.AWG5014CModule.TriggerMode  \u00b6  Trigger engine may be triggered, continuously firing, gated, or sequenced.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:148    PainterQB.AWG5014CModule.TriggerTimer  \u00b6  Internal trigger rate.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:346    PainterQB.AWG5014CModule.VoltageOffset  \u00b6  Offset voltage for a given channel.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:358    PainterQB.AWG5014CModule.WaitingForTrigger  \u00b6  When inspected, will report if the instrument is waiting for a trigger.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:349    PainterQB.AWG5014CModule.Waveform  \u00b6  Name of a waveform loaded into a given channel.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:352    PainterQB.AWG5014CModule.WaveformType  \u00b6  Waveform type may be integer or real.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:151    PainterQB.AWG5014CModule.WavelistLength  \u00b6  The number of waveforms stored in the AWG.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:355", 
            "title": "Types [Exported]"
        }, 
        {
            "location": "/api/AWG5014C/#macros-exported", 
            "text": "@allch(x::Expr)  \u00b6  Macro for performing an operation on every channel,\nprovided the channel is the last argument of the function to be called.  Example:  @allch configure(awg,Waveform,\"*Sine10\")  source:  PainterQB\\src\\instruments\\AWG5014C.jl:447", 
            "title": "Macros [Exported]"
        }, 
        {
            "location": "/api/AWG5014C/#functions-internal", 
            "text": "PainterQB.AWG5014CModule.nbytes  \u00b6  Returns the number of bytes per sample for a a given waveform type.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:747    PainterQB.AWG5014CModule.pulllowlevel  \u00b6  Takes care of the dirty work in pulling data from the AWG.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:827    PainterQB.AWG5014CModule.pushlowlevel  \u00b6  Takes care of the dirty work in pushing the data to the AWG.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:716", 
            "title": "Functions [Internal]"
        }, 
        {
            "location": "/api/AWG5014C/#methods-internal", 
            "text": "configure(ins::PainterQB.AWG5014CModule.AWG5014C,  ::Type{PainterQB.AWG5014CModule.Amplitude},  ampl::Real,  ch::Integer)  \u00b6  Configure Vpp for a given channel, between 0.05 V and 2 V.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:498    configure(ins::PainterQB.AWG5014CModule.AWG5014C,  ::Type{PainterQB.AWG5014CModule.Waveform},  name::ASCIIString,  ch::Integer)  \u00b6  Configure the waveform by name for a given channel.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:485    configure(ins::PainterQB.AWG5014CModule.AWG5014C,  ::Type{PainterQB.Output},  on::Bool)  \u00b6  Configure the global analog output state of the AWG.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:405    configure(ins::PainterQB.AWG5014CModule.AWG5014C,  ::Type{PainterQB.Phase},  phase::Real,  ch::Integer)  \u00b6  Set the output phase in degrees for a given channel.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:466    configure(ins::PainterQB.AWG5014CModule.AWG5014C,  ::Type{PainterQB.SampleRate},  rate::Real)  \u00b6  Configure the sample rate in Hz between 10 MHz and 10 GHz.\nOutput rate = sample rate / number of points.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:514    generate_configure{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty{T}}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty{T}})  \u00b6  This method generates the following method in the module where generate_configure  is defined:  configure(ins::InsType, ::Type{PropertySubtype}, infixes...)  source:  PainterQB\\src\\Metaprogramming.jl:82    generate_configure{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty{T}}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty{T}},  ::Type{PainterQB.NoArgs})  \u00b6  This method generates the following method in the module where generate_configure  is defined:  configure(ins::InsType, ::Type{PropertySubtype}, infixes...)  This particular method will be deprecated soon.  source:  PainterQB\\src\\Metaprogramming.jl:122    generate_configure{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty{T}}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty{T}},  returntype...)  \u00b6  This method generates the following method in the module where generate_configure  is defined:  configure(ins::InsType, Property, values..., infixes...)  source:  PainterQB\\src\\Metaprogramming.jl:151    generate_handlers{T :PainterQB.Instrument}(insType::Type{T :PainterQB.Instrument},  responseDict::Dict{K, V})  \u00b6  Each instrument can have a  responseDict . For each setting of the instrument,\nfor instance the  ClockSource , we need to know the correspondence between a\nlogical state  ExternalClock  and how the instrument encodes that logical state\n(e.g. \"EXT\").  The  responseDict  is actually a dictionary of dictionaries. The first level keys\nare like  ClockSource  and the second level keys are like \"EXT\", with the value\nbeing  :ExternalClock . Undoubtedly\nthis nested dictionary is \"nasty\" (in the technical parlance) but the dictionary\nis only used for code\ncreation and is not used at run-time (if the code works as intended).  This method makes a lot of other functions. Given some response from an instrument,\nwe require a function to map that response back on to the appropiate logical state.  ClockSource(ins::AWG5014C, res::AbstractString) \nreturns an  InternalClock  or  ExternalClock  type as appropriate,\nbased on the logical meaning of the response.  We also want a function to generate logical states without having to know the way\nthey are encoded by the instrument.  code(ins::AWG5014C, ::Type{InternalClock})  returns \"INT\",\nwith \"INT\" encoding how to pass this logical state to the instrument  ins .  source:  PainterQB\\src\\Metaprogramming.jl:218    generate_inspect{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty{T}}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty{T}},  ::Type{PainterQB.NoArgs})  \u00b6  This method does/returns nothing.  source:  PainterQB\\src\\Metaprogramming.jl:14    generate_inspect{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty{T}}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty{T}},  returntype...)  \u00b6  This method will\ngenerate the following method in the module where  generate_inspect  is defined:  inspect(ins::instype, ::Type{proptype}, infixes::Int...)  The  infixes  variable argument allows for numbers to be inserted within the\ncommands, for instance in  OUTP#:FILT:FREQ , where the  #  sign should be\nreplaced by an integer. The replacements are done in the order of the arguments.\nError checking is done on the number of arguments.  For a given property,  inspect  will return either an InstrumentProperty subtype,\na number, a boolean, or a string as appropriate.  source:  PainterQB\\src\\Metaprogramming.jl:33    generate_properties{S :PainterQB.InstrumentProperty{T}}(subtype::Symbol,  supertype::Type{S :PainterQB.InstrumentProperty{T}})  \u00b6  Creates and exports immutable singleton subtypes.  source:  PainterQB\\src\\Metaprogramming.jl:183    inspect(ins::PainterQB.AWG5014CModule.AWG5014C,  ::Type{PainterQB.AWG5014CModule.Amplitude},  ch::Integer)  \u00b6  Inspect Vpp for a given channel.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:505    inspect(ins::PainterQB.AWG5014CModule.AWG5014C,  ::Type{PainterQB.AWG5014CModule.SequencerType})  \u00b6  Returns current sequencer type.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:525    inspect(ins::PainterQB.AWG5014CModule.AWG5014C,  ::Type{PainterQB.AWG5014CModule.WaitingForTrigger})  \u00b6  Inspect whether or not the instrument is waiting for a trigger.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:415    inspect(ins::PainterQB.AWG5014CModule.AWG5014C,  ::Type{PainterQB.AWG5014CModule.Waveform},  ch::Integer)  \u00b6  Inspect the waveform name for a given channel.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:491    inspect(ins::PainterQB.AWG5014CModule.AWG5014C,  ::Type{PainterQB.Output})  \u00b6  Inspect the global analog output state of the AWG.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:410    inspect(ins::PainterQB.AWG5014CModule.AWG5014C,  ::Type{PainterQB.Phase},  ch::Integer)  \u00b6  Get the output phase in degrees for a given channel.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:460    inspect(ins::PainterQB.AWG5014CModule.AWG5014C,  ::Type{PainterQB.SampleRate})  \u00b6  Get the sample rate in Hz. Output rate = sample rate / number of points.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:520", 
            "title": "Methods [Internal]"
        }, 
        {
            "location": "/api/AWG5014C/#globals-internal", 
            "text": "byteLimit  \u00b6  Maximum number of bytes that may be sent using the SCPI command WLIS:WAV:DATA.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:67    exceptions  \u00b6  Exception dictionary mapping signed integers to error strings.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:124    maximumValue  \u00b6  Constant used for synthesizing/interpreting waveforms of integer type.\nThis represents the maximum value (register size?).  source:  PainterQB\\src\\instruments\\AWG5014C.jl:92    minimumValue  \u00b6  Constant used for synthesizing/interpreting waveforms of integer type.\nThis represents the minimum value.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:74    noError  \u00b6  Internal AWG code meaning no errors.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:121    offsetPlusPPOver2  \u00b6  Constant used for synthesizing/interpreting waveforms of integer type.\nThis represents zero plus Vpp/2.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:86    offsetValue  \u00b6  Constant used for synthesizing/interpreting waveforms of integer type.\nThis represents zero for a waveform.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:80", 
            "title": "Globals [Internal]"
        }, 
        {
            "location": "/api/AlazarTech/", 
            "text": "PainterQB.AlazarModule\n\n\nFunctions [Exported]\n\n\n\n\n\n\nPainterQB.AlazarModule.abort \n\u00b6\n\n\nAborts an acquisition. Must be called in the case of a DSP acquisition; somehow\nless fatal otherwise. Should be automatically taken care of in a well-written\n\nmeasure\n method, but can be called manually by the paranoid.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\CoreFunctions.jl:42\n\n\n\n\n\n\nPainterQB.AlazarModule.before_async_read \n\u00b6\n\n\nPerforms setup for asynchronous acquisitions. Should be called after\n\nbuffersizing\n has been called.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\CoreFunctions.jl:111\n\n\n\n\n\n\nPainterQB.AlazarModule.bufferarray \n\u00b6\n\n\nGiven and \nInstrumentAlazar\n and \nAlazarMode\n, returns a \nDMABufferArray\n\nwith the correct number of buffers and buffer sizes. \nbuffersizing\n should have\nbeen called before this function.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\CoreFunctions.jl:161\n\n\n\n\n\n\nPainterQB.AlazarModule.buffersizing \n\u00b6\n\n\nGiven an \nInstrumentAlazar\n and an \nAlazarMode\n, this will tweak parameters\nin the \nAlazarMode\n object to comply with record alignment and buffer granularity\nrequirements imposed by either the AlazarTech digitizer itself, or the implementation\nof measurement code. Should be called toward the very beginning of a \nmeasure\n\nmethod.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\CoreFunctions.jl:384\n\n\n\n\n\n\nPainterQB.AlazarModule.fft_fpga_setup \n\u00b6\n\n\nIf necessary, performs \nAlazarFFTSetup\n, which should be called before\n\nAlazarBeforeAsyncRead\n.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\CoreFunctions.jl:547\n\n\n\n\n\n\nPainterQB.AlazarModule.recordsizing \n\u00b6\n\n\nCalls C function \nAlazarSetRecordSize\n if necessary, given an \nInstrumentAlazar\n\nand \nAlazarMode\n.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\CoreFunctions.jl:630\n\n\n\n\n\n\nPainterQB.AlazarModule.wait_buffer \n\u00b6\n\n\nWaits for a buffer to be processed (or a timeout to elapse).\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\CoreFunctions.jl:782\n\n\nMethods [Exported]\n\n\n\n\n\n\nbusy(a::PainterQB.AlazarModule.InstrumentAlazar) \n\u00b6\n\n\nReturns whether or not the \nInstrumentAlazar\n is busy (Bool).\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\CoreFunctions.jl:393\n\n\n\n\n\n\nconfigure(a::PainterQB.AlazarModule.AlazarATS9360,  ::Type{PainterQB.SampleRate},  rate::Real) \n\u00b6\n\n\nConfigure the sample rate to any multiple of 1 MHz (within 300 MHz and 1.8 GHz)\nusing the external clock.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\models\\ATS9360.jl:145\n\n\n\n\n\n\nconfigure(a::PainterQB.AlazarModule.InstrumentAlazar,  ::Type{PainterQB.AlazarModule.AuxSoftwareTriggerEnable},  b::Bool) \n\u00b6\n\n\nIf an AUX IO output mode has been configured, then this will configure\nsoftware trigger enable. From the Alazar API:\n\n\nWhen this flag is set, the board will wait for software to call\n\nAlazarForceTriggerEnable\n to generate a trigger enable event; then wait for\nsufficient trigger events to capture the records in an AutoDMA buffer; then wait\nfor the next trigger enable event and repeat.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\Configure.jl:81\n\n\n\n\n\n\nconfigure(a::PainterQB.AlazarModule.InstrumentAlazar,  ::Type{PainterQB.AlazarModule.LED},  ledState::Bool) \n\u00b6\n\n\nConfigures the LED on the digitizer card chassis.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\Configure.jl:202\n\n\n\n\n\n\nconfigure(a::PainterQB.AlazarModule.InstrumentAlazar,  ::Type{PainterQB.AlazarModule.RecordCount},  count) \n\u00b6\n\n\nWrapper for C function \nAlazarSetRecordCount\n. See the Alazar API.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\Configure.jl:104\n\n\n\n\n\n\nconfigure(a::PainterQB.AlazarModule.InstrumentAlazar,  ::Type{PainterQB.AlazarModule.Sleep},  sleepState) \n\u00b6\n\n\nConfigures the sleep state of the digitizer card.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\Configure.jl:208\n\n\n\n\n\n\nconfigure(a::PainterQB.AlazarModule.InstrumentAlazar,  ::Type{PainterQB.AlazarModule.TriggerDelaySamples},  delay_samples) \n\u00b6\n\n\nConfigure how many samples to wait after receiving a trigger event before capturing\na record.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\Configure.jl:294\n\n\n\n\n\n\nconfigure(a::PainterQB.AlazarModule.InstrumentAlazar,  ::Type{PainterQB.AlazarModule.TriggerTimeoutS},  timeout_s) \n\u00b6\n\n\nWrapper for C function \nAlazarSetTriggerTimeOut\n, except we take seconds here\ninstead of ticks (units of 10 us).\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\Configure.jl:313\n\n\n\n\n\n\nconfigure(a::PainterQB.AlazarModule.InstrumentAlazar,  ::Type{PainterQB.AlazarModule.TriggerTimeoutTicks},  ticks) \n\u00b6\n\n\nWrapper for C function \nAlazarSetTriggerTimeOut\n.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\Configure.jl:303\n\n\n\n\n\n\nconfigure(a::PainterQB.AlazarModule.InstrumentAlazar,  ::Type{PainterQB.TriggerLevel},  levelJ,  levelK) \n\u00b6\n\n\nConfigure the trigger level for trigger engine J and K. This should be an\nunsigned 8 bit integer (0--255) corresponding to the full range of the digitizer.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\Configure.jl:269\n\n\n\n\n\n\nconfigure(a::PainterQB.AlazarModule.InstrumentAlazar,  aux::Type{PainterQB.AlazarModule.AuxDigitalInput}) \n\u00b6\n\n\nConfigure a digitizer's AUX IO to act as a digital input.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\Configure.jl:25\n\n\n\n\n\n\nconfigure(a::PainterQB.AlazarModule.InstrumentAlazar,  aux::Type{PainterQB.AlazarModule.AuxDigitalOutput},  level::Integer) \n\u00b6\n\n\nConfigure a digitizer's AUX IO port to act as a general purpose digital output.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\Configure.jl:62\n\n\n\n\n\n\nconfigure(a::PainterQB.AlazarModule.InstrumentAlazar,  aux::Type{PainterQB.AlazarModule.AuxOutputPacer},  divider::Integer) \n\u00b6\n\n\nConfigure a digitizer's AUX IO port to output the sample clock, divided by an integer.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\Configure.jl:49\n\n\n\n\n\n\nconfigure(a::PainterQB.AlazarModule.InstrumentAlazar,  aux::Type{PainterQB.AlazarModule.AuxOutputTrigger}) \n\u00b6\n\n\nConfigure a digitizer's AUX IO to output a trigger signal synced to the sample clock.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\Configure.jl:15\n\n\n\n\n\n\nconfigure(a::PainterQB.AlazarModule.InstrumentAlazar,  ch::Type{PainterQB.AlazarModule.BothChannels}) \n\u00b6\n\n\nConfigures acquisition from both channels, simultaneously.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\Configure.jl:122\n\n\n\n\n\n\nconfigure{S\n:PainterQB.AlazarModule.AlazarDataPacking}(a::PainterQB.AlazarModule.InstrumentAlazar,  ::Type{PainterQB.AlazarModule.AlazarDataPacking},  pack::Type{S\n:PainterQB.AlazarModule.AlazarDataPacking},  ch::Type{PainterQB.AlazarModule.BothChannels}) \n\u00b6\n\n\nConfigures the data packing mode for both channels.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\Configure.jl:191\n\n\n\n\n\n\nconfigure{S\n:PainterQB.AlazarModule.AlazarDataPacking}(a::PainterQB.AlazarModule.InstrumentAlazar,  ::Type{PainterQB.AlazarModule.AlazarDataPacking},  pack::Type{S\n:PainterQB.AlazarModule.AlazarDataPacking},  ch::Type{PainterQB.AlazarModule.ChannelA}) \n\u00b6\n\n\nConfigures the data packing mode for channel A.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\Configure.jl:163\n\n\n\n\n\n\nconfigure{S\n:PainterQB.AlazarModule.AlazarDataPacking}(a::PainterQB.AlazarModule.InstrumentAlazar,  ::Type{PainterQB.AlazarModule.AlazarDataPacking},  pack::Type{S\n:PainterQB.AlazarModule.AlazarDataPacking},  ch::Type{PainterQB.AlazarModule.ChannelB}) \n\u00b6\n\n\nConfigures the data packing mode for channel B.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\Configure.jl:177\n\n\n\n\n\n\nconfigure{S\n:PainterQB.AlazarModule.DSPWindow{T}, T\n:PainterQB.AlazarModule.DSPWindow{T}}(a::PainterQB.AlazarModule.AlazarATS9360,  re::Type{S\n:PainterQB.AlazarModule.DSPWindow{T}},  im::Type{T\n:PainterQB.AlazarModule.DSPWindow{T}}) \n\u00b6\n\n\nConfigures the DSP windows. \nAlazarFFTSetWindowFunction\n is called towards\nthe start of \nmeasure\n rather than here.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\models\\ATS9360.jl:180\n\n\n\n\n\n\nconfigure{S\n:PainterQB.TriggerSlope, T\n:PainterQB.TriggerSlope}(a::PainterQB.AlazarModule.InstrumentAlazar,  slopeJ::Type{S\n:PainterQB.TriggerSlope},  slopeK::Type{T\n:PainterQB.TriggerSlope}) \n\u00b6\n\n\nConfigures whether to trigger on a rising or falling slope, for engine J and K.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\Configure.jl:240\n\n\n\n\n\n\nconfigure{S\n:PainterQB.TriggerSource, T\n:PainterQB.TriggerSource}(a::PainterQB.AlazarModule.InstrumentAlazar,  sourceJ::Type{S\n:PainterQB.TriggerSource},  sourceK::Type{T\n:PainterQB.TriggerSource}) \n\u00b6\n\n\nConfigure the trigger source for trigger engine J and K.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\Configure.jl:254\n\n\n\n\n\n\nconfigure{T\n:PainterQB.AlazarModule.AlazarChannel}(a::PainterQB.AlazarModule.InstrumentAlazar,  ch::Type{T\n:PainterQB.AlazarModule.AlazarChannel}) \n\u00b6\n\n\nConfigures the acquisition channel.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\Configure.jl:114\n\n\n\n\n\n\nconfigure{T\n:PainterQB.AlazarModule.AlazarTimestampReset}(a::PainterQB.AlazarModule.InstrumentAlazar,  t::Type{T\n:PainterQB.AlazarModule.AlazarTimestampReset}) \n\u00b6\n\n\nConfigures timestamp reset. From the Alazar API, the choices are\n\nTimestampResetOnce\n\n(Reset the timestamp counter to zero on the next call to \nAlazarStartCapture\n,\nbut not thereafter.) or \nTimestampResetAlways\n (Reset the timestamp counter to\nzero on each call to AlazarStartCapture. This is the default operation.)\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\Configure.jl:221\n\n\n\n\n\n\nconfigure{T\n:PainterQB.AlazarModule.AlazarTriggerEngine}(a::PainterQB.AlazarModule.InstrumentAlazar,  engine::Type{T\n:PainterQB.AlazarModule.AlazarTriggerEngine}) \n\u00b6\n\n\nConfigures the trigger engines, e.g. TriggerOnJ, TriggerOnJAndNotK, etc.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\Configure.jl:231\n\n\n\n\n\n\nconfigure{T\n:PainterQB.AlazarModule.AlazarTriggerRange}(a::PainterQB.AlazarModule.AlazarATS9360,  range::Type{T\n:PainterQB.AlazarModule.AlazarTriggerRange}) \n\u00b6\n\n\nDoes nothing but display info telling you that this parameter cannot be changed\nfrom 5V range on the ATS9360.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\models\\ATS9360.jl:172\n\n\n\n\n\n\nconfigure{T\n:PainterQB.AlazarModule.AlazarTriggerRange}(a::PainterQB.AlazarModule.InstrumentAlazar,  range::Type{T\n:PainterQB.AlazarModule.AlazarTriggerRange}) \n\u00b6\n\n\nConfigure the external trigger range.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\Configure.jl:284\n\n\n\n\n\n\nconfigure{T\n:PainterQB.ClockSlope}(a::PainterQB.AlazarModule.InstrumentAlazar,  slope::Type{T\n:PainterQB.ClockSlope}) \n\u00b6\n\n\nConfigures whether the clock ticks on a rising or falling slope.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\Configure.jl:146\n\n\n\n\n\n\nconfigure{T\n:PainterQB.Coupling}(a::PainterQB.AlazarModule.AlazarATS9360,  coupling::Type{T\n:PainterQB.Coupling}) \n\u00b6\n\n\nDoes nothing but display info telling you that this parameter cannot be changed\nfrom DC coupling on the ATS9360.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\models\\ATS9360.jl:164\n\n\n\n\n\n\nconfigure{T\n:PainterQB.Coupling}(a::PainterQB.AlazarModule.InstrumentAlazar,  coupling::Type{T\n:PainterQB.Coupling}) \n\u00b6\n\n\nConfigure the external trigger coupling.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\Configure.jl:277\n\n\n\n\n\n\nconfigure{T\n:PainterQB.SampleRate}(a::PainterQB.AlazarModule.InstrumentAlazar,  rate::Type{T\n:PainterQB.SampleRate}) \n\u00b6\n\n\nConfigures one of the preset sample rates derived from the internal clock.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\Configure.jl:131\n\n\n\n\n\n\nconfigure{T\n:PainterQB.TriggerSlope}(a::PainterQB.AlazarModule.InstrumentAlazar,  aux::Type{PainterQB.AlazarModule.AuxInputTriggerEnable},  trigSlope::Type{T\n:PainterQB.TriggerSlope}) \n\u00b6\n\n\nConfigure a digitizer's AUX IO port to use the edge of a pulse as an AutoDMA\ntrigger signal.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\Configure.jl:37\n\n\n\n\n\n\ndsp_getinfo(dspModule::PainterQB.AlazarModule.DSPModule) \n\u00b6\n\n\nReturns a DSPModuleInfo object that describes a DSPModule.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\CoreFunctions.jl:442\n\n\n\n\n\n\ndsp_getmodulehandles(a::PainterQB.AlazarModule.InstrumentAlazar) \n\u00b6\n\n\nReturns an Array of \ndsp_module_handle\n.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\CoreFunctions.jl:466\n\n\n\n\n\n\ndsp_modules(a::PainterQB.AlazarModule.InstrumentAlazar) \n\u00b6\n\n\nReturns an array of \nDSPModule\n.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\CoreFunctions.jl:483\n\n\n\n\n\n\ndsp_num_modules(a::PainterQB.AlazarModule.InstrumentAlazar) \n\u00b6\n\n\nReturns the number of \nDSPModule\n.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\CoreFunctions.jl:488\n\n\n\n\n\n\nforcetrigger(a::PainterQB.AlazarModule.InstrumentAlazar) \n\u00b6\n\n\nForce a software trigger.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\CoreFunctions.jl:562\n\n\n\n\n\n\nforcetriggerenable(a::PainterQB.AlazarModule.InstrumentAlazar) \n\u00b6\n\n\nForce a software \"trigger enable.\" This involves the AUX I/O connector (see\nAlazar API).\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\CoreFunctions.jl:571\n\n\n\n\n\n\ninputcontrol(a::PainterQB.AlazarModule.InstrumentAlazar,  channel,  coupling,  inputRange,  impedance) \n\u00b6\n\n\nControls coupling, input range, and impedance for applicable digitizer cards.\nDoes nothing for ATS9360 cards since there is only one choice of arguments.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\CoreFunctions.jl:580\n\n\n\n\n\n\ninspect(a::PainterQB.AlazarModule.AlazarATS9360,  ::Type{PainterQB.AlazarModule.BufferAlignment}) \n\u00b6\n\n\nReturns the buffer alignment requirement (samples / record / channel).\nNote that buffers must also be page-aligned.\nFrom Table 8 of the Alazar API.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\models\\ATS9360.jl:220\n\n\n\n\n\n\ninspect(a::PainterQB.AlazarModule.AlazarATS9360,  ::Type{PainterQB.AlazarModule.MaxBufferBytes}) \n\u00b6\n\n\nMaximum number of bytes for a given DMA buffer.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\models\\ATS9360.jl:202\n\n\n\n\n\n\ninspect(a::PainterQB.AlazarModule.AlazarATS9360,  ::Type{PainterQB.AlazarModule.MaxFFTSamples}) \n\u00b6\n\n\nMaximum number of samples in an FPGA-based FFT. Can be obtained from \ndsp_getinfo\n\nbut we have hardcoded since it should not change for this model of digitizer.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\models\\ATS9360.jl:213\n\n\n\n\n\n\ninspect(a::PainterQB.AlazarModule.AlazarATS9360,  ::Type{PainterQB.AlazarModule.MinFFTSamples}) \n\u00b6\n\n\nMinimum number of samples in an FPGA-based FFT. Set by the minimum record size.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\models\\ATS9360.jl:207\n\n\n\n\n\n\ninspect(a::PainterQB.AlazarModule.AlazarATS9360,  ::Type{PainterQB.AlazarModule.MinSamplesPerRecord}) \n\u00b6\n\n\nMinimum samples per record. Observed behavior deviates from Table 8 of the\nAlazar API.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\models\\ATS9360.jl:196\n\n\n\n\n\n\ninspect(a::PainterQB.AlazarModule.AlazarATS9360,  ::Type{PainterQB.AlazarModule.PretriggerAlignment}) \n\u00b6\n\n\nReturns the pretrigger alignment requirement (samples / record / channel).\nFrom Table 8 of the Alazar API.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\models\\ATS9360.jl:227\n\n\n\n\n\n\ninspect(a::PainterQB.AlazarModule.InstrumentAlazar,  ::Type{PainterQB.AlazarModule.AlazarAux}) \n\u00b6\n\n\nInspect the AUX IO mode.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\Inspect.jl:6\n\n\n\n\n\n\ninspect(a::PainterQB.AlazarModule.InstrumentAlazar,  ::Type{PainterQB.AlazarModule.AlazarChannel}) \n\u00b6\n\n\nReturns which channel(s) will be acquired.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\Inspect.jl:13\n\n\n\n\n\n\ninspect(a::PainterQB.AlazarModule.InstrumentAlazar,  ::Type{PainterQB.AlazarModule.ChannelCount}) \n\u00b6\n\n\nReturns the number of channels to acquire.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\Inspect.jl:17\n\n\n\n\n\n\ninspect(a::PainterQB.AlazarModule.InstrumentAlazar,  ::Type{PainterQB.AlazarModule.SampleMemoryPerChannel}) \n\u00b6\n\n\nReturns the memory per channel in units of samples.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\Inspect.jl:41\n\n\n\n\n\n\ninspect(a::PainterQB.AlazarModule.InstrumentAlazar,  ::Type{PainterQB.SampleRate}) \n\u00b6\n\n\nInspect the sample rate. As currently programmed, does not distinguish\nbetween the internal preset clock rates and otherwise.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\Inspect.jl:35\n\n\n\n\n\n\ninspect{T\n:PainterQB.AlazarModule.AlazarChannel}(a::PainterQB.AlazarModule.InstrumentAlazar,  ::Type{PainterQB.AlazarModule.AlazarDataPacking},  ch::Type{T\n:PainterQB.AlazarModule.AlazarChannel}) \n\u00b6\n\n\nInspect the data packing mode for a given channel.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\Inspect.jl:22\n\n\n\n\n\n\nmeasure(ch::PainterQB.AlazarModule.AlazarResponse{T}) \n\u00b6\n\n\nLargely generic method for measuring \nAlazarResponse\n. Can be considered a\nprototype for more complicated user-defined methods.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\ResponseFunctions.jl:97\n\n\n\n\n\n\nmeasure(ch::PainterQB.AlazarModule.IQSoftwareResponse{T}) \n\u00b6\n\n\nAssume two-channel IQ FFT acquisition.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\ResponseFunctions.jl:189\n\n\n\n\n\n\npost_async_buffer(a::PainterQB.AlazarModule.InstrumentAlazar,  buffer,  bufferLength) \n\u00b6\n\n\nPost an asynchronous buffer to the digitizer for use in an acquisition.\nBuffer address must meet alignment requirements.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\CoreFunctions.jl:599\n\n\n\n\n\n\nset_parameter(a::PainterQB.AlazarModule.InstrumentAlazar,  channelId,  parameterId,  value) \n\u00b6\n\n\nJulia wrapper for C function AlazarSetParameter, with error checking.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\CoreFunctions.jl:717\n\n\n\n\n\n\nset_parameter_ul(a::PainterQB.AlazarModule.InstrumentAlazar,  channelId,  parameterId,  value) \n\u00b6\n\n\nJulia wrapper for C function AlazarSetParameterUL, with error checking.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\CoreFunctions.jl:723\n\n\n\n\n\n\nset_triggeroperation(a::PainterQB.AlazarModule.InstrumentAlazar,  args...) \n\u00b6\n\n\nConfigure the trigger operation. Usually not called directly.\nArgs should be, in the following order:\n\n\na::InstrumentAlazar\n\n\nengine:  one of the trigger engine operation IDs in the Alazar API.\n\n\nsource1: one of \nTRIG_CHAN_A\n, \nTRIG_CHAN_B\n, or \nTRIG_DISABLE\n\n\nslope1:  \nTRIGGER_SLOPE_POSITIVE\n or \nTRIGGER_SLOPE_NEGATIVE\n\n\nlevel1:  a voltage (V).\n\n\nsource2: one of \nTRIG_CHAN_A\n, \nTRIG_CHAN_B\n, or \nTRIG_DISABLE\n\n\nslope2:  \nTRIGGER_SLOPE_POSITIVE\n or \nTRIGGER_SLOPE_NEGATIVE\n\n\nlevel2:  a voltage (V).\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\CoreFunctions.jl:748\n\n\n\n\n\n\nstartcapture(a::PainterQB.AlazarModule.InstrumentAlazar) \n\u00b6\n\n\nShould be called after \nbefore_async_read\n has been called and buffers are posted.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\CoreFunctions.jl:763\n\n\n\n\n\n\ntriggered(a::PainterQB.AlazarModule.InstrumentAlazar) \n\u00b6\n\n\nReports whether or not the digitizer has been triggered.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\CoreFunctions.jl:769\n\n\nTypes [Exported]\n\n\n\n\n\n\nPainterQB.AlazarModule.AlazarATS9360 \n\u00b6\n\n\nConcrete InstrumentAlazar subtype representing an ATS9360 digitizer.\n\n\nDefaults are selected as:\n\n\n\n\nDC coupling (all). Cannot be changed for the ATS9360.\n\n\nInput range +/- 0.4V for channel A, B. Cannot be changed for the ATS9360.\n\n\nExternal trigger range: 5 V. Cannot be changed for the ATS9360 (?)\n\n\nAll impedances 50 Ohm. Cannot be changed for the ATS9360.\n\n\nInternal clock, 1 GSps, rising edge.\n\n\nTrigger on J; engine J fires when channel A crosses zero from below.\n\n\nTrigger delay 0 samples; no trigger timeout\n\n\nAcquire with both channels\n\n\nAUX IO outputs a trigger signal synced to the sample clock.\n\n\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\models\\ATS9360.jl:18\n\n\n\n\n\n\nPainterQB.AlazarModule.DSPModule \n\u00b6\n\n\nRepresents a DSP module of an AlazarTech digitizer.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\DSPTypes.jl:50\n\n\n\n\n\n\nPainterQB.AlazarModule.DSPModuleInfo \n\u00b6\n\n\nEncapsulates DSP module information: type, version, and max record length.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\DSPTypes.jl:56\n\n\n\n\n\n\nPainterQB.AlazarModule.DSPWindow{T} \n\u00b6\n\n\nAbstract parametric type representing a windowing function for DSP.\nThe parameter determines the method of window generation:\n\n\n\n\n:alazar\n: Use the AlazarDSP to synthesize the window\n\n\nNo parameter: Use default software method\n\n\n\n\nIn the future, other methods may be added.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\DSPTypes.jl:23\n\n\n\n\n\n\nPainterQB.AlazarModule.InstrumentAlazar \n\u00b6\n\n\nAbstract type representing an AlazarTech digitizer.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\Alazar.jl:31\n\n\n\n\n\n\nPainterQB.AlazarModule.WindowBartlett{T} \n\u00b6\n\n\nBartlett window. Implemented in AlazarDSP.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\DSPTypes.jl:41\n\n\n\n\n\n\nPainterQB.AlazarModule.WindowBlackmanHarris{T} \n\u00b6\n\n\nBlackman-Harris window. Implemented in AlazarDSP.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\DSPTypes.jl:38\n\n\n\n\n\n\nPainterQB.AlazarModule.WindowBlackman{T} \n\u00b6\n\n\nBlackman window. Implemented in AlazarDSP.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\DSPTypes.jl:35\n\n\n\n\n\n\nPainterQB.AlazarModule.WindowHamming{T} \n\u00b6\n\n\nHamming window. Implemented in AlazarDSP.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\DSPTypes.jl:32\n\n\n\n\n\n\nPainterQB.AlazarModule.WindowHanning{T} \n\u00b6\n\n\nHanning window. Implemented in AlazarDSP.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\DSPTypes.jl:29\n\n\n\n\n\n\nPainterQB.AlazarModule.WindowNone{T} \n\u00b6\n\n\nFlat window (ones). Implemented in AlazarDSP.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\DSPTypes.jl:26\n\n\n\n\n\n\nPainterQB.AlazarModule.WindowZeroes{T} \n\u00b6\n\n\nFlat window (zeroes!).\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\DSPTypes.jl:44\n\n\nTypealiass [Exported]\n\n\n\n\n\n\nWindowOnes \n\u00b6\n\n\nType alias for \nWindowNone\n.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\DSPTypes.jl:47\n\n\nGlobals [Exported]\n\n\n\n\n\n\ninf_records \n\u00b6\n\n\nAlazar API representation of an infinite number of records.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\Alazar.jl:27\n\n\nFunctions [Internal]\n\n\n\n\n\n\nPainterQB.AlazarModule.adma \n\u00b6\n\n\nReturns the asynchronous DMA flags for a given \nAlazarMode\n. These are\npassed as the final parameter to the C function \nAlazarBeforeAsyncRead\n.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\CoreFunctions.jl:66\n\n\n\n\n\n\nPainterQB.AlazarModule.dsp \n\u00b6\n\n\nGiven a DSPWindow type, this returns the constant needed to use the AlazarDSP\nAPI to generate a particular window function.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\CoreFunctions.jl:412\n\n\n\n\n\n\nPainterQB.AlazarModule.generatewindowfunction \n\u00b6\n\n\nGiven a \nDSPWindow\n, samples per record, and padding samples, this will prepare\na window function.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\CoreFunctions.jl:438\n\n\n\n\n\n\nPainterQB.AlazarModule.initmodes \n\u00b6\n\n\nShould be called at the beginning of a measure method to initialize the\nAlazarMode objects.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\ResponseFunctions.jl:26\n\n\n\n\n\n\nPainterQB.AlazarModule.postprocess \n\u00b6\n\n\nArrange for reinterpretation or conversion of the data stored in the\nDMABuffers (backed by SharedArrays) to the desired return type.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\ResponseFunctions.jl:303\n\n\n\n\n\n\nPainterQB.AlazarModule.pretriggersamples \n\u00b6\n\n\nGiven an \nAlazarMode\n, returns the number of pre-trigger samples.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\CoreFunctions.jl:610\n\n\n\n\n\n\nPainterQB.AlazarModule.processing \n\u00b6\n\n\nSpecifies what to do with the buffers during measurement based on the response type.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\ResponseFunctions.jl:313\n\n\n\n\n\n\nPainterQB.AlazarModule.rec_acq_param \n\u00b6\n\n\nReturns the value to pass as the recordsPerAcquisition parameter in the C\nfunction \nAlazarBeforeAsyncRead\n, given an \nAlazarMode\n object.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\CoreFunctions.jl:639\n\n\n\n\n\n\nPainterQB.AlazarModule.records_per_acquisition \n\u00b6\n\n\nGiven an \nInstrumentAlazar\n and \nAlazarMode\n, return the records per acquisition.\nFor \nStreamMode\n this will return the number of buffers per acquisition.\n\nbuffer_sizing\n should be called first to ensure the \nAlazarMode\n object\ncontains values that meet size and alignment requirements.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\CoreFunctions.jl:651\n\n\n\n\n\n\nPainterQB.AlazarModule.records_per_buffer \n\u00b6\n\n\nGiven an \nInstrumentAlazar\n and \nAlazarMode\n, return the records per buffer.\nFor \nStreamMode\n this will return 1.\n\nbuffer_sizing\n should be called first to ensure the \nAlazarMode\n object\ncontains values that meet size and alignment requirements.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\CoreFunctions.jl:664\n\n\n\n\n\n\nPainterQB.AlazarModule.samples_per_buffer_measured \n\u00b6\n\n\nGiven an \nInstrumentAlazar\n and \nAlazarMode\n, return the samples per buffer\nmeasured by the digitizer.\n\nbuffer_sizing\n should be called first to ensure the \nAlazarMode\n object\ncontains values that meet size and alignment requirements.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\CoreFunctions.jl:674\n\n\n\n\n\n\nPainterQB.AlazarModule.samples_per_buffer_returned \n\u00b6\n\n\nGiven an \nInstrumentAlazar\n and \nAlazarMode\n, return the samples per buffer\nreturned by the digitizer.\n\nbuffer_sizing\n should be called first to ensure the \nAlazarMode\n object\ncontains values that meet size and alignment requirements.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\CoreFunctions.jl:684\n\n\n\n\n\n\nPainterQB.AlazarModule.samples_per_record_measured \n\u00b6\n\n\nGiven an \nInstrumentAlazar\n and \nAlazarMode\n, return the samples per record\nmeasured by the digitizer.\n\nbuffer_sizing\n should be called first to ensure the \nAlazarMode\n object\ncontains values that meet size and alignment requirements.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\CoreFunctions.jl:698\n\n\n\n\n\n\nPainterQB.AlazarModule.samples_per_record_returned \n\u00b6\n\n\nGiven an \nInstrumentAlazar\n and \nAlazarMode\n, return the samples per record\nreturned by the digitizer.\n\nbuffer_sizing\n should be called first to ensure the \nAlazarMode\n object\ncontains values that meet size and alignment requirements.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\CoreFunctions.jl:714\n\n\nMethods [Internal]\n\n\n\n\n\n\nauxmode(m::UInt32,  b::Bool) \n\u00b6\n\n\nMasks an AUX IO mode parameter to specify AUX IO software trigger enable.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\Configure.jl:6\n\n\n\n\n\n\nbits_per_sample(a::PainterQB.AlazarModule.AlazarATS9360) \n\u00b6\n\n\nHard coded to return 0x0c. May need to change if we want to play with data packing.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\models\\ATS9360.jl:234\n\n\n\n\n\n\nbits_per_sample(a::PainterQB.AlazarModule.InstrumentAlazar) \n\u00b6\n\n\nReturns the number of bits per sample. Queries the digitizer directly via\nthe C function \nAlazarGetChannelInfo\n.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\CoreFunctions.jl:117\n\n\n\n\n\n\nboardhandle(sysid::Integer,  boardid::Integer) \n\u00b6\n\n\nReturn a handle to an Alazar digitizer given a system ID and board ID.\nFor single digitizer systems, pass 1 for both to get a handle for the digitizer.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\CoreFunctions.jl:133\n\n\n\n\n\n\nboardkind(handle::UInt32) \n\u00b6\n\n\nReturns the kind of digitizer; corresponds to a constant in AlazarConstants.jl\nin the Alazar.jl package.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\CoreFunctions.jl:141\n\n\n\n\n\n\nbytes_per_sample(a::PainterQB.AlazarModule.AlazarATS9360) \n\u00b6\n\n\nHard coded to return 2. May need to change if we want to play with data packing.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\models\\ATS9360.jl:239\n\n\n\n\n\n\nbytes_per_sample(a::PainterQB.AlazarModule.InstrumentAlazar) \n\u00b6\n\n\nReturns the number of bytes per sample. Calls \nbitspersample\n and does ceiling\ndivision by 8.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\CoreFunctions.jl:399\n\n\n\n\n\n\ngenerate_configure{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty{T}}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty{T}}) \n\u00b6\n\n\nThis method generates the following method in the module where\n\ngenerate_configure\n is defined:\n\n\nconfigure(ins::InsType, ::Type{PropertySubtype}, infixes...)\n\n\n\n\nsource:\n\n\nPainterQB\\src\\Metaprogramming.jl:82\n\n\n\n\n\n\ngenerate_configure{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty{T}}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty{T}},  ::Type{PainterQB.NoArgs}) \n\u00b6\n\n\nThis method generates the following method in the module where\n\ngenerate_configure\n is defined:\n\n\nconfigure(ins::InsType, ::Type{PropertySubtype}, infixes...)\n\n\n\n\nThis particular method will be deprecated soon.\n\n\nsource:\n\n\nPainterQB\\src\\Metaprogramming.jl:122\n\n\n\n\n\n\ngenerate_configure{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty{T}}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty{T}},  returntype...) \n\u00b6\n\n\nThis method generates the following method in the module where\n\ngenerate_configure\n is defined:\n\n\nconfigure(ins::InsType, Property, values..., infixes...)\n\n\n\n\nsource:\n\n\nPainterQB\\src\\Metaprogramming.jl:151\n\n\n\n\n\n\ngenerate_handlers{T\n:PainterQB.Instrument}(insType::Type{T\n:PainterQB.Instrument},  responseDict::Dict{K, V}) \n\u00b6\n\n\nEach instrument can have a \nresponseDict\n. For each setting of the instrument,\nfor instance the \nClockSource\n, we need to know the correspondence between a\nlogical state \nExternalClock\n and how the instrument encodes that logical state\n(e.g. \"EXT\").\n\n\nThe \nresponseDict\n is actually a dictionary of dictionaries. The first level keys\nare like \nClockSource\n and the second level keys are like \"EXT\", with the value\nbeing \n:ExternalClock\n. Undoubtedly\nthis nested dictionary is \"nasty\" (in the technical parlance) but the dictionary\nis only used for code\ncreation and is not used at run-time (if the code works as intended).\n\n\nThis method makes a lot of other functions. Given some response from an instrument,\nwe require a function to map that response back on to the appropiate logical state.\n\n\nClockSource(ins::AWG5014C, res::AbstractString)\n\nreturns an \nInternalClock\n or \nExternalClock\n type as appropriate,\nbased on the logical meaning of the response.\n\n\nWe also want a function to generate logical states without having to know the way\nthey are encoded by the instrument.\n\n\ncode(ins::AWG5014C, ::Type{InternalClock})\n returns \"INT\",\nwith \"INT\" encoding how to pass this logical state to the instrument \nins\n.\n\n\nsource:\n\n\nPainterQB\\src\\Metaprogramming.jl:218\n\n\n\n\n\n\ngenerate_inspect{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty{T}}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty{T}},  ::Type{PainterQB.NoArgs}) \n\u00b6\n\n\nThis method does/returns nothing.\n\n\nsource:\n\n\nPainterQB\\src\\Metaprogramming.jl:14\n\n\n\n\n\n\ngenerate_inspect{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty{T}}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty{T}},  returntype...) \n\u00b6\n\n\nThis method will\ngenerate the following method in the module where \ngenerate_inspect\n is defined:\n\n\ninspect(ins::instype, ::Type{proptype}, infixes::Int...)\n\n\nThe \ninfixes\n variable argument allows for numbers to be inserted within the\ncommands, for instance in \nOUTP#:FILT:FREQ\n, where the \n#\n sign should be\nreplaced by an integer. The replacements are done in the order of the arguments.\nError checking is done on the number of arguments.\n\n\nFor a given property, \ninspect\n will return either an InstrumentProperty subtype,\na number, a boolean, or a string as appropriate.\n\n\nsource:\n\n\nPainterQB\\src\\Metaprogramming.jl:33\n\n\n\n\n\n\ngenerate_properties{S\n:PainterQB.InstrumentProperty{T}}(subtype::Symbol,  supertype::Type{S\n:PainterQB.InstrumentProperty{T}}) \n\u00b6\n\n\nCreates and exports immutable singleton subtypes.\n\n\nsource:\n\n\nPainterQB\\src\\Metaprogramming.jl:183\n\n\n\n\n\n\niqfft(sam_per_buf::Int64,  buf_completed::Int64,  rec_per_buf::Int64,  backing::SharedArray{T, N},  fft_array::SharedArray{T, N}) \n\u00b6\n\n\nConvert and copy\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\ResponseFunctions.jl:358\n\n\n\n\n\n\nscaling{T\n:AbstractArray{T, N}}(resp::PainterQB.AlazarModule.FFTResponse{T\n:AbstractArray{T, N}}) \n\u00b6\n\n\nReturns the axis scaling for an FFT response.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\ResponseFunctions.jl:319\n\n\n\n\n\n\nscaling{T\n:AbstractArray{T, N}}(resp::PainterQB.AlazarModule.FFTResponse{T\n:AbstractArray{T, N}},  whichaxis::Integer) \n\u00b6\n\n\nReturns the axis scaling for an FFT response.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\ResponseFunctions.jl:319\n\n\n\n\n\n\ntofloat!(sam_per_buf::Int64,  buf_completed::Int64,  backing::SharedArray{T, N}) \n\u00b6\n\n\nArrange multithreaded conversion of the Alazar 12-bit integer format to 16-bit\nfloating point format.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\ResponseFunctions.jl:344\n\n\n\n\n\n\ntriglevel(a::PainterQB.AlazarModule.AlazarATS9360,  x) \n\u00b6\n\n\nReturns a UInt32 in the range 0--255 given a desired trigger level in Volts.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\models\\ATS9360.jl:244\n\n\nTypes [Internal]\n\n\n\n\n\n\nPainterQB.AlazarModule.AlazarATS9440 \n\u00b6\n\n\nAbstract type; not implemented.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\models\\ATS9440.jl:2\n\n\nMacros [Internal]\n\n\n\n\n\n\n@eh2(expr) \n\u00b6\n\n\nTakes an Alazar API call and brackets it with some error checking.\nThrows an InstrumentException if there is an error.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\Errors.jl:8\n\n\nGlobals [Internal]\n\n\n\n\n\n\nlib_opened \n\u00b6\n\n\nFlag indicating whether the AlazarTech shared library has been opened.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\Alazar.jl:16", 
            "title": "AlazarTech"
        }, 
        {
            "location": "/api/AlazarTech/#painterqbalazarmodule", 
            "text": "", 
            "title": "PainterQB.AlazarModule"
        }, 
        {
            "location": "/api/AlazarTech/#functions-exported", 
            "text": "PainterQB.AlazarModule.abort  \u00b6  Aborts an acquisition. Must be called in the case of a DSP acquisition; somehow\nless fatal otherwise. Should be automatically taken care of in a well-written measure  method, but can be called manually by the paranoid.  source:  PainterQB\\src\\instruments\\Alazar\\CoreFunctions.jl:42    PainterQB.AlazarModule.before_async_read  \u00b6  Performs setup for asynchronous acquisitions. Should be called after buffersizing  has been called.  source:  PainterQB\\src\\instruments\\Alazar\\CoreFunctions.jl:111    PainterQB.AlazarModule.bufferarray  \u00b6  Given and  InstrumentAlazar  and  AlazarMode , returns a  DMABufferArray \nwith the correct number of buffers and buffer sizes.  buffersizing  should have\nbeen called before this function.  source:  PainterQB\\src\\instruments\\Alazar\\CoreFunctions.jl:161    PainterQB.AlazarModule.buffersizing  \u00b6  Given an  InstrumentAlazar  and an  AlazarMode , this will tweak parameters\nin the  AlazarMode  object to comply with record alignment and buffer granularity\nrequirements imposed by either the AlazarTech digitizer itself, or the implementation\nof measurement code. Should be called toward the very beginning of a  measure \nmethod.  source:  PainterQB\\src\\instruments\\Alazar\\CoreFunctions.jl:384    PainterQB.AlazarModule.fft_fpga_setup  \u00b6  If necessary, performs  AlazarFFTSetup , which should be called before AlazarBeforeAsyncRead .  source:  PainterQB\\src\\instruments\\Alazar\\CoreFunctions.jl:547    PainterQB.AlazarModule.recordsizing  \u00b6  Calls C function  AlazarSetRecordSize  if necessary, given an  InstrumentAlazar \nand  AlazarMode .  source:  PainterQB\\src\\instruments\\Alazar\\CoreFunctions.jl:630    PainterQB.AlazarModule.wait_buffer  \u00b6  Waits for a buffer to be processed (or a timeout to elapse).  source:  PainterQB\\src\\instruments\\Alazar\\CoreFunctions.jl:782", 
            "title": "Functions [Exported]"
        }, 
        {
            "location": "/api/AlazarTech/#methods-exported", 
            "text": "busy(a::PainterQB.AlazarModule.InstrumentAlazar)  \u00b6  Returns whether or not the  InstrumentAlazar  is busy (Bool).  source:  PainterQB\\src\\instruments\\Alazar\\CoreFunctions.jl:393    configure(a::PainterQB.AlazarModule.AlazarATS9360,  ::Type{PainterQB.SampleRate},  rate::Real)  \u00b6  Configure the sample rate to any multiple of 1 MHz (within 300 MHz and 1.8 GHz)\nusing the external clock.  source:  PainterQB\\src\\instruments\\Alazar\\models\\ATS9360.jl:145    configure(a::PainterQB.AlazarModule.InstrumentAlazar,  ::Type{PainterQB.AlazarModule.AuxSoftwareTriggerEnable},  b::Bool)  \u00b6  If an AUX IO output mode has been configured, then this will configure\nsoftware trigger enable. From the Alazar API:  When this flag is set, the board will wait for software to call AlazarForceTriggerEnable  to generate a trigger enable event; then wait for\nsufficient trigger events to capture the records in an AutoDMA buffer; then wait\nfor the next trigger enable event and repeat.  source:  PainterQB\\src\\instruments\\Alazar\\Configure.jl:81    configure(a::PainterQB.AlazarModule.InstrumentAlazar,  ::Type{PainterQB.AlazarModule.LED},  ledState::Bool)  \u00b6  Configures the LED on the digitizer card chassis.  source:  PainterQB\\src\\instruments\\Alazar\\Configure.jl:202    configure(a::PainterQB.AlazarModule.InstrumentAlazar,  ::Type{PainterQB.AlazarModule.RecordCount},  count)  \u00b6  Wrapper for C function  AlazarSetRecordCount . See the Alazar API.  source:  PainterQB\\src\\instruments\\Alazar\\Configure.jl:104    configure(a::PainterQB.AlazarModule.InstrumentAlazar,  ::Type{PainterQB.AlazarModule.Sleep},  sleepState)  \u00b6  Configures the sleep state of the digitizer card.  source:  PainterQB\\src\\instruments\\Alazar\\Configure.jl:208    configure(a::PainterQB.AlazarModule.InstrumentAlazar,  ::Type{PainterQB.AlazarModule.TriggerDelaySamples},  delay_samples)  \u00b6  Configure how many samples to wait after receiving a trigger event before capturing\na record.  source:  PainterQB\\src\\instruments\\Alazar\\Configure.jl:294    configure(a::PainterQB.AlazarModule.InstrumentAlazar,  ::Type{PainterQB.AlazarModule.TriggerTimeoutS},  timeout_s)  \u00b6  Wrapper for C function  AlazarSetTriggerTimeOut , except we take seconds here\ninstead of ticks (units of 10 us).  source:  PainterQB\\src\\instruments\\Alazar\\Configure.jl:313    configure(a::PainterQB.AlazarModule.InstrumentAlazar,  ::Type{PainterQB.AlazarModule.TriggerTimeoutTicks},  ticks)  \u00b6  Wrapper for C function  AlazarSetTriggerTimeOut .  source:  PainterQB\\src\\instruments\\Alazar\\Configure.jl:303    configure(a::PainterQB.AlazarModule.InstrumentAlazar,  ::Type{PainterQB.TriggerLevel},  levelJ,  levelK)  \u00b6  Configure the trigger level for trigger engine J and K. This should be an\nunsigned 8 bit integer (0--255) corresponding to the full range of the digitizer.  source:  PainterQB\\src\\instruments\\Alazar\\Configure.jl:269    configure(a::PainterQB.AlazarModule.InstrumentAlazar,  aux::Type{PainterQB.AlazarModule.AuxDigitalInput})  \u00b6  Configure a digitizer's AUX IO to act as a digital input.  source:  PainterQB\\src\\instruments\\Alazar\\Configure.jl:25    configure(a::PainterQB.AlazarModule.InstrumentAlazar,  aux::Type{PainterQB.AlazarModule.AuxDigitalOutput},  level::Integer)  \u00b6  Configure a digitizer's AUX IO port to act as a general purpose digital output.  source:  PainterQB\\src\\instruments\\Alazar\\Configure.jl:62    configure(a::PainterQB.AlazarModule.InstrumentAlazar,  aux::Type{PainterQB.AlazarModule.AuxOutputPacer},  divider::Integer)  \u00b6  Configure a digitizer's AUX IO port to output the sample clock, divided by an integer.  source:  PainterQB\\src\\instruments\\Alazar\\Configure.jl:49    configure(a::PainterQB.AlazarModule.InstrumentAlazar,  aux::Type{PainterQB.AlazarModule.AuxOutputTrigger})  \u00b6  Configure a digitizer's AUX IO to output a trigger signal synced to the sample clock.  source:  PainterQB\\src\\instruments\\Alazar\\Configure.jl:15    configure(a::PainterQB.AlazarModule.InstrumentAlazar,  ch::Type{PainterQB.AlazarModule.BothChannels})  \u00b6  Configures acquisition from both channels, simultaneously.  source:  PainterQB\\src\\instruments\\Alazar\\Configure.jl:122    configure{S :PainterQB.AlazarModule.AlazarDataPacking}(a::PainterQB.AlazarModule.InstrumentAlazar,  ::Type{PainterQB.AlazarModule.AlazarDataPacking},  pack::Type{S :PainterQB.AlazarModule.AlazarDataPacking},  ch::Type{PainterQB.AlazarModule.BothChannels})  \u00b6  Configures the data packing mode for both channels.  source:  PainterQB\\src\\instruments\\Alazar\\Configure.jl:191    configure{S :PainterQB.AlazarModule.AlazarDataPacking}(a::PainterQB.AlazarModule.InstrumentAlazar,  ::Type{PainterQB.AlazarModule.AlazarDataPacking},  pack::Type{S :PainterQB.AlazarModule.AlazarDataPacking},  ch::Type{PainterQB.AlazarModule.ChannelA})  \u00b6  Configures the data packing mode for channel A.  source:  PainterQB\\src\\instruments\\Alazar\\Configure.jl:163    configure{S :PainterQB.AlazarModule.AlazarDataPacking}(a::PainterQB.AlazarModule.InstrumentAlazar,  ::Type{PainterQB.AlazarModule.AlazarDataPacking},  pack::Type{S :PainterQB.AlazarModule.AlazarDataPacking},  ch::Type{PainterQB.AlazarModule.ChannelB})  \u00b6  Configures the data packing mode for channel B.  source:  PainterQB\\src\\instruments\\Alazar\\Configure.jl:177    configure{S :PainterQB.AlazarModule.DSPWindow{T}, T :PainterQB.AlazarModule.DSPWindow{T}}(a::PainterQB.AlazarModule.AlazarATS9360,  re::Type{S :PainterQB.AlazarModule.DSPWindow{T}},  im::Type{T :PainterQB.AlazarModule.DSPWindow{T}})  \u00b6  Configures the DSP windows.  AlazarFFTSetWindowFunction  is called towards\nthe start of  measure  rather than here.  source:  PainterQB\\src\\instruments\\Alazar\\models\\ATS9360.jl:180    configure{S :PainterQB.TriggerSlope, T :PainterQB.TriggerSlope}(a::PainterQB.AlazarModule.InstrumentAlazar,  slopeJ::Type{S :PainterQB.TriggerSlope},  slopeK::Type{T :PainterQB.TriggerSlope})  \u00b6  Configures whether to trigger on a rising or falling slope, for engine J and K.  source:  PainterQB\\src\\instruments\\Alazar\\Configure.jl:240    configure{S :PainterQB.TriggerSource, T :PainterQB.TriggerSource}(a::PainterQB.AlazarModule.InstrumentAlazar,  sourceJ::Type{S :PainterQB.TriggerSource},  sourceK::Type{T :PainterQB.TriggerSource})  \u00b6  Configure the trigger source for trigger engine J and K.  source:  PainterQB\\src\\instruments\\Alazar\\Configure.jl:254    configure{T :PainterQB.AlazarModule.AlazarChannel}(a::PainterQB.AlazarModule.InstrumentAlazar,  ch::Type{T :PainterQB.AlazarModule.AlazarChannel})  \u00b6  Configures the acquisition channel.  source:  PainterQB\\src\\instruments\\Alazar\\Configure.jl:114    configure{T :PainterQB.AlazarModule.AlazarTimestampReset}(a::PainterQB.AlazarModule.InstrumentAlazar,  t::Type{T :PainterQB.AlazarModule.AlazarTimestampReset})  \u00b6  Configures timestamp reset. From the Alazar API, the choices are TimestampResetOnce \n(Reset the timestamp counter to zero on the next call to  AlazarStartCapture ,\nbut not thereafter.) or  TimestampResetAlways  (Reset the timestamp counter to\nzero on each call to AlazarStartCapture. This is the default operation.)  source:  PainterQB\\src\\instruments\\Alazar\\Configure.jl:221    configure{T :PainterQB.AlazarModule.AlazarTriggerEngine}(a::PainterQB.AlazarModule.InstrumentAlazar,  engine::Type{T :PainterQB.AlazarModule.AlazarTriggerEngine})  \u00b6  Configures the trigger engines, e.g. TriggerOnJ, TriggerOnJAndNotK, etc.  source:  PainterQB\\src\\instruments\\Alazar\\Configure.jl:231    configure{T :PainterQB.AlazarModule.AlazarTriggerRange}(a::PainterQB.AlazarModule.AlazarATS9360,  range::Type{T :PainterQB.AlazarModule.AlazarTriggerRange})  \u00b6  Does nothing but display info telling you that this parameter cannot be changed\nfrom 5V range on the ATS9360.  source:  PainterQB\\src\\instruments\\Alazar\\models\\ATS9360.jl:172    configure{T :PainterQB.AlazarModule.AlazarTriggerRange}(a::PainterQB.AlazarModule.InstrumentAlazar,  range::Type{T :PainterQB.AlazarModule.AlazarTriggerRange})  \u00b6  Configure the external trigger range.  source:  PainterQB\\src\\instruments\\Alazar\\Configure.jl:284    configure{T :PainterQB.ClockSlope}(a::PainterQB.AlazarModule.InstrumentAlazar,  slope::Type{T :PainterQB.ClockSlope})  \u00b6  Configures whether the clock ticks on a rising or falling slope.  source:  PainterQB\\src\\instruments\\Alazar\\Configure.jl:146    configure{T :PainterQB.Coupling}(a::PainterQB.AlazarModule.AlazarATS9360,  coupling::Type{T :PainterQB.Coupling})  \u00b6  Does nothing but display info telling you that this parameter cannot be changed\nfrom DC coupling on the ATS9360.  source:  PainterQB\\src\\instruments\\Alazar\\models\\ATS9360.jl:164    configure{T :PainterQB.Coupling}(a::PainterQB.AlazarModule.InstrumentAlazar,  coupling::Type{T :PainterQB.Coupling})  \u00b6  Configure the external trigger coupling.  source:  PainterQB\\src\\instruments\\Alazar\\Configure.jl:277    configure{T :PainterQB.SampleRate}(a::PainterQB.AlazarModule.InstrumentAlazar,  rate::Type{T :PainterQB.SampleRate})  \u00b6  Configures one of the preset sample rates derived from the internal clock.  source:  PainterQB\\src\\instruments\\Alazar\\Configure.jl:131    configure{T :PainterQB.TriggerSlope}(a::PainterQB.AlazarModule.InstrumentAlazar,  aux::Type{PainterQB.AlazarModule.AuxInputTriggerEnable},  trigSlope::Type{T :PainterQB.TriggerSlope})  \u00b6  Configure a digitizer's AUX IO port to use the edge of a pulse as an AutoDMA\ntrigger signal.  source:  PainterQB\\src\\instruments\\Alazar\\Configure.jl:37    dsp_getinfo(dspModule::PainterQB.AlazarModule.DSPModule)  \u00b6  Returns a DSPModuleInfo object that describes a DSPModule.  source:  PainterQB\\src\\instruments\\Alazar\\CoreFunctions.jl:442    dsp_getmodulehandles(a::PainterQB.AlazarModule.InstrumentAlazar)  \u00b6  Returns an Array of  dsp_module_handle .  source:  PainterQB\\src\\instruments\\Alazar\\CoreFunctions.jl:466    dsp_modules(a::PainterQB.AlazarModule.InstrumentAlazar)  \u00b6  Returns an array of  DSPModule .  source:  PainterQB\\src\\instruments\\Alazar\\CoreFunctions.jl:483    dsp_num_modules(a::PainterQB.AlazarModule.InstrumentAlazar)  \u00b6  Returns the number of  DSPModule .  source:  PainterQB\\src\\instruments\\Alazar\\CoreFunctions.jl:488    forcetrigger(a::PainterQB.AlazarModule.InstrumentAlazar)  \u00b6  Force a software trigger.  source:  PainterQB\\src\\instruments\\Alazar\\CoreFunctions.jl:562    forcetriggerenable(a::PainterQB.AlazarModule.InstrumentAlazar)  \u00b6  Force a software \"trigger enable.\" This involves the AUX I/O connector (see\nAlazar API).  source:  PainterQB\\src\\instruments\\Alazar\\CoreFunctions.jl:571    inputcontrol(a::PainterQB.AlazarModule.InstrumentAlazar,  channel,  coupling,  inputRange,  impedance)  \u00b6  Controls coupling, input range, and impedance for applicable digitizer cards.\nDoes nothing for ATS9360 cards since there is only one choice of arguments.  source:  PainterQB\\src\\instruments\\Alazar\\CoreFunctions.jl:580    inspect(a::PainterQB.AlazarModule.AlazarATS9360,  ::Type{PainterQB.AlazarModule.BufferAlignment})  \u00b6  Returns the buffer alignment requirement (samples / record / channel).\nNote that buffers must also be page-aligned.\nFrom Table 8 of the Alazar API.  source:  PainterQB\\src\\instruments\\Alazar\\models\\ATS9360.jl:220    inspect(a::PainterQB.AlazarModule.AlazarATS9360,  ::Type{PainterQB.AlazarModule.MaxBufferBytes})  \u00b6  Maximum number of bytes for a given DMA buffer.  source:  PainterQB\\src\\instruments\\Alazar\\models\\ATS9360.jl:202    inspect(a::PainterQB.AlazarModule.AlazarATS9360,  ::Type{PainterQB.AlazarModule.MaxFFTSamples})  \u00b6  Maximum number of samples in an FPGA-based FFT. Can be obtained from  dsp_getinfo \nbut we have hardcoded since it should not change for this model of digitizer.  source:  PainterQB\\src\\instruments\\Alazar\\models\\ATS9360.jl:213    inspect(a::PainterQB.AlazarModule.AlazarATS9360,  ::Type{PainterQB.AlazarModule.MinFFTSamples})  \u00b6  Minimum number of samples in an FPGA-based FFT. Set by the minimum record size.  source:  PainterQB\\src\\instruments\\Alazar\\models\\ATS9360.jl:207    inspect(a::PainterQB.AlazarModule.AlazarATS9360,  ::Type{PainterQB.AlazarModule.MinSamplesPerRecord})  \u00b6  Minimum samples per record. Observed behavior deviates from Table 8 of the\nAlazar API.  source:  PainterQB\\src\\instruments\\Alazar\\models\\ATS9360.jl:196    inspect(a::PainterQB.AlazarModule.AlazarATS9360,  ::Type{PainterQB.AlazarModule.PretriggerAlignment})  \u00b6  Returns the pretrigger alignment requirement (samples / record / channel).\nFrom Table 8 of the Alazar API.  source:  PainterQB\\src\\instruments\\Alazar\\models\\ATS9360.jl:227    inspect(a::PainterQB.AlazarModule.InstrumentAlazar,  ::Type{PainterQB.AlazarModule.AlazarAux})  \u00b6  Inspect the AUX IO mode.  source:  PainterQB\\src\\instruments\\Alazar\\Inspect.jl:6    inspect(a::PainterQB.AlazarModule.InstrumentAlazar,  ::Type{PainterQB.AlazarModule.AlazarChannel})  \u00b6  Returns which channel(s) will be acquired.  source:  PainterQB\\src\\instruments\\Alazar\\Inspect.jl:13    inspect(a::PainterQB.AlazarModule.InstrumentAlazar,  ::Type{PainterQB.AlazarModule.ChannelCount})  \u00b6  Returns the number of channels to acquire.  source:  PainterQB\\src\\instruments\\Alazar\\Inspect.jl:17    inspect(a::PainterQB.AlazarModule.InstrumentAlazar,  ::Type{PainterQB.AlazarModule.SampleMemoryPerChannel})  \u00b6  Returns the memory per channel in units of samples.  source:  PainterQB\\src\\instruments\\Alazar\\Inspect.jl:41    inspect(a::PainterQB.AlazarModule.InstrumentAlazar,  ::Type{PainterQB.SampleRate})  \u00b6  Inspect the sample rate. As currently programmed, does not distinguish\nbetween the internal preset clock rates and otherwise.  source:  PainterQB\\src\\instruments\\Alazar\\Inspect.jl:35    inspect{T :PainterQB.AlazarModule.AlazarChannel}(a::PainterQB.AlazarModule.InstrumentAlazar,  ::Type{PainterQB.AlazarModule.AlazarDataPacking},  ch::Type{T :PainterQB.AlazarModule.AlazarChannel})  \u00b6  Inspect the data packing mode for a given channel.  source:  PainterQB\\src\\instruments\\Alazar\\Inspect.jl:22    measure(ch::PainterQB.AlazarModule.AlazarResponse{T})  \u00b6  Largely generic method for measuring  AlazarResponse . Can be considered a\nprototype for more complicated user-defined methods.  source:  PainterQB\\src\\instruments\\Alazar\\ResponseFunctions.jl:97    measure(ch::PainterQB.AlazarModule.IQSoftwareResponse{T})  \u00b6  Assume two-channel IQ FFT acquisition.  source:  PainterQB\\src\\instruments\\Alazar\\ResponseFunctions.jl:189    post_async_buffer(a::PainterQB.AlazarModule.InstrumentAlazar,  buffer,  bufferLength)  \u00b6  Post an asynchronous buffer to the digitizer for use in an acquisition.\nBuffer address must meet alignment requirements.  source:  PainterQB\\src\\instruments\\Alazar\\CoreFunctions.jl:599    set_parameter(a::PainterQB.AlazarModule.InstrumentAlazar,  channelId,  parameterId,  value)  \u00b6  Julia wrapper for C function AlazarSetParameter, with error checking.  source:  PainterQB\\src\\instruments\\Alazar\\CoreFunctions.jl:717    set_parameter_ul(a::PainterQB.AlazarModule.InstrumentAlazar,  channelId,  parameterId,  value)  \u00b6  Julia wrapper for C function AlazarSetParameterUL, with error checking.  source:  PainterQB\\src\\instruments\\Alazar\\CoreFunctions.jl:723    set_triggeroperation(a::PainterQB.AlazarModule.InstrumentAlazar,  args...)  \u00b6  Configure the trigger operation. Usually not called directly.\nArgs should be, in the following order:  a::InstrumentAlazar  engine:  one of the trigger engine operation IDs in the Alazar API.  source1: one of  TRIG_CHAN_A ,  TRIG_CHAN_B , or  TRIG_DISABLE  slope1:   TRIGGER_SLOPE_POSITIVE  or  TRIGGER_SLOPE_NEGATIVE  level1:  a voltage (V).  source2: one of  TRIG_CHAN_A ,  TRIG_CHAN_B , or  TRIG_DISABLE  slope2:   TRIGGER_SLOPE_POSITIVE  or  TRIGGER_SLOPE_NEGATIVE  level2:  a voltage (V).  source:  PainterQB\\src\\instruments\\Alazar\\CoreFunctions.jl:748    startcapture(a::PainterQB.AlazarModule.InstrumentAlazar)  \u00b6  Should be called after  before_async_read  has been called and buffers are posted.  source:  PainterQB\\src\\instruments\\Alazar\\CoreFunctions.jl:763    triggered(a::PainterQB.AlazarModule.InstrumentAlazar)  \u00b6  Reports whether or not the digitizer has been triggered.  source:  PainterQB\\src\\instruments\\Alazar\\CoreFunctions.jl:769", 
            "title": "Methods [Exported]"
        }, 
        {
            "location": "/api/AlazarTech/#types-exported", 
            "text": "PainterQB.AlazarModule.AlazarATS9360  \u00b6  Concrete InstrumentAlazar subtype representing an ATS9360 digitizer.  Defaults are selected as:   DC coupling (all). Cannot be changed for the ATS9360.  Input range +/- 0.4V for channel A, B. Cannot be changed for the ATS9360.  External trigger range: 5 V. Cannot be changed for the ATS9360 (?)  All impedances 50 Ohm. Cannot be changed for the ATS9360.  Internal clock, 1 GSps, rising edge.  Trigger on J; engine J fires when channel A crosses zero from below.  Trigger delay 0 samples; no trigger timeout  Acquire with both channels  AUX IO outputs a trigger signal synced to the sample clock.   source:  PainterQB\\src\\instruments\\Alazar\\models\\ATS9360.jl:18    PainterQB.AlazarModule.DSPModule  \u00b6  Represents a DSP module of an AlazarTech digitizer.  source:  PainterQB\\src\\instruments\\Alazar\\DSPTypes.jl:50    PainterQB.AlazarModule.DSPModuleInfo  \u00b6  Encapsulates DSP module information: type, version, and max record length.  source:  PainterQB\\src\\instruments\\Alazar\\DSPTypes.jl:56    PainterQB.AlazarModule.DSPWindow{T}  \u00b6  Abstract parametric type representing a windowing function for DSP.\nThe parameter determines the method of window generation:   :alazar : Use the AlazarDSP to synthesize the window  No parameter: Use default software method   In the future, other methods may be added.  source:  PainterQB\\src\\instruments\\Alazar\\DSPTypes.jl:23    PainterQB.AlazarModule.InstrumentAlazar  \u00b6  Abstract type representing an AlazarTech digitizer.  source:  PainterQB\\src\\instruments\\Alazar\\Alazar.jl:31    PainterQB.AlazarModule.WindowBartlett{T}  \u00b6  Bartlett window. Implemented in AlazarDSP.  source:  PainterQB\\src\\instruments\\Alazar\\DSPTypes.jl:41    PainterQB.AlazarModule.WindowBlackmanHarris{T}  \u00b6  Blackman-Harris window. Implemented in AlazarDSP.  source:  PainterQB\\src\\instruments\\Alazar\\DSPTypes.jl:38    PainterQB.AlazarModule.WindowBlackman{T}  \u00b6  Blackman window. Implemented in AlazarDSP.  source:  PainterQB\\src\\instruments\\Alazar\\DSPTypes.jl:35    PainterQB.AlazarModule.WindowHamming{T}  \u00b6  Hamming window. Implemented in AlazarDSP.  source:  PainterQB\\src\\instruments\\Alazar\\DSPTypes.jl:32    PainterQB.AlazarModule.WindowHanning{T}  \u00b6  Hanning window. Implemented in AlazarDSP.  source:  PainterQB\\src\\instruments\\Alazar\\DSPTypes.jl:29    PainterQB.AlazarModule.WindowNone{T}  \u00b6  Flat window (ones). Implemented in AlazarDSP.  source:  PainterQB\\src\\instruments\\Alazar\\DSPTypes.jl:26    PainterQB.AlazarModule.WindowZeroes{T}  \u00b6  Flat window (zeroes!).  source:  PainterQB\\src\\instruments\\Alazar\\DSPTypes.jl:44", 
            "title": "Types [Exported]"
        }, 
        {
            "location": "/api/AlazarTech/#typealiass-exported", 
            "text": "WindowOnes  \u00b6  Type alias for  WindowNone .  source:  PainterQB\\src\\instruments\\Alazar\\DSPTypes.jl:47", 
            "title": "Typealiass [Exported]"
        }, 
        {
            "location": "/api/AlazarTech/#globals-exported", 
            "text": "inf_records  \u00b6  Alazar API representation of an infinite number of records.  source:  PainterQB\\src\\instruments\\Alazar\\Alazar.jl:27", 
            "title": "Globals [Exported]"
        }, 
        {
            "location": "/api/AlazarTech/#functions-internal", 
            "text": "PainterQB.AlazarModule.adma  \u00b6  Returns the asynchronous DMA flags for a given  AlazarMode . These are\npassed as the final parameter to the C function  AlazarBeforeAsyncRead .  source:  PainterQB\\src\\instruments\\Alazar\\CoreFunctions.jl:66    PainterQB.AlazarModule.dsp  \u00b6  Given a DSPWindow type, this returns the constant needed to use the AlazarDSP\nAPI to generate a particular window function.  source:  PainterQB\\src\\instruments\\Alazar\\CoreFunctions.jl:412    PainterQB.AlazarModule.generatewindowfunction  \u00b6  Given a  DSPWindow , samples per record, and padding samples, this will prepare\na window function.  source:  PainterQB\\src\\instruments\\Alazar\\CoreFunctions.jl:438    PainterQB.AlazarModule.initmodes  \u00b6  Should be called at the beginning of a measure method to initialize the\nAlazarMode objects.  source:  PainterQB\\src\\instruments\\Alazar\\ResponseFunctions.jl:26    PainterQB.AlazarModule.postprocess  \u00b6  Arrange for reinterpretation or conversion of the data stored in the\nDMABuffers (backed by SharedArrays) to the desired return type.  source:  PainterQB\\src\\instruments\\Alazar\\ResponseFunctions.jl:303    PainterQB.AlazarModule.pretriggersamples  \u00b6  Given an  AlazarMode , returns the number of pre-trigger samples.  source:  PainterQB\\src\\instruments\\Alazar\\CoreFunctions.jl:610    PainterQB.AlazarModule.processing  \u00b6  Specifies what to do with the buffers during measurement based on the response type.  source:  PainterQB\\src\\instruments\\Alazar\\ResponseFunctions.jl:313    PainterQB.AlazarModule.rec_acq_param  \u00b6  Returns the value to pass as the recordsPerAcquisition parameter in the C\nfunction  AlazarBeforeAsyncRead , given an  AlazarMode  object.  source:  PainterQB\\src\\instruments\\Alazar\\CoreFunctions.jl:639    PainterQB.AlazarModule.records_per_acquisition  \u00b6  Given an  InstrumentAlazar  and  AlazarMode , return the records per acquisition.\nFor  StreamMode  this will return the number of buffers per acquisition. buffer_sizing  should be called first to ensure the  AlazarMode  object\ncontains values that meet size and alignment requirements.  source:  PainterQB\\src\\instruments\\Alazar\\CoreFunctions.jl:651    PainterQB.AlazarModule.records_per_buffer  \u00b6  Given an  InstrumentAlazar  and  AlazarMode , return the records per buffer.\nFor  StreamMode  this will return 1. buffer_sizing  should be called first to ensure the  AlazarMode  object\ncontains values that meet size and alignment requirements.  source:  PainterQB\\src\\instruments\\Alazar\\CoreFunctions.jl:664    PainterQB.AlazarModule.samples_per_buffer_measured  \u00b6  Given an  InstrumentAlazar  and  AlazarMode , return the samples per buffer\nmeasured by the digitizer. buffer_sizing  should be called first to ensure the  AlazarMode  object\ncontains values that meet size and alignment requirements.  source:  PainterQB\\src\\instruments\\Alazar\\CoreFunctions.jl:674    PainterQB.AlazarModule.samples_per_buffer_returned  \u00b6  Given an  InstrumentAlazar  and  AlazarMode , return the samples per buffer\nreturned by the digitizer. buffer_sizing  should be called first to ensure the  AlazarMode  object\ncontains values that meet size and alignment requirements.  source:  PainterQB\\src\\instruments\\Alazar\\CoreFunctions.jl:684    PainterQB.AlazarModule.samples_per_record_measured  \u00b6  Given an  InstrumentAlazar  and  AlazarMode , return the samples per record\nmeasured by the digitizer. buffer_sizing  should be called first to ensure the  AlazarMode  object\ncontains values that meet size and alignment requirements.  source:  PainterQB\\src\\instruments\\Alazar\\CoreFunctions.jl:698    PainterQB.AlazarModule.samples_per_record_returned  \u00b6  Given an  InstrumentAlazar  and  AlazarMode , return the samples per record\nreturned by the digitizer. buffer_sizing  should be called first to ensure the  AlazarMode  object\ncontains values that meet size and alignment requirements.  source:  PainterQB\\src\\instruments\\Alazar\\CoreFunctions.jl:714", 
            "title": "Functions [Internal]"
        }, 
        {
            "location": "/api/AlazarTech/#methods-internal", 
            "text": "auxmode(m::UInt32,  b::Bool)  \u00b6  Masks an AUX IO mode parameter to specify AUX IO software trigger enable.  source:  PainterQB\\src\\instruments\\Alazar\\Configure.jl:6    bits_per_sample(a::PainterQB.AlazarModule.AlazarATS9360)  \u00b6  Hard coded to return 0x0c. May need to change if we want to play with data packing.  source:  PainterQB\\src\\instruments\\Alazar\\models\\ATS9360.jl:234    bits_per_sample(a::PainterQB.AlazarModule.InstrumentAlazar)  \u00b6  Returns the number of bits per sample. Queries the digitizer directly via\nthe C function  AlazarGetChannelInfo .  source:  PainterQB\\src\\instruments\\Alazar\\CoreFunctions.jl:117    boardhandle(sysid::Integer,  boardid::Integer)  \u00b6  Return a handle to an Alazar digitizer given a system ID and board ID.\nFor single digitizer systems, pass 1 for both to get a handle for the digitizer.  source:  PainterQB\\src\\instruments\\Alazar\\CoreFunctions.jl:133    boardkind(handle::UInt32)  \u00b6  Returns the kind of digitizer; corresponds to a constant in AlazarConstants.jl\nin the Alazar.jl package.  source:  PainterQB\\src\\instruments\\Alazar\\CoreFunctions.jl:141    bytes_per_sample(a::PainterQB.AlazarModule.AlazarATS9360)  \u00b6  Hard coded to return 2. May need to change if we want to play with data packing.  source:  PainterQB\\src\\instruments\\Alazar\\models\\ATS9360.jl:239    bytes_per_sample(a::PainterQB.AlazarModule.InstrumentAlazar)  \u00b6  Returns the number of bytes per sample. Calls  bitspersample  and does ceiling\ndivision by 8.  source:  PainterQB\\src\\instruments\\Alazar\\CoreFunctions.jl:399    generate_configure{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty{T}}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty{T}})  \u00b6  This method generates the following method in the module where generate_configure  is defined:  configure(ins::InsType, ::Type{PropertySubtype}, infixes...)  source:  PainterQB\\src\\Metaprogramming.jl:82    generate_configure{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty{T}}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty{T}},  ::Type{PainterQB.NoArgs})  \u00b6  This method generates the following method in the module where generate_configure  is defined:  configure(ins::InsType, ::Type{PropertySubtype}, infixes...)  This particular method will be deprecated soon.  source:  PainterQB\\src\\Metaprogramming.jl:122    generate_configure{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty{T}}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty{T}},  returntype...)  \u00b6  This method generates the following method in the module where generate_configure  is defined:  configure(ins::InsType, Property, values..., infixes...)  source:  PainterQB\\src\\Metaprogramming.jl:151    generate_handlers{T :PainterQB.Instrument}(insType::Type{T :PainterQB.Instrument},  responseDict::Dict{K, V})  \u00b6  Each instrument can have a  responseDict . For each setting of the instrument,\nfor instance the  ClockSource , we need to know the correspondence between a\nlogical state  ExternalClock  and how the instrument encodes that logical state\n(e.g. \"EXT\").  The  responseDict  is actually a dictionary of dictionaries. The first level keys\nare like  ClockSource  and the second level keys are like \"EXT\", with the value\nbeing  :ExternalClock . Undoubtedly\nthis nested dictionary is \"nasty\" (in the technical parlance) but the dictionary\nis only used for code\ncreation and is not used at run-time (if the code works as intended).  This method makes a lot of other functions. Given some response from an instrument,\nwe require a function to map that response back on to the appropiate logical state.  ClockSource(ins::AWG5014C, res::AbstractString) \nreturns an  InternalClock  or  ExternalClock  type as appropriate,\nbased on the logical meaning of the response.  We also want a function to generate logical states without having to know the way\nthey are encoded by the instrument.  code(ins::AWG5014C, ::Type{InternalClock})  returns \"INT\",\nwith \"INT\" encoding how to pass this logical state to the instrument  ins .  source:  PainterQB\\src\\Metaprogramming.jl:218    generate_inspect{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty{T}}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty{T}},  ::Type{PainterQB.NoArgs})  \u00b6  This method does/returns nothing.  source:  PainterQB\\src\\Metaprogramming.jl:14    generate_inspect{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty{T}}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty{T}},  returntype...)  \u00b6  This method will\ngenerate the following method in the module where  generate_inspect  is defined:  inspect(ins::instype, ::Type{proptype}, infixes::Int...)  The  infixes  variable argument allows for numbers to be inserted within the\ncommands, for instance in  OUTP#:FILT:FREQ , where the  #  sign should be\nreplaced by an integer. The replacements are done in the order of the arguments.\nError checking is done on the number of arguments.  For a given property,  inspect  will return either an InstrumentProperty subtype,\na number, a boolean, or a string as appropriate.  source:  PainterQB\\src\\Metaprogramming.jl:33    generate_properties{S :PainterQB.InstrumentProperty{T}}(subtype::Symbol,  supertype::Type{S :PainterQB.InstrumentProperty{T}})  \u00b6  Creates and exports immutable singleton subtypes.  source:  PainterQB\\src\\Metaprogramming.jl:183    iqfft(sam_per_buf::Int64,  buf_completed::Int64,  rec_per_buf::Int64,  backing::SharedArray{T, N},  fft_array::SharedArray{T, N})  \u00b6  Convert and copy  source:  PainterQB\\src\\instruments\\Alazar\\ResponseFunctions.jl:358    scaling{T :AbstractArray{T, N}}(resp::PainterQB.AlazarModule.FFTResponse{T :AbstractArray{T, N}})  \u00b6  Returns the axis scaling for an FFT response.  source:  PainterQB\\src\\instruments\\Alazar\\ResponseFunctions.jl:319    scaling{T :AbstractArray{T, N}}(resp::PainterQB.AlazarModule.FFTResponse{T :AbstractArray{T, N}},  whichaxis::Integer)  \u00b6  Returns the axis scaling for an FFT response.  source:  PainterQB\\src\\instruments\\Alazar\\ResponseFunctions.jl:319    tofloat!(sam_per_buf::Int64,  buf_completed::Int64,  backing::SharedArray{T, N})  \u00b6  Arrange multithreaded conversion of the Alazar 12-bit integer format to 16-bit\nfloating point format.  source:  PainterQB\\src\\instruments\\Alazar\\ResponseFunctions.jl:344    triglevel(a::PainterQB.AlazarModule.AlazarATS9360,  x)  \u00b6  Returns a UInt32 in the range 0--255 given a desired trigger level in Volts.  source:  PainterQB\\src\\instruments\\Alazar\\models\\ATS9360.jl:244", 
            "title": "Methods [Internal]"
        }, 
        {
            "location": "/api/AlazarTech/#types-internal", 
            "text": "PainterQB.AlazarModule.AlazarATS9440  \u00b6  Abstract type; not implemented.  source:  PainterQB\\src\\instruments\\Alazar\\models\\ATS9440.jl:2", 
            "title": "Types [Internal]"
        }, 
        {
            "location": "/api/AlazarTech/#macros-internal", 
            "text": "@eh2(expr)  \u00b6  Takes an Alazar API call and brackets it with some error checking.\nThrows an InstrumentException if there is an error.  source:  PainterQB\\src\\instruments\\Alazar\\Errors.jl:8", 
            "title": "Macros [Internal]"
        }, 
        {
            "location": "/api/AlazarTech/#globals-internal", 
            "text": "lib_opened  \u00b6  Flag indicating whether the AlazarTech shared library has been opened.  source:  PainterQB\\src\\instruments\\Alazar\\Alazar.jl:16", 
            "title": "Globals [Internal]"
        }, 
        {
            "location": "/releases/", 
            "text": "Releases\n\n\nv0.0.1      Currently under development", 
            "title": "Release notes"
        }, 
        {
            "location": "/releases/#releases", 
            "text": "v0.0.1      Currently under development", 
            "title": "Releases"
        }, 
        {
            "location": "/LICENSE/", 
            "text": "License\n\n\nMost code:\n\n\n\n\nCopyright (c) 2015: Andrew Keller.\n\n\n\n\nRandom.jl, Time.jl, and a few other snippets here and there:\n\n\n\n\nCopyright (c) 2014: Menyoung Lee.\n\n\n\n\nLarge majority of code in VISA.jl package:\n\n\n\n\nCopyright (c) 2014: Colm Ryan.\n\n\n\n\nAll of the code is licensed under the MIT \"Expat\" License by the respective\ncopyright holders:\n\n\n\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.", 
            "title": "License"
        }, 
        {
            "location": "/LICENSE/#license", 
            "text": "Most code:   Copyright (c) 2015: Andrew Keller.   Random.jl, Time.jl, and a few other snippets here and there:   Copyright (c) 2014: Menyoung Lee.   Large majority of code in VISA.jl package:   Copyright (c) 2014: Colm Ryan.   All of the code is licensed under the MIT \"Expat\" License by the respective\ncopyright holders:   Permission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:  The above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.", 
            "title": "License"
        }
    ]
}