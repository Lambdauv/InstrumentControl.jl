{
    "docs": [
        {
            "location": "/", 
            "text": "PainterQB.jl\n\n\nA \nJulia\n package for qubit measurement and analysis.\n\n\nWork in development, not ready for implementation. The documentation may assume some familiarity\nwith Julia.\n\n\nInstallation\n\n\n\n\nInstall \nNational Instruments VISA libraries\n\n (tested with v15.0.1 on Windows 10)\n\n\nInstall \nAlazarTech\n digitizer drivers and shared libraries\n (may need to contact AlazarTech)\n\n\nInstall \nVISA.jl\n\n\nInstall \nAlazar.jl\n\n\nInstall \nPainterQB.jl\n\n\n\n\nQuick start\n\n\nusing PainterQB\nusing PainterQB.AlazarModule\nusing PainterQB.AWG5014CModule  # etc.\n\nawg = AWG5014C(tcpip_socket(\n1.2.3.4\n,5000))\nats = AlazarATS9360()\n\n# do something with awg and ats\n\n\n\n\nTo do\n\n\nGlobally\n\n\n\n\nUnits! A good starting point would be the\n\nSIUnits.jl\n package. It currently does\nnot support fractional units like V/sqrt(Hz) but support could be added.\n\n\nHow to save / load configurations for instruments? Maybe JSON files?\n\n\nHow to save / load data?\n\n\nPlotting ease-of-use features?\n\n\n\n\nAWG5014C\n\n\n\n\nWaveform methods could be made more Julian\n\n\nSequencer support needed\n\n\n\n\nAlazar\n\n\n\n\nSome properties seem to be overwritten when switching between measurement\nmodes. e.g. when measuring a ContinuousStreamResponse the trigger needs to be\nreconfigured before measuring a TriggeredStreamResponse.", 
            "title": "Home"
        }, 
        {
            "location": "/#painterqbjl", 
            "text": "A  Julia  package for qubit measurement and analysis.  Work in development, not ready for implementation. The documentation may assume some familiarity\nwith Julia.", 
            "title": "PainterQB.jl"
        }, 
        {
            "location": "/#installation", 
            "text": "Install  National Instruments VISA libraries \n (tested with v15.0.1 on Windows 10)  Install  AlazarTech  digitizer drivers and shared libraries\n (may need to contact AlazarTech)  Install  VISA.jl  Install  Alazar.jl  Install  PainterQB.jl", 
            "title": "Installation"
        }, 
        {
            "location": "/#quick-start", 
            "text": "using PainterQB\nusing PainterQB.AlazarModule\nusing PainterQB.AWG5014CModule  # etc.\n\nawg = AWG5014C(tcpip_socket( 1.2.3.4 ,5000))\nats = AlazarATS9360()\n\n# do something with awg and ats", 
            "title": "Quick start"
        }, 
        {
            "location": "/#to-do", 
            "text": "Globally   Units! A good starting point would be the SIUnits.jl  package. It currently does\nnot support fractional units like V/sqrt(Hz) but support could be added.  How to save / load configurations for instruments? Maybe JSON files?  How to save / load data?  Plotting ease-of-use features?   AWG5014C   Waveform methods could be made more Julian  Sequencer support needed   Alazar   Some properties seem to be overwritten when switching between measurement\nmodes. e.g. when measuring a ContinuousStreamResponse the trigger needs to be\nreconfigured before measuring a TriggeredStreamResponse.", 
            "title": "To do"
        }, 
        {
            "location": "/design/", 
            "text": "Design overview\n\n\nWhat should good measurement code do?\n\n\nAnyone who has written code in MATLAB or something comparable (IGOR Pro, in the\nauthor's case) has undoubtedly seen spaghetti code. Often there are many copies\nof a measurement routine that differ only slightly, perhaps in the functionality\nof what happens inside some for loop, etc.\n\n\nWe would like to have clear, reusable code to avoid redundancy and accidental\nerrors, both of which consume precious time on the part of the experimenters.\nConsider an archetypal measurement scheme wherein we measure a device's response to\nvarious stimuli (perhaps we measure current as a function of applied bias).\nWe should be able to write just one sweep function to do this:\n\n\n# Just an example; only slightly simplified...\nfunction sweep(stimulus::Stimulus, response::Response, iterator)\n    for values in iterator\n        source(stimulus,value)\n        measure(response)\n    end\nend\n\n\n\n\nThe idea of \nmultiple dispatch\n, natively supported in Julia, permits writing such\nconvenient and abstract code. This is just one example where the advantages of\nmultiple dispatch are obvious. We hope it will more broadly simplify the extension of\nmeasurement code while ensuring continued reliability.\n\n\nHow do we take measurements?\n\n\nSource and measure\n\n\nTwo functions are provided to abstract away many kinds of measurements: \nsource\n\nand \nmeasure\n. In an experiment you source some stimulus and measure a response.\nTherefore \nsource\n takes as an argument an object matching type signature\n\nStimulus\n, which can have different fields for different types of stimuli, as\nwell as some value. \nmeasure\n takes as an argument an object matching type\nsignature \nResponse\n. The idea is to write new subtypes of \nStimulus\n and \nResponse\n\nto describe what you are doing, as well as new methods for \nsource\n and \nmeasure\n.\n\n\nStimuli\n\n\nAll stimuli are objects, subtyped from the abstract \nStimulus\n type.\nMany stimuli, associated with the capabilities of particular instruments,\nare already implemented.\n\n\nNot all stimuli are associated with a physical instrument. For instance, sourcing a\n\nDelayStimulus\n will cause the script to block until a specified time after\ncreation of the \nDelayStimulus\n object.\n\n\nStimuli could also be associated with several instruments. Maybe a stimulus that\nmakes sense for a particular experiment would be to change all gate voltages at once.\nThese gate voltages could of course be sourced by several physical instruments.\n\n\nResponses\n\n\nAll responses are objects, subtyped from the abstract parametric \nResponse{T}\n type.\nWe use a parametric type for responses so that the return type of the numerical data\nis clear. Usually a response is associated with a particular instrument.\n\n\nHowever, responses need not come from instruments. For test purposes, suppose we want to\nmimic a measurement by generating random numbers. \nRandomResponse\n produces a\nrandom number in the unit interval when it is measured. A \nTimerResponse\n will\nmeasure the time since creation of the \nTimerResponse\n object.\n\n\nWhat is an instrument?\n\n\nFor the purposes of this package, an instrument is just something connected to the\ncomputer that we need to communicate with, and which can source or measure something.\nEvery instrument may connect to the computer by different hardware,\ncomms protocols, and command dialects.\n\n\nAll instruments are Julia objects, subtypes of the abstract type \nInstrument\n.\n\n\nInstrument types\n\n\nMany instruments share the same communications protocols. We subtype \nInstrument\n\nbased on these protocols.\n\n\nVISA\n\n\nMany instruments are able to be addressed using the\n\nVISA\n standard (Virtual\nInstrument Software Architecture), currently maintained by the IVI Foundation.\n\nInstrumentVISA\n is an abstract subtype of \nInstrument\n.\n\n\nTo talk to VISA instruments will require the Julia package \nVISA.jl\n\nas well as the \nNational Instruments VISA libraries\n.\nInstallation instructions are available at each link.\n\n\nAlazar digitizers\n\n\nDigitizers made by \nAlazarTech\n are notably \nnot\n\ncompatible with the VISA standard. All Alazar digitizers are addressable by an API\nsupplied by the company, which talks to the card through a shared library (a .dll on\nWindows or .so on Linux). \nInstrumentAlazar\n is an abstract subtype of \nInstrument\n.\n\n\nThe shared library files and API documentation are only available from AlazarTech.\n\n\nHow do we configure instruments?\n\n\nProperties\n\n\nInstrument properties are configured and inspected using two functions,\n\nconfigure\n and \ninspect\n. Why not \nset\n and \nget\n? Ultimately these verbs are\npretty generic and often have implicit meanings in other programming languages.\nIn Objective C, for instance, \nget\n implies that the function will return an address\nin memory rather than a value.\n\n\nBoth \nconfigure\n and \ninspect\n have a lot of methods that take as one of their\narguments an \nInstrumentProperty\n subtype. One subtypes \nInstrumentProperty\n for properties such as \nClockSource\n, the\nlogical states of which have no obvious consistent encoding. One should instead\nsubtype \nNumericalProperty\n for properties where a number suffices to describe\nthe property (up to units).\n\n\nProperties which may be shared by multiple instruments should be defined in\n\nsrc/InstrumentDefs.jl\n. Examples include \nFrequency\n, \nPower\n, \nSampleRate\n, etc.\nThey may be imported in each instrument's module as needed. Properties specific\nto a given instrument may of course be defined in that instrument's module.\n\n\nA design choice was for \nconfigure\n and \ninspect\n to take types rather than\nobjects. Two examples:\n\n\nconfigure(awg, RisingTrigger)    # not RisingTrigger()\nconfigure(awg, SampleRate, 10e6) # not SampleRate() or SampleRate(10e6)\n\n\n\n\nDifference between stimuli and instrument properties\n\n\nBecause a stimulus is defined so broadly, the difference between a stimulus\nand an instrument property is not obvious. A stimulus is like a generalized\ninstrument property: sourcing a stimulus may entail configuring zero or more\ninstrument properties.\n\n\nIt is useful to think of a stimulus to be something that what you are measuring\nhas a chance to react to. For example, this could be applied voltage, sourced by\none or more instruments. The applied voltages would be seen by the device under test,\nwhich would respond accordingly. The stimulus could also just be a time delay,\nprovided by the measurement computer. It could even be the number of threads used\nby Julia for real-time processing.\n\n\nAn instrument property is any persistent setting of an instrument. Tweaking an\ninstrument property could affect the device under test, but it might not.\nAveraging is a good example. With averaging a measurement may look less noisy,\nbut your device under test doesn't know the difference. The trigger engine of a\ndigitizer would also have associated instrument properties.\n\n\nIn many cases there is an overlap between stimuli and properties. Consider that\nthe frequency of a signal generator is an instrument property. In this case\nsourcing a frequency stimulus results in configuring an instrument property.\nRather than make a \nFrequencyStimulus\n type, we provide a \nPropertyStimulus\n type\nwhich can be used more generically. Consider the following example, where we make a\n\nPropertyStimulus\n for sweeping the frequency of our E8257D signal generator:\n\n\nstim = PropertyStimulus(siggen::E8257D, Frequency)\nfor freq in 1e9:1e8:5e9     # 1 GHz to 5 GHz in steps of 100 MHz\n    source(stim, freq)\n    # measure(something)\nend\n\n\n\n\nNote that \nFrequency\n is a subtype of \nNumericalProperty\n, which is required for\nmaking a \nPropertyStimulus\n.\n\n\nAgain, stimuli need not be tied to a particular property. Rather, this is just one\nconvenient and easily generalized example. In more complicated instances it is\nprobably better to make a new \nStimulus\n subtype rather than use \nPropertyStimulus\n.\n\n\nFuture directions\n\n\nFeedback loops\n\n\nIn principle, asynchronous software feedback loops could be implemented\nwith the \nReactive.jl\n package. This\nwould probably only be suitable for slowly varying signals, e.g. PID temperature\ncontrol. Ultimately benchmarking needs to be done to determine how useful\nthis approach would be.", 
            "title": "Design"
        }, 
        {
            "location": "/design/#design-overview", 
            "text": "", 
            "title": "Design overview"
        }, 
        {
            "location": "/design/#what-should-good-measurement-code-do", 
            "text": "Anyone who has written code in MATLAB or something comparable (IGOR Pro, in the\nauthor's case) has undoubtedly seen spaghetti code. Often there are many copies\nof a measurement routine that differ only slightly, perhaps in the functionality\nof what happens inside some for loop, etc.  We would like to have clear, reusable code to avoid redundancy and accidental\nerrors, both of which consume precious time on the part of the experimenters.\nConsider an archetypal measurement scheme wherein we measure a device's response to\nvarious stimuli (perhaps we measure current as a function of applied bias).\nWe should be able to write just one sweep function to do this:  # Just an example; only slightly simplified...\nfunction sweep(stimulus::Stimulus, response::Response, iterator)\n    for values in iterator\n        source(stimulus,value)\n        measure(response)\n    end\nend  The idea of  multiple dispatch , natively supported in Julia, permits writing such\nconvenient and abstract code. This is just one example where the advantages of\nmultiple dispatch are obvious. We hope it will more broadly simplify the extension of\nmeasurement code while ensuring continued reliability.", 
            "title": "What should good measurement code do?"
        }, 
        {
            "location": "/design/#how-do-we-take-measurements", 
            "text": "Source and measure  Two functions are provided to abstract away many kinds of measurements:  source \nand  measure . In an experiment you source some stimulus and measure a response.\nTherefore  source  takes as an argument an object matching type signature Stimulus , which can have different fields for different types of stimuli, as\nwell as some value.  measure  takes as an argument an object matching type\nsignature  Response . The idea is to write new subtypes of  Stimulus  and  Response \nto describe what you are doing, as well as new methods for  source  and  measure .  Stimuli  All stimuli are objects, subtyped from the abstract  Stimulus  type.\nMany stimuli, associated with the capabilities of particular instruments,\nare already implemented.  Not all stimuli are associated with a physical instrument. For instance, sourcing a DelayStimulus  will cause the script to block until a specified time after\ncreation of the  DelayStimulus  object.  Stimuli could also be associated with several instruments. Maybe a stimulus that\nmakes sense for a particular experiment would be to change all gate voltages at once.\nThese gate voltages could of course be sourced by several physical instruments.  Responses  All responses are objects, subtyped from the abstract parametric  Response{T}  type.\nWe use a parametric type for responses so that the return type of the numerical data\nis clear. Usually a response is associated with a particular instrument.  However, responses need not come from instruments. For test purposes, suppose we want to\nmimic a measurement by generating random numbers.  RandomResponse  produces a\nrandom number in the unit interval when it is measured. A  TimerResponse  will\nmeasure the time since creation of the  TimerResponse  object.", 
            "title": "How do we take measurements?"
        }, 
        {
            "location": "/design/#what-is-an-instrument", 
            "text": "For the purposes of this package, an instrument is just something connected to the\ncomputer that we need to communicate with, and which can source or measure something.\nEvery instrument may connect to the computer by different hardware,\ncomms protocols, and command dialects.  All instruments are Julia objects, subtypes of the abstract type  Instrument .  Instrument types  Many instruments share the same communications protocols. We subtype  Instrument \nbased on these protocols.  VISA  Many instruments are able to be addressed using the VISA  standard (Virtual\nInstrument Software Architecture), currently maintained by the IVI Foundation. InstrumentVISA  is an abstract subtype of  Instrument .  To talk to VISA instruments will require the Julia package  VISA.jl \nas well as the  National Instruments VISA libraries .\nInstallation instructions are available at each link.  Alazar digitizers  Digitizers made by  AlazarTech  are notably  not \ncompatible with the VISA standard. All Alazar digitizers are addressable by an API\nsupplied by the company, which talks to the card through a shared library (a .dll on\nWindows or .so on Linux).  InstrumentAlazar  is an abstract subtype of  Instrument .  The shared library files and API documentation are only available from AlazarTech.", 
            "title": "What is an instrument?"
        }, 
        {
            "location": "/design/#how-do-we-configure-instruments", 
            "text": "Properties  Instrument properties are configured and inspected using two functions, configure  and  inspect . Why not  set  and  get ? Ultimately these verbs are\npretty generic and often have implicit meanings in other programming languages.\nIn Objective C, for instance,  get  implies that the function will return an address\nin memory rather than a value.  Both  configure  and  inspect  have a lot of methods that take as one of their\narguments an  InstrumentProperty  subtype. One subtypes  InstrumentProperty  for properties such as  ClockSource , the\nlogical states of which have no obvious consistent encoding. One should instead\nsubtype  NumericalProperty  for properties where a number suffices to describe\nthe property (up to units).  Properties which may be shared by multiple instruments should be defined in src/InstrumentDefs.jl . Examples include  Frequency ,  Power ,  SampleRate , etc.\nThey may be imported in each instrument's module as needed. Properties specific\nto a given instrument may of course be defined in that instrument's module.  A design choice was for  configure  and  inspect  to take types rather than\nobjects. Two examples:  configure(awg, RisingTrigger)    # not RisingTrigger()\nconfigure(awg, SampleRate, 10e6) # not SampleRate() or SampleRate(10e6)  Difference between stimuli and instrument properties  Because a stimulus is defined so broadly, the difference between a stimulus\nand an instrument property is not obvious. A stimulus is like a generalized\ninstrument property: sourcing a stimulus may entail configuring zero or more\ninstrument properties.  It is useful to think of a stimulus to be something that what you are measuring\nhas a chance to react to. For example, this could be applied voltage, sourced by\none or more instruments. The applied voltages would be seen by the device under test,\nwhich would respond accordingly. The stimulus could also just be a time delay,\nprovided by the measurement computer. It could even be the number of threads used\nby Julia for real-time processing.  An instrument property is any persistent setting of an instrument. Tweaking an\ninstrument property could affect the device under test, but it might not.\nAveraging is a good example. With averaging a measurement may look less noisy,\nbut your device under test doesn't know the difference. The trigger engine of a\ndigitizer would also have associated instrument properties.  In many cases there is an overlap between stimuli and properties. Consider that\nthe frequency of a signal generator is an instrument property. In this case\nsourcing a frequency stimulus results in configuring an instrument property.\nRather than make a  FrequencyStimulus  type, we provide a  PropertyStimulus  type\nwhich can be used more generically. Consider the following example, where we make a PropertyStimulus  for sweeping the frequency of our E8257D signal generator:  stim = PropertyStimulus(siggen::E8257D, Frequency)\nfor freq in 1e9:1e8:5e9     # 1 GHz to 5 GHz in steps of 100 MHz\n    source(stim, freq)\n    # measure(something)\nend  Note that  Frequency  is a subtype of  NumericalProperty , which is required for\nmaking a  PropertyStimulus .  Again, stimuli need not be tied to a particular property. Rather, this is just one\nconvenient and easily generalized example. In more complicated instances it is\nprobably better to make a new  Stimulus  subtype rather than use  PropertyStimulus .", 
            "title": "How do we configure instruments?"
        }, 
        {
            "location": "/design/#future-directions", 
            "text": "Feedback loops  In principle, asynchronous software feedback loops could be implemented\nwith the  Reactive.jl  package. This\nwould probably only be suitable for slowly varying signals, e.g. PID temperature\ncontrol. Ultimately benchmarking needs to be done to determine how useful\nthis approach would be.", 
            "title": "Future directions"
        }, 
        {
            "location": "/implementation/", 
            "text": "Implementation overview\n\n\nCode organization\n\n\nOrganizing the code into Julia modules is tricky and the organization may change\nin future releases. It would not be surprising if the way Julia implements modules\nchanges before Julia v1.0.\n\n\n\n\nWith few exceptions, all code is kept inside a single package. For now the\npackage is unregistered and must be retrieved from the repository with\n\nPkg.clone()\n rather than \nPkg.add()\n.\n\n\nLow-level wrappers for shared libraries are kept in their own packages\n(e.g. VISA and Alazar calls). This way, at least some code can be reused if\nsomeone else does not want to use our codebase.\n\n\n\n\n\n\nAll code is kept inside a \"main\" \nPainterQB\n module, defined inside \nsrc/PainterQB.jl\n.\n\n\nCommon instrument definitions and functions are defined in \nsrc/Definitions.jl\n.\n\n\nInstrumentVISA\n and associated functions are defined in \nsrc/VISA.jl\n.\n\n\nCode that should be loaded by Julia workers for parallel processing is\nactually kept outside the module to avoid loading the whole module unnecessarily.\nThese are typically functions that are focused on number crunching and don't\nneed to know much about the internals of PainterQB.\n\n\n\n\n\n\nEach instrument is defined within its own module, a submodule of \nPainterQB\n.\n\n\nEach instrument has a corresponding .jl file in \nsrc/instruments\n.\n\n\nInstrument model numbers are used for type definitions (e.g. \nAWG5014C\n),\nso module names have \"Module\" appended (e.g. \nAWG5014CModule\n). We put all\nAlazar digitizers in \nAlazarModule\n; the feature set and API is so similar\nfor the various models that just one module makes sense.\n\n\nexport\n statements from an instrument submodule are not currently exported\nfrom \nPainterQB\n. The statement \nusing PainterQB.AWG5014CModule\n\nmay be desired when using the AWG, for instance.\n\n\n\n\n\n\nTo test for possible namespace conflicts when adding new instruments,\nuncomment the \nimportall\n statements in \nsrc/PainterQB.jl\n.\n\n\nAs functions from different instrument modules are imported, any functions\nthat are defined in different modules will be printed and warned about. The\nsolution is to define the shared function name in \nsrc/Definitions.jl\n\n(\nglobal\n and \nexport\n) such that the submodules can both import the function.\n\n\n\n\n\n\n\n\nVISA instruments\n\n\nMany commercial instruments support a common communications protocol and command\nsyntax (VISA and SCPI respectively). For such instruments, many methods for\n\nconfigure\n and \ninspect\n can be generated with metaprogramming, rather than\ntyping them out explicitly. The implementation could and should be done\nmore elegantly, but it seems to work for now.\n\n\nThe file \nsrc/Metaprogramming.jl\n is included in each VISA\ninstrument's source file, and therefore in each instrument's own module.\nInitially this file was included directly in the PainterQB module, but it seems\nthere are subtleties regarding the use of the \n@eval\n macro between modules.\n\n\nMetaprogramming\n\n\ngenerate_inspect\n\n\ngenerate_inspect{S\n:Instrument,T\n:InstrumentProperty}(instype::Type{S},\n        command::ASCIIString, proptype::Type{T}, returntype...)\n\n\n\n\nThis command takes an \nInstrument\n subtype \ninstype\n, a VISA command, an\n\nInstrumentProperty\n subtype \nproptype\n, and possibly an argument. It will\ngenerate the following method in the module where \ngenerate_inspect\n is defined:\n\n\ninspect(ins::instype, ::Type{proptype}, infixes::Int...)\n\n\nThe \ninfixes\n variable argument allows for numbers to be inserted within the\ncommands, for instance in \nOUTP#:FILT:FREQ\n, where the \n#\n sign should be\nreplaced by an integer. The replacements are done in the order of the arguments.\nError checking is done on the number of arguments.\n\n\nFor a given property, \ninspect\n will return either an InstrumentProperty subtype,\na number, a boolean, or a string as appropriate.\n\n\ngenerate_configure\n\n\ngenerate_configure{S\n:Instrument,T\n:InstrumentProperty}(instype::Type{S},\n        command::ASCIIString, proptype::Type{T}, returntype...)\n\n\n\n\nThis command takes an \nInstrument\n subtype \nInsType\n, a VISA command, an\n\nInstrumentProperty\n type, and possibly an argument. It will generate one of the\nfollowing methods in the module where \ngenerate_inspect\n is defined:\n\n\nconfigure(ins::InsType, PropertySubtype)\nconfigure(ins::InsType, Property, values..., infixes...)\n\n\n\n\ngenerate_properties\n\n\ngenerate_properties{S\n:InstrumentProperty}(subtype::Symbol, supertype::Type{S})\n\n\n\n\nThis makes it easy to generate new \nInstrumentProperty\n subtypes. Typically\nthis function is called inside a for loop. Calling this function is equivalent\nto writing the following pseudocode:\n\n\nimmutable subtype{T} \n: supertype\nend\n\nexport subtype\n\n\n\n\ngenerate_handlers\n\n\ngenerate_handlers{T\n:Instrument}(insType::Type{T}, responseDict::Dict)\n\n\n\n\nEach instrument can have a \nresponseDict\n. For each setting of the instrument,\nfor instance the \nClockSource\n, we need to know the correspondence between a\nlogical state \nExternalClock\n and how the instrument encodes that logical state\n(e.g. \"EXT\").\nThe \nresponseDict\n is actually a dictionary of dictionaries. The first level keys\nare like \nClockSource\n and the second level keys are like \"EXT\", with the value\nbeing \n:ExternalClock\n. Undoubtedly\nthis nested dictionary is \"nasty\" (in the technical parlance) but the dictionary\nis only used for code\ncreation and is not used at run-time (if the code works as intended).\n\n\nThis function makes a lot of other functions. Given some response from an instrument,\nwe require a function to map that response back on to the appropiate logical state.\n\n\nClockSource(ins::AWG5014C, res::AbstractString)\n\nreturns an \nInternalClock\n or \nExternalClock\n type as appropriate,\nbased on the logical meaning of the response.\n\n\nWe also want a function to generate logical states without having to know the way\nthey are encoded by the instrument.\n\n\ncode(ins::AWG5014C, ::Type{InternalClock})\n returns \"INT\",\nwith \"INT\" encoding how to pass this logical state to the instrument \nins\n.\n\n\nResponses\n\n\nUnlike stimuli, all responses are subtypes of an abstract parametric type,\n\nResponse{T}\n. Although it may seem unduly abstract to have it be both abstract\nand parametric, we use this\nfunctionality to distinguish between desired return types of a measurement.\nSuppose an instrument provides data in some kind of awkward format, like 12-bit\nunsigned integers. For reasons of convenience we may want the measurement to\nreturn the data in a machine-native \nInt64\n format, or we may want to specify\na linear or 2D shape for the data, etc.\n\n\nAn important consideration in writing fast Julia code is to ensure type stability.\nIn other words, the type that is returned from a function should depend only on\nthe method signature and not depend on some value at run-time. By parameterizing\n\nResponse\n types with the return type, we can ensure that \nmeasure\n will be\ntype stable. If we instead had the desired return type as some field\nin a \nResponse\n object, then \nmeasure\n would not be type stable.\n\n\nAlazar digitizers\n\n\nA response type is given for each measurement mode:\ncontinuous streaming (\nContinuousStreamResponse\n), triggered streaming (\n\nTriggeredStreamResponse\n), NPT records (\nNPTRecordResponse\n),\nand FPGA-based FFT calculations (\nFFTHardwareResponse\n).\nTraditional record mode has not been implemented yet for lack of immediate need.\n\n\nLooking at the source code, it would\nseem that there is some redundancy in the types, for instance there is an\n\nNPTRecordMode\n and an \nNPTRecordResponse\n object. The difference is that the\nformer is used internally in the code to denote a particular method of configuring\nthe instrument, allocating buffers, etc., whereas the latter specifies what you\nactually want to do: retrieve NPT records from the digitizer, perhaps doing\nsome post-processing or processing during acquisition along the way. Perhaps\ndifferent responses would dictate different processing behavior, while the\ninstrument is ultimately configured the same way.\n\n\nAlazar instruments\n\n\nIn the following discussion, it is important to understand some Alazar terminology.\nNewer Alazar digitizers use direct memory access (DMA) to stream data into\na computer's RAM. A single \nacquisition\n uses one or many \nbuffers\n, which\nconstitute preallocated regions in the computer's physical memory. Each buffer\ncontains one or many \nrecords\n. Each \nrecord\n contains many \nsamples\n,\nwhich are the voltages measured by the digitizer.\n\n\nIn streaming mode, there is only one record per buffer, but in other modes there\ncan be many records per buffer.\n\n\nBuffer allocation\n\n\nDigitizer requirements\n\n\nThe Alazar digitizers expect buffers in physical memory which are page-aligned.\nThe size of each buffer should also be chosen appropriately.\n\n\nThe behavior of the digitizer is not specified when the buffer is made larger\nthan 64 MB. On our computer, it seems like an \nApiWaitTimeout\n error is thrown\nwhen the buffer is too large (for some unspecified definition of \"large\" greater\nthan 64 MB). The digitizer will then throw \nApiInsufficientResources\n errors\nwhenever another acquisition is attempted, until the computer is restarted.\nJust restarting the Julia kernel, forcing a reload of the Alazar DLLs,\ndoes not appear to be enough to reset the digitizer fully.\n\n\nFor performance reasons, a buffer should not be made much smaller than 1 MB if\nmulitple buffers are required.\nThere is also a minimum record size for each model of digitizer. For the ATS9360,\nif a record has fewer than 256 samples (could be 128 from channel A + 128 from channel B)\nthen the acquisition will proceed, but return garbage data. Allocating too small\nof a buffer is therefore still bad, but less fatal than allocating one that is too large.\n\n\n\n\n\nHow to allocate appropriate buffers in Julia\n\n\nIn Julia, just allocating a fixed-size array will not necessarily return a\npage-aligned block in memory. One approach would be to allocate our own page-aligned\nmemory using \nvalloc\n and \nvfree\n (or their Windows equivalents).\n\n\nfunction virtualalloc{T\n:Union{UInt8,UInt16}}(size_bytes::Integer, ::Type{T})\n    @windows? begin\n        MEM_COMMIT = U32(0x1000)\n        PAGE_READWRITE = U32(0x4)\n        addr = ccall((:VirtualAlloc, \nKernel32\n), Ptr{T},\n                     (Ptr{Void}, Culonglong, Culong, Culong),\n                     C_NULL, size_bytes, MEM_COMMIT, PAGE_READWRITE)\n    end : (@linux? begin\n        addr = ccall((:valloc, libc), Ptr{T}, (Culonglong,), size_bytes)\n    end : throw(SystemError()))\n\n    addr == C_NULL \n throw(OutOfMemoryError())\n\n    addr::Ptr{T}\nend\n\nfunction virtualfree{T\n:Union{UInt16,UInt8}}(addr::Ptr{T})\n    @windows? begin\n        MEM_RELEASE = 0x8000\n        ccall((:VirtualFree, \nKernel32\n), Cint, (Ptr{Void}, Culonglong, Culong),\n            addr, Culonglong(0), MEM_RELEASE)\n    end : (@linux? begin\n        ccall((:free, \nlibc\n), Void, (Ptr{Void},), addr)\n    end : throw(SystemError()))\n    nothing\nend\n\n\n\n\nIn case it wasn't obvious, this was my original approach.\nNote that memory allocated in this way will not be visible to multiple processes\nwithout extra work, and moreover we will need to deallocate the memory ourselves\nat a later time, perhaps using \nfinalizer()\n if the memory is made to be part of\na Julia object.\n\n\nFortunately, there is a special kind of array in Julia called the \nSharedArray\n.\nIt can be viewed and modified from multiple processes, and the memory is page-aligned.\nHopefully this continues to be the case in future Julia releases.\nWe implement a type called the \nDMABufferArray\n whose definition is worth\nrepeating here:\n\n\ntype DMABufferArray{sample_type} \n:\n        AbstractArray{Ptr{sample_type},1}\n\n    bytes_buf::Int\n    n_buf::Int\n    backing::SharedArray{sample_type}\n\n    DMABufferArray(bytes_buf, n_buf) = begin\n        n_buf \n 1 \n bytes_buf % Base.Mmap.PAGESIZE != 0 \n\n            error(\nBytes per buffer must be a multiple of Base.Mmap.PAGESIZE when \n,\n                  \nthere is more than one buffer.\n)\n\n        backing = SharedArray(sample_type,\n                        Int((bytes_buf * n_buf) / sizeof(sample_type)))\n\n        dmabuf = new(bytes_buf,\n                     n_buf,\n                     backing)\n\n        return dmabuf\n    end\n\nend\n\nBase.size(dma::DMABufferArray) = (dma.n_buf,)\nBase.linearindexing(::Type{DMABufferArray}) = Base.LinearFast()\nBase.getindex(dma::DMABufferArray, i::Int) =\n    pointer(dma.backing) + (i-1) * dma.bytes_buf\nBase.length(dma::DMABufferArray) = dma.n_buf\n\nbytespersample{T}(buf_array::DMABufferArray{T}) = sizeof(T)\nsampletype{T}(buf_array::DMABufferArray{T}) = T\n\n\n\n\nSome comments:\n\n\n\n\nA single SharedArray is used to back \nall\n DMA buffers. Memory is therefore\ncontiguous and page-aligned.\n\n\nThe memory for each DMA buffer is required to be a multiple of the page size\nwhen there is more than one buffer.\n\n\nThe memory can be accessed by multiple processes.\n\n\nThe elements of a \nDMABufferArray\n are pointers to the the different\nlocations in memory which act as DMA buffers. The array is iterable and indexable\nas usual.", 
            "title": "Implementation"
        }, 
        {
            "location": "/implementation/#implementation-overview", 
            "text": "", 
            "title": "Implementation overview"
        }, 
        {
            "location": "/implementation/#code-organization", 
            "text": "Organizing the code into Julia modules is tricky and the organization may change\nin future releases. It would not be surprising if the way Julia implements modules\nchanges before Julia v1.0.   With few exceptions, all code is kept inside a single package. For now the\npackage is unregistered and must be retrieved from the repository with Pkg.clone()  rather than  Pkg.add() .  Low-level wrappers for shared libraries are kept in their own packages\n(e.g. VISA and Alazar calls). This way, at least some code can be reused if\nsomeone else does not want to use our codebase.    All code is kept inside a \"main\"  PainterQB  module, defined inside  src/PainterQB.jl .  Common instrument definitions and functions are defined in  src/Definitions.jl .  InstrumentVISA  and associated functions are defined in  src/VISA.jl .  Code that should be loaded by Julia workers for parallel processing is\nactually kept outside the module to avoid loading the whole module unnecessarily.\nThese are typically functions that are focused on number crunching and don't\nneed to know much about the internals of PainterQB.    Each instrument is defined within its own module, a submodule of  PainterQB .  Each instrument has a corresponding .jl file in  src/instruments .  Instrument model numbers are used for type definitions (e.g.  AWG5014C ),\nso module names have \"Module\" appended (e.g.  AWG5014CModule ). We put all\nAlazar digitizers in  AlazarModule ; the feature set and API is so similar\nfor the various models that just one module makes sense.  export  statements from an instrument submodule are not currently exported\nfrom  PainterQB . The statement  using PainterQB.AWG5014CModule \nmay be desired when using the AWG, for instance.    To test for possible namespace conflicts when adding new instruments,\nuncomment the  importall  statements in  src/PainterQB.jl .  As functions from different instrument modules are imported, any functions\nthat are defined in different modules will be printed and warned about. The\nsolution is to define the shared function name in  src/Definitions.jl \n( global  and  export ) such that the submodules can both import the function.", 
            "title": "Code organization"
        }, 
        {
            "location": "/implementation/#visa-instruments", 
            "text": "Many commercial instruments support a common communications protocol and command\nsyntax (VISA and SCPI respectively). For such instruments, many methods for configure  and  inspect  can be generated with metaprogramming, rather than\ntyping them out explicitly. The implementation could and should be done\nmore elegantly, but it seems to work for now.  The file  src/Metaprogramming.jl  is included in each VISA\ninstrument's source file, and therefore in each instrument's own module.\nInitially this file was included directly in the PainterQB module, but it seems\nthere are subtleties regarding the use of the  @eval  macro between modules.  Metaprogramming  generate_inspect  generate_inspect{S :Instrument,T :InstrumentProperty}(instype::Type{S},\n        command::ASCIIString, proptype::Type{T}, returntype...)  This command takes an  Instrument  subtype  instype , a VISA command, an InstrumentProperty  subtype  proptype , and possibly an argument. It will\ngenerate the following method in the module where  generate_inspect  is defined:  inspect(ins::instype, ::Type{proptype}, infixes::Int...)  The  infixes  variable argument allows for numbers to be inserted within the\ncommands, for instance in  OUTP#:FILT:FREQ , where the  #  sign should be\nreplaced by an integer. The replacements are done in the order of the arguments.\nError checking is done on the number of arguments.  For a given property,  inspect  will return either an InstrumentProperty subtype,\na number, a boolean, or a string as appropriate.  generate_configure  generate_configure{S :Instrument,T :InstrumentProperty}(instype::Type{S},\n        command::ASCIIString, proptype::Type{T}, returntype...)  This command takes an  Instrument  subtype  InsType , a VISA command, an InstrumentProperty  type, and possibly an argument. It will generate one of the\nfollowing methods in the module where  generate_inspect  is defined:  configure(ins::InsType, PropertySubtype)\nconfigure(ins::InsType, Property, values..., infixes...)  generate_properties  generate_properties{S :InstrumentProperty}(subtype::Symbol, supertype::Type{S})  This makes it easy to generate new  InstrumentProperty  subtypes. Typically\nthis function is called inside a for loop. Calling this function is equivalent\nto writing the following pseudocode:  immutable subtype{T}  : supertype\nend\n\nexport subtype  generate_handlers  generate_handlers{T :Instrument}(insType::Type{T}, responseDict::Dict)  Each instrument can have a  responseDict . For each setting of the instrument,\nfor instance the  ClockSource , we need to know the correspondence between a\nlogical state  ExternalClock  and how the instrument encodes that logical state\n(e.g. \"EXT\").\nThe  responseDict  is actually a dictionary of dictionaries. The first level keys\nare like  ClockSource  and the second level keys are like \"EXT\", with the value\nbeing  :ExternalClock . Undoubtedly\nthis nested dictionary is \"nasty\" (in the technical parlance) but the dictionary\nis only used for code\ncreation and is not used at run-time (if the code works as intended).  This function makes a lot of other functions. Given some response from an instrument,\nwe require a function to map that response back on to the appropiate logical state.  ClockSource(ins::AWG5014C, res::AbstractString) \nreturns an  InternalClock  or  ExternalClock  type as appropriate,\nbased on the logical meaning of the response.  We also want a function to generate logical states without having to know the way\nthey are encoded by the instrument.  code(ins::AWG5014C, ::Type{InternalClock})  returns \"INT\",\nwith \"INT\" encoding how to pass this logical state to the instrument  ins .", 
            "title": "VISA instruments"
        }, 
        {
            "location": "/implementation/#responses", 
            "text": "Unlike stimuli, all responses are subtypes of an abstract parametric type, Response{T} . Although it may seem unduly abstract to have it be both abstract\nand parametric, we use this\nfunctionality to distinguish between desired return types of a measurement.\nSuppose an instrument provides data in some kind of awkward format, like 12-bit\nunsigned integers. For reasons of convenience we may want the measurement to\nreturn the data in a machine-native  Int64  format, or we may want to specify\na linear or 2D shape for the data, etc.  An important consideration in writing fast Julia code is to ensure type stability.\nIn other words, the type that is returned from a function should depend only on\nthe method signature and not depend on some value at run-time. By parameterizing Response  types with the return type, we can ensure that  measure  will be\ntype stable. If we instead had the desired return type as some field\nin a  Response  object, then  measure  would not be type stable.  Alazar digitizers  A response type is given for each measurement mode:\ncontinuous streaming ( ContinuousStreamResponse ), triggered streaming ( TriggeredStreamResponse ), NPT records ( NPTRecordResponse ),\nand FPGA-based FFT calculations ( FFTHardwareResponse ).\nTraditional record mode has not been implemented yet for lack of immediate need.  Looking at the source code, it would\nseem that there is some redundancy in the types, for instance there is an NPTRecordMode  and an  NPTRecordResponse  object. The difference is that the\nformer is used internally in the code to denote a particular method of configuring\nthe instrument, allocating buffers, etc., whereas the latter specifies what you\nactually want to do: retrieve NPT records from the digitizer, perhaps doing\nsome post-processing or processing during acquisition along the way. Perhaps\ndifferent responses would dictate different processing behavior, while the\ninstrument is ultimately configured the same way.", 
            "title": "Responses"
        }, 
        {
            "location": "/implementation/#alazar-instruments", 
            "text": "In the following discussion, it is important to understand some Alazar terminology.\nNewer Alazar digitizers use direct memory access (DMA) to stream data into\na computer's RAM. A single  acquisition  uses one or many  buffers , which\nconstitute preallocated regions in the computer's physical memory. Each buffer\ncontains one or many  records . Each  record  contains many  samples ,\nwhich are the voltages measured by the digitizer.  In streaming mode, there is only one record per buffer, but in other modes there\ncan be many records per buffer.  Buffer allocation  Digitizer requirements  The Alazar digitizers expect buffers in physical memory which are page-aligned.\nThe size of each buffer should also be chosen appropriately.  The behavior of the digitizer is not specified when the buffer is made larger\nthan 64 MB. On our computer, it seems like an  ApiWaitTimeout  error is thrown\nwhen the buffer is too large (for some unspecified definition of \"large\" greater\nthan 64 MB). The digitizer will then throw  ApiInsufficientResources  errors\nwhenever another acquisition is attempted, until the computer is restarted.\nJust restarting the Julia kernel, forcing a reload of the Alazar DLLs,\ndoes not appear to be enough to reset the digitizer fully.  For performance reasons, a buffer should not be made much smaller than 1 MB if\nmulitple buffers are required.\nThere is also a minimum record size for each model of digitizer. For the ATS9360,\nif a record has fewer than 256 samples (could be 128 from channel A + 128 from channel B)\nthen the acquisition will proceed, but return garbage data. Allocating too small\nof a buffer is therefore still bad, but less fatal than allocating one that is too large.   How to allocate appropriate buffers in Julia  In Julia, just allocating a fixed-size array will not necessarily return a\npage-aligned block in memory. One approach would be to allocate our own page-aligned\nmemory using  valloc  and  vfree  (or their Windows equivalents).  function virtualalloc{T :Union{UInt8,UInt16}}(size_bytes::Integer, ::Type{T})\n    @windows? begin\n        MEM_COMMIT = U32(0x1000)\n        PAGE_READWRITE = U32(0x4)\n        addr = ccall((:VirtualAlloc,  Kernel32 ), Ptr{T},\n                     (Ptr{Void}, Culonglong, Culong, Culong),\n                     C_NULL, size_bytes, MEM_COMMIT, PAGE_READWRITE)\n    end : (@linux? begin\n        addr = ccall((:valloc, libc), Ptr{T}, (Culonglong,), size_bytes)\n    end : throw(SystemError()))\n\n    addr == C_NULL   throw(OutOfMemoryError())\n\n    addr::Ptr{T}\nend\n\nfunction virtualfree{T :Union{UInt16,UInt8}}(addr::Ptr{T})\n    @windows? begin\n        MEM_RELEASE = 0x8000\n        ccall((:VirtualFree,  Kernel32 ), Cint, (Ptr{Void}, Culonglong, Culong),\n            addr, Culonglong(0), MEM_RELEASE)\n    end : (@linux? begin\n        ccall((:free,  libc ), Void, (Ptr{Void},), addr)\n    end : throw(SystemError()))\n    nothing\nend  In case it wasn't obvious, this was my original approach.\nNote that memory allocated in this way will not be visible to multiple processes\nwithout extra work, and moreover we will need to deallocate the memory ourselves\nat a later time, perhaps using  finalizer()  if the memory is made to be part of\na Julia object.  Fortunately, there is a special kind of array in Julia called the  SharedArray .\nIt can be viewed and modified from multiple processes, and the memory is page-aligned.\nHopefully this continues to be the case in future Julia releases.\nWe implement a type called the  DMABufferArray  whose definition is worth\nrepeating here:  type DMABufferArray{sample_type}  :\n        AbstractArray{Ptr{sample_type},1}\n\n    bytes_buf::Int\n    n_buf::Int\n    backing::SharedArray{sample_type}\n\n    DMABufferArray(bytes_buf, n_buf) = begin\n        n_buf   1   bytes_buf % Base.Mmap.PAGESIZE != 0  \n            error( Bytes per buffer must be a multiple of Base.Mmap.PAGESIZE when  ,\n                   there is more than one buffer. )\n\n        backing = SharedArray(sample_type,\n                        Int((bytes_buf * n_buf) / sizeof(sample_type)))\n\n        dmabuf = new(bytes_buf,\n                     n_buf,\n                     backing)\n\n        return dmabuf\n    end\n\nend\n\nBase.size(dma::DMABufferArray) = (dma.n_buf,)\nBase.linearindexing(::Type{DMABufferArray}) = Base.LinearFast()\nBase.getindex(dma::DMABufferArray, i::Int) =\n    pointer(dma.backing) + (i-1) * dma.bytes_buf\nBase.length(dma::DMABufferArray) = dma.n_buf\n\nbytespersample{T}(buf_array::DMABufferArray{T}) = sizeof(T)\nsampletype{T}(buf_array::DMABufferArray{T}) = T  Some comments:   A single SharedArray is used to back  all  DMA buffers. Memory is therefore\ncontiguous and page-aligned.  The memory for each DMA buffer is required to be a multiple of the page size\nwhen there is more than one buffer.  The memory can be accessed by multiple processes.  The elements of a  DMABufferArray  are pointers to the the different\nlocations in memory which act as DMA buffers. The array is iterable and indexable\nas usual.", 
            "title": "Alazar instruments"
        }, 
        {
            "location": "/api/api/", 
            "text": "API-INDEX\n\n\nMODULE: PainterQB\n\n\n\n\nMethods [Exported]\n\n\nask(ins::PainterQB.InstrumentVISA,  msg::ASCIIString)\n  Idiomatic \"write and read available\" function with optional delay.\n\n\nask(ins::PainterQB.InstrumentVISA,  msg::ASCIIString,  delay::Real)\n  Idiomatic \"write and read available\" function with optional delay.\n\n\nbinblockreadavailable(ins::PainterQB.InstrumentVISA)\n  Read an entire block of bytes with properly formatted IEEE header.\n\n\nbinblockwrite(ins::PainterQB.InstrumentVISA,  message::Union{ASCIIString, Array{UInt8, 1}},  data::Array{UInt8, 1})\n  Write an IEEE header block followed by an arbitary sequency of bytes and the terminator.\n\n\nfindresources()\n  Finds VISA resources to which we can connect. Doesn't find ethernet instruments.\n\n\nfindresources(expr::AbstractString)\n  Finds VISA resources to which we can connect. Doesn't find ethernet instruments.\n\n\ngpib(primary)\n  Returns a viSession for the given GPIB address.\n\n\nread(ins::PainterQB.InstrumentVISA)\n  Read from an instrument. Strips trailing carriage returns and new lines.\n\n\nreadavailable(ins::PainterQB.InstrumentVISA)\n  Keep reading from an instrument until the instrument says we are done.\n\n\ntcpip_instr(ip)\n  Returns a INSTR viSession for the given IPv4 address.\n\n\ntcpip_socket(ip,  port)\n  Returns a raw socket viSession for the given IPv4 address.\n\n\nwrite(ins::PainterQB.InstrumentVISA,  msg::ASCIIString)\n  Write to an instrument. Appends the instrument's write terminator.\n\n\n\n\nTypes [Exported]\n\n\nPainterQB.All\n  The All type is meant to be dispatched upon and not instantiated.\n\n\nPainterQB.DelayStimulus\n  \nDelayStimulus\n\n\nPainterQB.InstrumentProperty\n  ### InstrumentProperty\n\n\nPainterQB.InstrumentVISA\n  ### InstrumentVISA\n\n\nPainterQB.TimeAResponse\n  \nTimeAResponse\n\n\nPainterQB.TimerResponse{T\n:AbstractFloat}\n  \nTimerResponse\n\n\n\n\nMethods [Internal]\n\n\ngenerate_configure{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty})\n  ```\n\n\ngenerate_handlers{T\n:PainterQB.Instrument}(insType::Type{T\n:PainterQB.Instrument},  responseDict::Dict{K, V})\n  ### generate_handlers\n\n\ngenerate_inspect{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty},  ::Type{PainterQB.NoArgs})\n  ```\n\n\ngenerate_properties{S\n:PainterQB.InstrumentProperty}(subtype::Symbol,  supertype::Type{S\n:PainterQB.InstrumentProperty})\n  Makes parametric subtypes and gives constructors. Also defines a code method.\n\n\nMODULE: PainterQB.E5071CModule\n\n\n\n\nMethods [Internal]\n\n\ngenerate_configure{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty})\n  ```\n\n\ngenerate_handlers{T\n:PainterQB.Instrument}(insType::Type{T\n:PainterQB.Instrument},  responseDict::Dict{K, V})\n  ### generate_handlers\n\n\ngenerate_inspect{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty},  ::Type{PainterQB.NoArgs})\n  ```\n\n\ngenerate_properties{S\n:PainterQB.InstrumentProperty}(subtype::Symbol,  supertype::Type{S\n:PainterQB.InstrumentProperty})\n  Makes parametric subtypes and gives constructors. Also defines a code method.\n\n\nMODULE: PainterQB.E8257DModule\n\n\n\n\nMethods [Internal]\n\n\ngenerate_configure{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty})\n  ```\n\n\ngenerate_handlers{T\n:PainterQB.Instrument}(insType::Type{T\n:PainterQB.Instrument},  responseDict::Dict{K, V})\n  ### generate_handlers\n\n\ngenerate_inspect{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty},  ::Type{PainterQB.NoArgs})\n  ```\n\n\ngenerate_properties{S\n:PainterQB.InstrumentProperty}(subtype::Symbol,  supertype::Type{S\n:PainterQB.InstrumentProperty})\n  Makes parametric subtypes and gives constructors. Also defines a code method.\n\n\nMODULE: PainterQB.AWG5014CModule\n\n\n\n\nMethods [Exported]\n\n\npullfrom_awg(ins::PainterQB.AWG5014CModule.AWG5014C,  name::ASCIIString)\n  Pull data from the AWG, performing checks and generating errors as appropriate.\n\n\npushto_awg{T\n:PainterQB.AWG5014CModule.WaveformType}(ins::PainterQB.AWG5014CModule.AWG5014C,  name::ASCIIString,  awgData::PainterQB.AWG5014CModule.AWG5014CData,  wvType::Type{T\n:PainterQB.AWG5014CModule.WaveformType})\n  Push data to the AWG, performing checks and generating errors as appropriate.\n\n\npushto_awg{T\n:PainterQB.AWG5014CModule.WaveformType}(ins::PainterQB.AWG5014CModule.AWG5014C,  name::ASCIIString,  awgData::PainterQB.AWG5014CModule.AWG5014CData,  wvType::Type{T\n:PainterQB.AWG5014CModule.WaveformType},  resampleOk::Bool)\n  Push data to the AWG, performing checks and generating errors as appropriate.\n\n\nrunapplication(ins::PainterQB.AWG5014CModule.AWG5014C,  app::ASCIIString)\n  Run an application, e.g. SerialXpress\n\n\nvalidate(awgData::PainterQB.AWG5014CModule.AWG5014CData,  wvType::Type{PainterQB.AWG5014CModule.WaveformType})\n  Validates data to be pushed to the AWG to check for internal consistency and appropriate range.\n\n\nwaveformname(ins::PainterQB.AWG5014CModule.AWG5014C,  num::Integer)\n  Uses Julia style indexing (begins at 1) to retrieve the name of a waveform.\n\n\nwaveformtype(ins::PainterQB.AWG5014CModule.AWG5014C,  name::ASCIIString)\n  Returns the type of the waveform. The AWG hardware ultimately uses an \nIntWaveform\n but \nRealWaveform\n is more convenient.\n\n\n\n\nMacros [Exported]\n\n\n@allch(x::Expr)\n  Macro for performing an operation on every channel,\n\n\n\n\nMethods [Internal]\n\n\nconfigure(ins::PainterQB.AWG5014CModule.AWG5014C,  ::Type{PainterQB.Phase},  phase::Real,  ch::Integer)\n  Set the output phase in degrees for a given channel.\n\n\nconfigure(ins::PainterQB.AWG5014CModule.AWG5014C,  ::Type{PainterQB.SampleRate},  rate::Real)\n  Set the sample rate in Hz between 10 MHz and 10 GHz. Output rate = sample rate / number of points.\n\n\ngenerate_configure{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty})\n  ```\n\n\ngenerate_handlers{T\n:PainterQB.Instrument}(insType::Type{T\n:PainterQB.Instrument},  responseDict::Dict{K, V})\n  ### generate_handlers\n\n\ngenerate_inspect{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty},  ::Type{PainterQB.NoArgs})\n  ```\n\n\ngenerate_properties{S\n:PainterQB.InstrumentProperty}(subtype::Symbol,  supertype::Type{S\n:PainterQB.InstrumentProperty})\n  Makes parametric subtypes and gives constructors. Also defines a code method.\n\n\ninspect(ins::PainterQB.AWG5014CModule.AWG5014C,  ::Type{PainterQB.AWG5014CModule.SequencerType})\n  Current sequencer type\n\n\ninspect(ins::PainterQB.AWG5014CModule.AWG5014C,  ::Type{PainterQB.Phase},  ch::Integer)\n  Get the output phase in degrees for a given channel.\n\n\ninspect(ins::PainterQB.AWG5014CModule.AWG5014C,  ::Type{PainterQB.SampleRate})\n  Get the sample rate in Hz. Output rate = sample rate / number of points.\n\n\npulllowlevel{T\n:PainterQB.AWG5014CModule.RealWaveform}(ins::PainterQB.AWG5014CModule.AWG5014C,  name::ASCIIString,  ::Type{T\n:PainterQB.AWG5014CModule.RealWaveform})\n  Takes care of the dirty work in pulling data from the AWG.\n\n\npushlowlevel{T\n:PainterQB.AWG5014CModule.RealWaveform}(ins::PainterQB.AWG5014CModule.AWG5014C,  name::ASCIIString,  awgData::PainterQB.AWG5014CModule.AWG5014CData,  wvType::Type{T\n:PainterQB.AWG5014CModule.RealWaveform})\n  Takes care of the dirty work in pushing the data to the AWG.\n\n\nMODULE: PainterQB.AlazarModule\n\n\n\n\nTypes [Exported]\n\n\nPainterQB.AlazarModule.AlazarATS9360\n  ATS9360 is a concrete subtype of InstrumentAlazar.\n\n\nPainterQB.AlazarModule.InstrumentAlazar\n  The InstrumentAlazar types represent an AlazarTech device on the local\n\n\n\n\nMethods [Internal]\n\n\ncall(::Type{PainterQB.InstrumentException},  ins::PainterQB.AlazarModule.InstrumentAlazar,  r)\n  Create descriptive exceptions.\n\n\ngenerate_configure{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty})\n  ```\n\n\ngenerate_handlers{T\n:PainterQB.Instrument}(insType::Type{T\n:PainterQB.Instrument},  responseDict::Dict{K, V})\n  ### generate_handlers\n\n\ngenerate_inspect{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty},  ::Type{PainterQB.NoArgs})\n  ```\n\n\ngenerate_properties{S\n:PainterQB.InstrumentProperty}(subtype::Symbol,  supertype::Type{S\n:PainterQB.InstrumentProperty})\n  Makes parametric subtypes and gives constructors. Also defines a code method.\n\n\n\n\nMacros [Internal]\n\n\n@eh2(expr)\n  Takes an Alazar API call and brackets it with some checking.", 
            "title": "Index"
        }, 
        {
            "location": "/api/api/#api-index", 
            "text": "", 
            "title": "API-INDEX"
        }, 
        {
            "location": "/api/api/#module-painterqb", 
            "text": "", 
            "title": "MODULE: PainterQB"
        }, 
        {
            "location": "/api/api/#methods-exported", 
            "text": "ask(ins::PainterQB.InstrumentVISA,  msg::ASCIIString)   Idiomatic \"write and read available\" function with optional delay.  ask(ins::PainterQB.InstrumentVISA,  msg::ASCIIString,  delay::Real)   Idiomatic \"write and read available\" function with optional delay.  binblockreadavailable(ins::PainterQB.InstrumentVISA)   Read an entire block of bytes with properly formatted IEEE header.  binblockwrite(ins::PainterQB.InstrumentVISA,  message::Union{ASCIIString, Array{UInt8, 1}},  data::Array{UInt8, 1})   Write an IEEE header block followed by an arbitary sequency of bytes and the terminator.  findresources()   Finds VISA resources to which we can connect. Doesn't find ethernet instruments.  findresources(expr::AbstractString)   Finds VISA resources to which we can connect. Doesn't find ethernet instruments.  gpib(primary)   Returns a viSession for the given GPIB address.  read(ins::PainterQB.InstrumentVISA)   Read from an instrument. Strips trailing carriage returns and new lines.  readavailable(ins::PainterQB.InstrumentVISA)   Keep reading from an instrument until the instrument says we are done.  tcpip_instr(ip)   Returns a INSTR viSession for the given IPv4 address.  tcpip_socket(ip,  port)   Returns a raw socket viSession for the given IPv4 address.  write(ins::PainterQB.InstrumentVISA,  msg::ASCIIString)   Write to an instrument. Appends the instrument's write terminator.", 
            "title": "Methods [Exported]"
        }, 
        {
            "location": "/api/api/#types-exported", 
            "text": "PainterQB.All   The All type is meant to be dispatched upon and not instantiated.  PainterQB.DelayStimulus    DelayStimulus  PainterQB.InstrumentProperty   ### InstrumentProperty  PainterQB.InstrumentVISA   ### InstrumentVISA  PainterQB.TimeAResponse    TimeAResponse  PainterQB.TimerResponse{T :AbstractFloat}    TimerResponse", 
            "title": "Types [Exported]"
        }, 
        {
            "location": "/api/api/#methods-internal", 
            "text": "generate_configure{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty})   ```  generate_handlers{T :PainterQB.Instrument}(insType::Type{T :PainterQB.Instrument},  responseDict::Dict{K, V})   ### generate_handlers  generate_inspect{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty},  ::Type{PainterQB.NoArgs})   ```  generate_properties{S :PainterQB.InstrumentProperty}(subtype::Symbol,  supertype::Type{S :PainterQB.InstrumentProperty})   Makes parametric subtypes and gives constructors. Also defines a code method.", 
            "title": "Methods [Internal]"
        }, 
        {
            "location": "/api/api/#module-painterqbe5071cmodule", 
            "text": "", 
            "title": "MODULE: PainterQB.E5071CModule"
        }, 
        {
            "location": "/api/api/#methods-internal_1", 
            "text": "generate_configure{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty})   ```  generate_handlers{T :PainterQB.Instrument}(insType::Type{T :PainterQB.Instrument},  responseDict::Dict{K, V})   ### generate_handlers  generate_inspect{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty},  ::Type{PainterQB.NoArgs})   ```  generate_properties{S :PainterQB.InstrumentProperty}(subtype::Symbol,  supertype::Type{S :PainterQB.InstrumentProperty})   Makes parametric subtypes and gives constructors. Also defines a code method.", 
            "title": "Methods [Internal]"
        }, 
        {
            "location": "/api/api/#module-painterqbe8257dmodule", 
            "text": "", 
            "title": "MODULE: PainterQB.E8257DModule"
        }, 
        {
            "location": "/api/api/#methods-internal_2", 
            "text": "generate_configure{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty})   ```  generate_handlers{T :PainterQB.Instrument}(insType::Type{T :PainterQB.Instrument},  responseDict::Dict{K, V})   ### generate_handlers  generate_inspect{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty},  ::Type{PainterQB.NoArgs})   ```  generate_properties{S :PainterQB.InstrumentProperty}(subtype::Symbol,  supertype::Type{S :PainterQB.InstrumentProperty})   Makes parametric subtypes and gives constructors. Also defines a code method.", 
            "title": "Methods [Internal]"
        }, 
        {
            "location": "/api/api/#module-painterqbawg5014cmodule", 
            "text": "", 
            "title": "MODULE: PainterQB.AWG5014CModule"
        }, 
        {
            "location": "/api/api/#methods-exported_1", 
            "text": "pullfrom_awg(ins::PainterQB.AWG5014CModule.AWG5014C,  name::ASCIIString)   Pull data from the AWG, performing checks and generating errors as appropriate.  pushto_awg{T :PainterQB.AWG5014CModule.WaveformType}(ins::PainterQB.AWG5014CModule.AWG5014C,  name::ASCIIString,  awgData::PainterQB.AWG5014CModule.AWG5014CData,  wvType::Type{T :PainterQB.AWG5014CModule.WaveformType})   Push data to the AWG, performing checks and generating errors as appropriate.  pushto_awg{T :PainterQB.AWG5014CModule.WaveformType}(ins::PainterQB.AWG5014CModule.AWG5014C,  name::ASCIIString,  awgData::PainterQB.AWG5014CModule.AWG5014CData,  wvType::Type{T :PainterQB.AWG5014CModule.WaveformType},  resampleOk::Bool)   Push data to the AWG, performing checks and generating errors as appropriate.  runapplication(ins::PainterQB.AWG5014CModule.AWG5014C,  app::ASCIIString)   Run an application, e.g. SerialXpress  validate(awgData::PainterQB.AWG5014CModule.AWG5014CData,  wvType::Type{PainterQB.AWG5014CModule.WaveformType})   Validates data to be pushed to the AWG to check for internal consistency and appropriate range.  waveformname(ins::PainterQB.AWG5014CModule.AWG5014C,  num::Integer)   Uses Julia style indexing (begins at 1) to retrieve the name of a waveform.  waveformtype(ins::PainterQB.AWG5014CModule.AWG5014C,  name::ASCIIString)   Returns the type of the waveform. The AWG hardware ultimately uses an  IntWaveform  but  RealWaveform  is more convenient.", 
            "title": "Methods [Exported]"
        }, 
        {
            "location": "/api/api/#macros-exported", 
            "text": "@allch(x::Expr)   Macro for performing an operation on every channel,", 
            "title": "Macros [Exported]"
        }, 
        {
            "location": "/api/api/#methods-internal_3", 
            "text": "configure(ins::PainterQB.AWG5014CModule.AWG5014C,  ::Type{PainterQB.Phase},  phase::Real,  ch::Integer)   Set the output phase in degrees for a given channel.  configure(ins::PainterQB.AWG5014CModule.AWG5014C,  ::Type{PainterQB.SampleRate},  rate::Real)   Set the sample rate in Hz between 10 MHz and 10 GHz. Output rate = sample rate / number of points.  generate_configure{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty})   ```  generate_handlers{T :PainterQB.Instrument}(insType::Type{T :PainterQB.Instrument},  responseDict::Dict{K, V})   ### generate_handlers  generate_inspect{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty},  ::Type{PainterQB.NoArgs})   ```  generate_properties{S :PainterQB.InstrumentProperty}(subtype::Symbol,  supertype::Type{S :PainterQB.InstrumentProperty})   Makes parametric subtypes and gives constructors. Also defines a code method.  inspect(ins::PainterQB.AWG5014CModule.AWG5014C,  ::Type{PainterQB.AWG5014CModule.SequencerType})   Current sequencer type  inspect(ins::PainterQB.AWG5014CModule.AWG5014C,  ::Type{PainterQB.Phase},  ch::Integer)   Get the output phase in degrees for a given channel.  inspect(ins::PainterQB.AWG5014CModule.AWG5014C,  ::Type{PainterQB.SampleRate})   Get the sample rate in Hz. Output rate = sample rate / number of points.  pulllowlevel{T :PainterQB.AWG5014CModule.RealWaveform}(ins::PainterQB.AWG5014CModule.AWG5014C,  name::ASCIIString,  ::Type{T :PainterQB.AWG5014CModule.RealWaveform})   Takes care of the dirty work in pulling data from the AWG.  pushlowlevel{T :PainterQB.AWG5014CModule.RealWaveform}(ins::PainterQB.AWG5014CModule.AWG5014C,  name::ASCIIString,  awgData::PainterQB.AWG5014CModule.AWG5014CData,  wvType::Type{T :PainterQB.AWG5014CModule.RealWaveform})   Takes care of the dirty work in pushing the data to the AWG.", 
            "title": "Methods [Internal]"
        }, 
        {
            "location": "/api/api/#module-painterqbalazarmodule", 
            "text": "", 
            "title": "MODULE: PainterQB.AlazarModule"
        }, 
        {
            "location": "/api/api/#types-exported_1", 
            "text": "PainterQB.AlazarModule.AlazarATS9360   ATS9360 is a concrete subtype of InstrumentAlazar.  PainterQB.AlazarModule.InstrumentAlazar   The InstrumentAlazar types represent an AlazarTech device on the local", 
            "title": "Types [Exported]"
        }, 
        {
            "location": "/api/api/#methods-internal_4", 
            "text": "call(::Type{PainterQB.InstrumentException},  ins::PainterQB.AlazarModule.InstrumentAlazar,  r)   Create descriptive exceptions.  generate_configure{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty})   ```  generate_handlers{T :PainterQB.Instrument}(insType::Type{T :PainterQB.Instrument},  responseDict::Dict{K, V})   ### generate_handlers  generate_inspect{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty},  ::Type{PainterQB.NoArgs})   ```  generate_properties{S :PainterQB.InstrumentProperty}(subtype::Symbol,  supertype::Type{S :PainterQB.InstrumentProperty})   Makes parametric subtypes and gives constructors. Also defines a code method.", 
            "title": "Methods [Internal]"
        }, 
        {
            "location": "/api/api/#macros-internal", 
            "text": "@eh2(expr)   Takes an Alazar API call and brackets it with some checking.", 
            "title": "Macros [Internal]"
        }, 
        {
            "location": "/api/PainterQB/", 
            "text": "PainterQB\n\n\nMethods [Exported]\n\n\n\n\n\n\nask(ins::PainterQB.InstrumentVISA,  msg::ASCIIString) \n\u00b6\n\n\nIdiomatic \"write and read available\" function with optional delay.\n\n\nsource:\n\n\nPainterQB\\src\\VISA.jl:63\n\n\n\n\n\n\nask(ins::PainterQB.InstrumentVISA,  msg::ASCIIString,  delay::Real) \n\u00b6\n\n\nIdiomatic \"write and read available\" function with optional delay.\n\n\nsource:\n\n\nPainterQB\\src\\VISA.jl:63\n\n\n\n\n\n\nbinblockreadavailable(ins::PainterQB.InstrumentVISA) \n\u00b6\n\n\nRead an entire block of bytes with properly formatted IEEE header.\n\n\nsource:\n\n\nPainterQB\\src\\VISA.jl:92\n\n\n\n\n\n\nbinblockwrite(ins::PainterQB.InstrumentVISA,  message::Union{ASCIIString, Array{UInt8, 1}},  data::Array{UInt8, 1}) \n\u00b6\n\n\nWrite an IEEE header block followed by an arbitary sequency of bytes and the terminator.\n\n\nsource:\n\n\nPainterQB\\src\\VISA.jl:87\n\n\n\n\n\n\nfindresources() \n\u00b6\n\n\nFinds VISA resources to which we can connect. Doesn't find ethernet instruments.\n\n\nsource:\n\n\nPainterQB\\src\\VISA.jl:42\n\n\n\n\n\n\nfindresources(expr::AbstractString) \n\u00b6\n\n\nFinds VISA resources to which we can connect. Doesn't find ethernet instruments.\n\n\nsource:\n\n\nPainterQB\\src\\VISA.jl:42\n\n\n\n\n\n\ngpib(primary) \n\u00b6\n\n\nReturns a viSession for the given GPIB address.\n\n\nsource:\n\n\nPainterQB\\src\\VISA.jl:45\n\n\n\n\n\n\nread(ins::PainterQB.InstrumentVISA) \n\u00b6\n\n\nRead from an instrument. Strips trailing carriage returns and new lines.\nNote that this function will only read so many characters (buffered).\n\n\nsource:\n\n\nPainterQB\\src\\VISA.jl:73\n\n\n\n\n\n\nreadavailable(ins::PainterQB.InstrumentVISA) \n\u00b6\n\n\nKeep reading from an instrument until the instrument says we are done.\n\n\nsource:\n\n\nPainterQB\\src\\VISA.jl:81\n\n\n\n\n\n\ntcpip_instr(ip) \n\u00b6\n\n\nReturns a INSTR viSession for the given IPv4 address.\n\n\nsource:\n\n\nPainterQB\\src\\VISA.jl:54\n\n\n\n\n\n\ntcpip_socket(ip,  port) \n\u00b6\n\n\nReturns a raw socket viSession for the given IPv4 address.\n\n\nsource:\n\n\nPainterQB\\src\\VISA.jl:57\n\n\n\n\n\n\nwrite(ins::PainterQB.InstrumentVISA,  msg::ASCIIString) \n\u00b6\n\n\nWrite to an instrument. Appends the instrument's write terminator.\n\n\nsource:\n\n\nPainterQB\\src\\VISA.jl:77\n\n\nTypes [Exported]\n\n\n\n\n\n\nPainterQB.All \n\u00b6\n\n\nThe All type is meant to be dispatched upon and not instantiated.\n\n\nsource:\n\n\nPainterQB\\src\\Definitions.jl:229\n\n\n\n\n\n\nPainterQB.DelayStimulus \n\u00b6\n\n\nDelayStimulus\n\n\nWhen sourced with a value in seconds, will wait until that many\nseconds have elapsed since the DelayStimulus was initialized.\n\n\nsource:\n\n\nPainterQB\\src\\sourcemeasure\\Time.jl:9\n\n\n\n\n\n\nPainterQB.InstrumentProperty \n\u00b6\n\n\nInstrumentProperty\n\n\nabstract InstrumentProperty \n: Any\n\n\nAbstract supertype representing communications with an instrument.\n\n\nEach \nabstract\n subtype one level down should represent a logical state of the\ninstrument configuration, e.g. \nTriggerSource\n may be have concrete\nsubtypes \nExternalTrigger\n or \nInternalTrigger\n.\n\n\nEach \nconcrete\n subtype two levels down is an immutable type:\n\nInternalTrigger(ins::AWG5014C, \"INT\")\n encodes everything one needs to know\nfor how the AWG5014C represents an internal trigger.\n\n\nTo retrieve what one has to send the AWG from the type signature, we have\ndefined a function \ncode\n.\n\n\nsource:\n\n\nPainterQB\\src\\Definitions.jl:62\n\n\n\n\n\n\nPainterQB.InstrumentVISA \n\u00b6\n\n\nInstrumentVISA\n\n\nabstract InstrumentVISA \n: Instrument\n\n\nAbstract supertype of all Instruments addressable using a VISA library.\nConcrete types are expected to have fields:\n\n\nvi::ViSession\n\n\nwriteTerminator::ASCIIString\n\n\nsource:\n\n\nPainterQB\\src\\VISA.jl:37\n\n\n\n\n\n\nPainterQB.TimeAResponse \n\u00b6\n\n\nTimeAResponse\n\n\nWhen measured, will return how many seconds it takes to measure\nthe response field it holds. So meta.\n\n\nsource:\n\n\nPainterQB\\src\\sourcemeasure\\Time.jl:42\n\n\n\n\n\n\nPainterQB.TimerResponse{T\n:AbstractFloat} \n\u00b6\n\n\nTimerResponse\n\n\nWhen measured, will return how many seconds have elapsed since\nthe timer was initialized.\n\n\nsource:\n\n\nPainterQB\\src\\sourcemeasure\\Time.jl:30\n\n\nMethods [Internal]\n\n\n\n\n\n\ngenerate_configure{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty}) \n\u00b6\n\n\ngenerate_configure{S\n:Instrument,T\n:InstrumentProperty}(instype::Type{S},\n        command::ASCIIString, proptype::Type{T}, returntype...)\n\n\n\n\nThis command takes an \nInstrument\n subtype \nInsType\n, a VISA command, an\n\nInstrumentProperty\n type, and possibly an argument. It will generate one of the\nfollowing methods in the module where \ngenerate_inspect\n is defined:\n\n\nconfigure(ins::InsType, PropertySubtype)\nconfigure(ins::InsType, Property, values..., infixes...)\n\n\n\n\nsource:\n\n\nPainterQB\\src\\Metaprogramming.jl:93\n\n\n\n\n\n\ngenerate_handlers{T\n:PainterQB.Instrument}(insType::Type{T\n:PainterQB.Instrument},  responseDict::Dict{K, V}) \n\u00b6\n\n\ngenerate_handlers\n\n\ngenerate_handlers{T\n:Instrument}(insType::Type{T}, responseDict::Dict)\n\n\nEach instrument can have a \nresponseDict\n. For each setting of the instrument,\nfor instance the \nClockSource\n, we need to know the correspondence between a\nlogical state \nExternalClock\n and how the instrument encodes that logical state\n(e.g. \"EXT\").\nThe \nresponseDict\n is actually a dictionary of dictionaries. The first level keys\nare like \nClockSource\n and the second level keys are like \"EXT\", with the value\nbeing \n:ExternalClock\n. Undoubtedly\nthis nested dictionary is \"nasty\" (in the technical parlance) but the dictionary\nis only used for code\ncreation and is not used at run-time (if the code works as intended).\n\n\nThis function makes a lot of other functions. Given some response from an instrument,\nwe require a function to map that response back on to the appropiate logical state.\n\n\nClockSource(ins::AWG5014C, res::AbstractString)\n\nreturns an \nInternalClock\n or \nExternalClock\n type as appropriate,\nbased on the logical meaning of the response.\n\n\nWe also want a function to generate logical states without having to know the way\nthey are encoded by the instrument.\n\n\ncode(ins::AWG5014C, ::Type{InternalClock})\n returns \"INT\",\nwith \"INT\" encoding how to pass this logical state to the instrument \nins\n.\n\n\nsource:\n\n\nPainterQB\\src\\Metaprogramming.jl:213\n\n\n\n\n\n\ngenerate_inspect{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty},  ::Type{PainterQB.NoArgs}) \n\u00b6\n\n\ngenerate_inspect{S\n:Instrument,T\n:InstrumentProperty}(instype::Type{S},\n        command::ASCIIString, proptype::Type{T}, returntype...)\n\n\n\n\nThis command takes an \nInstrument\n subtype \ninstype\n, a VISA command, an\n\nInstrumentProperty\n subtype \nproptype\n, and possibly an argument. It will\ngenerate the following method in the module where \ngenerate_inspect\n is defined:\n\n\ninspect(ins::instype, ::Type{proptype}, infixes::Int...)\n\n\nThe \ninfixes\n variable argument allows for numbers to be inserted within the\ncommands, for instance in \nOUTP#:FILT:FREQ\n, where the \n#\n sign should be\nreplaced by an integer. The replacements are done in the order of the arguments.\nError checking is done on the number of arguments.\n\n\nFor a given property, \ninspect\n will return either an InstrumentProperty subtype,\na number, a boolean, or a string as appropriate.\n\n\nsource:\n\n\nPainterQB\\src\\Metaprogramming.jl:32\n\n\n\n\n\n\ngenerate_properties{S\n:PainterQB.InstrumentProperty}(subtype::Symbol,  supertype::Type{S\n:PainterQB.InstrumentProperty}) \n\u00b6\n\n\nMakes parametric subtypes and gives constructors. Also defines a code method.\n\n\nsource:\n\n\nPainterQB\\src\\Metaprogramming.jl:176", 
            "title": "PainterQB"
        }, 
        {
            "location": "/api/PainterQB/#painterqb", 
            "text": "", 
            "title": "PainterQB"
        }, 
        {
            "location": "/api/PainterQB/#methods-exported", 
            "text": "ask(ins::PainterQB.InstrumentVISA,  msg::ASCIIString)  \u00b6  Idiomatic \"write and read available\" function with optional delay.  source:  PainterQB\\src\\VISA.jl:63    ask(ins::PainterQB.InstrumentVISA,  msg::ASCIIString,  delay::Real)  \u00b6  Idiomatic \"write and read available\" function with optional delay.  source:  PainterQB\\src\\VISA.jl:63    binblockreadavailable(ins::PainterQB.InstrumentVISA)  \u00b6  Read an entire block of bytes with properly formatted IEEE header.  source:  PainterQB\\src\\VISA.jl:92    binblockwrite(ins::PainterQB.InstrumentVISA,  message::Union{ASCIIString, Array{UInt8, 1}},  data::Array{UInt8, 1})  \u00b6  Write an IEEE header block followed by an arbitary sequency of bytes and the terminator.  source:  PainterQB\\src\\VISA.jl:87    findresources()  \u00b6  Finds VISA resources to which we can connect. Doesn't find ethernet instruments.  source:  PainterQB\\src\\VISA.jl:42    findresources(expr::AbstractString)  \u00b6  Finds VISA resources to which we can connect. Doesn't find ethernet instruments.  source:  PainterQB\\src\\VISA.jl:42    gpib(primary)  \u00b6  Returns a viSession for the given GPIB address.  source:  PainterQB\\src\\VISA.jl:45    read(ins::PainterQB.InstrumentVISA)  \u00b6  Read from an instrument. Strips trailing carriage returns and new lines.\nNote that this function will only read so many characters (buffered).  source:  PainterQB\\src\\VISA.jl:73    readavailable(ins::PainterQB.InstrumentVISA)  \u00b6  Keep reading from an instrument until the instrument says we are done.  source:  PainterQB\\src\\VISA.jl:81    tcpip_instr(ip)  \u00b6  Returns a INSTR viSession for the given IPv4 address.  source:  PainterQB\\src\\VISA.jl:54    tcpip_socket(ip,  port)  \u00b6  Returns a raw socket viSession for the given IPv4 address.  source:  PainterQB\\src\\VISA.jl:57    write(ins::PainterQB.InstrumentVISA,  msg::ASCIIString)  \u00b6  Write to an instrument. Appends the instrument's write terminator.  source:  PainterQB\\src\\VISA.jl:77", 
            "title": "Methods [Exported]"
        }, 
        {
            "location": "/api/PainterQB/#types-exported", 
            "text": "PainterQB.All  \u00b6  The All type is meant to be dispatched upon and not instantiated.  source:  PainterQB\\src\\Definitions.jl:229    PainterQB.DelayStimulus  \u00b6  DelayStimulus  When sourced with a value in seconds, will wait until that many\nseconds have elapsed since the DelayStimulus was initialized.  source:  PainterQB\\src\\sourcemeasure\\Time.jl:9    PainterQB.InstrumentProperty  \u00b6  InstrumentProperty  abstract InstrumentProperty  : Any  Abstract supertype representing communications with an instrument.  Each  abstract  subtype one level down should represent a logical state of the\ninstrument configuration, e.g.  TriggerSource  may be have concrete\nsubtypes  ExternalTrigger  or  InternalTrigger .  Each  concrete  subtype two levels down is an immutable type: InternalTrigger(ins::AWG5014C, \"INT\")  encodes everything one needs to know\nfor how the AWG5014C represents an internal trigger.  To retrieve what one has to send the AWG from the type signature, we have\ndefined a function  code .  source:  PainterQB\\src\\Definitions.jl:62    PainterQB.InstrumentVISA  \u00b6  InstrumentVISA  abstract InstrumentVISA  : Instrument  Abstract supertype of all Instruments addressable using a VISA library.\nConcrete types are expected to have fields:  vi::ViSession  writeTerminator::ASCIIString  source:  PainterQB\\src\\VISA.jl:37    PainterQB.TimeAResponse  \u00b6  TimeAResponse  When measured, will return how many seconds it takes to measure\nthe response field it holds. So meta.  source:  PainterQB\\src\\sourcemeasure\\Time.jl:42    PainterQB.TimerResponse{T :AbstractFloat}  \u00b6  TimerResponse  When measured, will return how many seconds have elapsed since\nthe timer was initialized.  source:  PainterQB\\src\\sourcemeasure\\Time.jl:30", 
            "title": "Types [Exported]"
        }, 
        {
            "location": "/api/PainterQB/#methods-internal", 
            "text": "generate_configure{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty})  \u00b6  generate_configure{S :Instrument,T :InstrumentProperty}(instype::Type{S},\n        command::ASCIIString, proptype::Type{T}, returntype...)  This command takes an  Instrument  subtype  InsType , a VISA command, an InstrumentProperty  type, and possibly an argument. It will generate one of the\nfollowing methods in the module where  generate_inspect  is defined:  configure(ins::InsType, PropertySubtype)\nconfigure(ins::InsType, Property, values..., infixes...)  source:  PainterQB\\src\\Metaprogramming.jl:93    generate_handlers{T :PainterQB.Instrument}(insType::Type{T :PainterQB.Instrument},  responseDict::Dict{K, V})  \u00b6  generate_handlers  generate_handlers{T :Instrument}(insType::Type{T}, responseDict::Dict)  Each instrument can have a  responseDict . For each setting of the instrument,\nfor instance the  ClockSource , we need to know the correspondence between a\nlogical state  ExternalClock  and how the instrument encodes that logical state\n(e.g. \"EXT\").\nThe  responseDict  is actually a dictionary of dictionaries. The first level keys\nare like  ClockSource  and the second level keys are like \"EXT\", with the value\nbeing  :ExternalClock . Undoubtedly\nthis nested dictionary is \"nasty\" (in the technical parlance) but the dictionary\nis only used for code\ncreation and is not used at run-time (if the code works as intended).  This function makes a lot of other functions. Given some response from an instrument,\nwe require a function to map that response back on to the appropiate logical state.  ClockSource(ins::AWG5014C, res::AbstractString) \nreturns an  InternalClock  or  ExternalClock  type as appropriate,\nbased on the logical meaning of the response.  We also want a function to generate logical states without having to know the way\nthey are encoded by the instrument.  code(ins::AWG5014C, ::Type{InternalClock})  returns \"INT\",\nwith \"INT\" encoding how to pass this logical state to the instrument  ins .  source:  PainterQB\\src\\Metaprogramming.jl:213    generate_inspect{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty},  ::Type{PainterQB.NoArgs})  \u00b6  generate_inspect{S :Instrument,T :InstrumentProperty}(instype::Type{S},\n        command::ASCIIString, proptype::Type{T}, returntype...)  This command takes an  Instrument  subtype  instype , a VISA command, an InstrumentProperty  subtype  proptype , and possibly an argument. It will\ngenerate the following method in the module where  generate_inspect  is defined:  inspect(ins::instype, ::Type{proptype}, infixes::Int...)  The  infixes  variable argument allows for numbers to be inserted within the\ncommands, for instance in  OUTP#:FILT:FREQ , where the  #  sign should be\nreplaced by an integer. The replacements are done in the order of the arguments.\nError checking is done on the number of arguments.  For a given property,  inspect  will return either an InstrumentProperty subtype,\na number, a boolean, or a string as appropriate.  source:  PainterQB\\src\\Metaprogramming.jl:32    generate_properties{S :PainterQB.InstrumentProperty}(subtype::Symbol,  supertype::Type{S :PainterQB.InstrumentProperty})  \u00b6  Makes parametric subtypes and gives constructors. Also defines a code method.  source:  PainterQB\\src\\Metaprogramming.jl:176", 
            "title": "Methods [Internal]"
        }, 
        {
            "location": "/api/E8257D/", 
            "text": "PainterQB.E8257DModule\n\n\nMethods [Internal]\n\n\n\n\n\n\ngenerate_configure{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty}) \n\u00b6\n\n\ngenerate_configure{S\n:Instrument,T\n:InstrumentProperty}(instype::Type{S},\n        command::ASCIIString, proptype::Type{T}, returntype...)\n\n\n\n\nThis command takes an \nInstrument\n subtype \nInsType\n, a VISA command, an\n\nInstrumentProperty\n type, and possibly an argument. It will generate one of the\nfollowing methods in the module where \ngenerate_inspect\n is defined:\n\n\nconfigure(ins::InsType, PropertySubtype)\nconfigure(ins::InsType, Property, values..., infixes...)\n\n\n\n\nsource:\n\n\nPainterQB\\src\\Metaprogramming.jl:93\n\n\n\n\n\n\ngenerate_handlers{T\n:PainterQB.Instrument}(insType::Type{T\n:PainterQB.Instrument},  responseDict::Dict{K, V}) \n\u00b6\n\n\ngenerate_handlers\n\n\ngenerate_handlers{T\n:Instrument}(insType::Type{T}, responseDict::Dict)\n\n\nEach instrument can have a \nresponseDict\n. For each setting of the instrument,\nfor instance the \nClockSource\n, we need to know the correspondence between a\nlogical state \nExternalClock\n and how the instrument encodes that logical state\n(e.g. \"EXT\").\nThe \nresponseDict\n is actually a dictionary of dictionaries. The first level keys\nare like \nClockSource\n and the second level keys are like \"EXT\", with the value\nbeing \n:ExternalClock\n. Undoubtedly\nthis nested dictionary is \"nasty\" (in the technical parlance) but the dictionary\nis only used for code\ncreation and is not used at run-time (if the code works as intended).\n\n\nThis function makes a lot of other functions. Given some response from an instrument,\nwe require a function to map that response back on to the appropiate logical state.\n\n\nClockSource(ins::AWG5014C, res::AbstractString)\n\nreturns an \nInternalClock\n or \nExternalClock\n type as appropriate,\nbased on the logical meaning of the response.\n\n\nWe also want a function to generate logical states without having to know the way\nthey are encoded by the instrument.\n\n\ncode(ins::AWG5014C, ::Type{InternalClock})\n returns \"INT\",\nwith \"INT\" encoding how to pass this logical state to the instrument \nins\n.\n\n\nsource:\n\n\nPainterQB\\src\\Metaprogramming.jl:213\n\n\n\n\n\n\ngenerate_inspect{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty},  ::Type{PainterQB.NoArgs}) \n\u00b6\n\n\ngenerate_inspect{S\n:Instrument,T\n:InstrumentProperty}(instype::Type{S},\n        command::ASCIIString, proptype::Type{T}, returntype...)\n\n\n\n\nThis command takes an \nInstrument\n subtype \ninstype\n, a VISA command, an\n\nInstrumentProperty\n subtype \nproptype\n, and possibly an argument. It will\ngenerate the following method in the module where \ngenerate_inspect\n is defined:\n\n\ninspect(ins::instype, ::Type{proptype}, infixes::Int...)\n\n\nThe \ninfixes\n variable argument allows for numbers to be inserted within the\ncommands, for instance in \nOUTP#:FILT:FREQ\n, where the \n#\n sign should be\nreplaced by an integer. The replacements are done in the order of the arguments.\nError checking is done on the number of arguments.\n\n\nFor a given property, \ninspect\n will return either an InstrumentProperty subtype,\na number, a boolean, or a string as appropriate.\n\n\nsource:\n\n\nPainterQB\\src\\Metaprogramming.jl:32\n\n\n\n\n\n\ngenerate_properties{S\n:PainterQB.InstrumentProperty}(subtype::Symbol,  supertype::Type{S\n:PainterQB.InstrumentProperty}) \n\u00b6\n\n\nMakes parametric subtypes and gives constructors. Also defines a code method.\n\n\nsource:\n\n\nPainterQB\\src\\Metaprogramming.jl:176", 
            "title": "E8257D"
        }, 
        {
            "location": "/api/E8257D/#painterqbe8257dmodule", 
            "text": "", 
            "title": "PainterQB.E8257DModule"
        }, 
        {
            "location": "/api/E8257D/#methods-internal", 
            "text": "generate_configure{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty})  \u00b6  generate_configure{S :Instrument,T :InstrumentProperty}(instype::Type{S},\n        command::ASCIIString, proptype::Type{T}, returntype...)  This command takes an  Instrument  subtype  InsType , a VISA command, an InstrumentProperty  type, and possibly an argument. It will generate one of the\nfollowing methods in the module where  generate_inspect  is defined:  configure(ins::InsType, PropertySubtype)\nconfigure(ins::InsType, Property, values..., infixes...)  source:  PainterQB\\src\\Metaprogramming.jl:93    generate_handlers{T :PainterQB.Instrument}(insType::Type{T :PainterQB.Instrument},  responseDict::Dict{K, V})  \u00b6  generate_handlers  generate_handlers{T :Instrument}(insType::Type{T}, responseDict::Dict)  Each instrument can have a  responseDict . For each setting of the instrument,\nfor instance the  ClockSource , we need to know the correspondence between a\nlogical state  ExternalClock  and how the instrument encodes that logical state\n(e.g. \"EXT\").\nThe  responseDict  is actually a dictionary of dictionaries. The first level keys\nare like  ClockSource  and the second level keys are like \"EXT\", with the value\nbeing  :ExternalClock . Undoubtedly\nthis nested dictionary is \"nasty\" (in the technical parlance) but the dictionary\nis only used for code\ncreation and is not used at run-time (if the code works as intended).  This function makes a lot of other functions. Given some response from an instrument,\nwe require a function to map that response back on to the appropiate logical state.  ClockSource(ins::AWG5014C, res::AbstractString) \nreturns an  InternalClock  or  ExternalClock  type as appropriate,\nbased on the logical meaning of the response.  We also want a function to generate logical states without having to know the way\nthey are encoded by the instrument.  code(ins::AWG5014C, ::Type{InternalClock})  returns \"INT\",\nwith \"INT\" encoding how to pass this logical state to the instrument  ins .  source:  PainterQB\\src\\Metaprogramming.jl:213    generate_inspect{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty},  ::Type{PainterQB.NoArgs})  \u00b6  generate_inspect{S :Instrument,T :InstrumentProperty}(instype::Type{S},\n        command::ASCIIString, proptype::Type{T}, returntype...)  This command takes an  Instrument  subtype  instype , a VISA command, an InstrumentProperty  subtype  proptype , and possibly an argument. It will\ngenerate the following method in the module where  generate_inspect  is defined:  inspect(ins::instype, ::Type{proptype}, infixes::Int...)  The  infixes  variable argument allows for numbers to be inserted within the\ncommands, for instance in  OUTP#:FILT:FREQ , where the  #  sign should be\nreplaced by an integer. The replacements are done in the order of the arguments.\nError checking is done on the number of arguments.  For a given property,  inspect  will return either an InstrumentProperty subtype,\na number, a boolean, or a string as appropriate.  source:  PainterQB\\src\\Metaprogramming.jl:32    generate_properties{S :PainterQB.InstrumentProperty}(subtype::Symbol,  supertype::Type{S :PainterQB.InstrumentProperty})  \u00b6  Makes parametric subtypes and gives constructors. Also defines a code method.  source:  PainterQB\\src\\Metaprogramming.jl:176", 
            "title": "Methods [Internal]"
        }, 
        {
            "location": "/api/E5071C/", 
            "text": "PainterQB.E5071CModule\n\n\nMethods [Internal]\n\n\n\n\n\n\ngenerate_configure{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty}) \n\u00b6\n\n\ngenerate_configure{S\n:Instrument,T\n:InstrumentProperty}(instype::Type{S},\n        command::ASCIIString, proptype::Type{T}, returntype...)\n\n\n\n\nThis command takes an \nInstrument\n subtype \nInsType\n, a VISA command, an\n\nInstrumentProperty\n type, and possibly an argument. It will generate one of the\nfollowing methods in the module where \ngenerate_inspect\n is defined:\n\n\nconfigure(ins::InsType, PropertySubtype)\nconfigure(ins::InsType, Property, values..., infixes...)\n\n\n\n\nsource:\n\n\nPainterQB\\src\\Metaprogramming.jl:93\n\n\n\n\n\n\ngenerate_handlers{T\n:PainterQB.Instrument}(insType::Type{T\n:PainterQB.Instrument},  responseDict::Dict{K, V}) \n\u00b6\n\n\ngenerate_handlers\n\n\ngenerate_handlers{T\n:Instrument}(insType::Type{T}, responseDict::Dict)\n\n\nEach instrument can have a \nresponseDict\n. For each setting of the instrument,\nfor instance the \nClockSource\n, we need to know the correspondence between a\nlogical state \nExternalClock\n and how the instrument encodes that logical state\n(e.g. \"EXT\").\nThe \nresponseDict\n is actually a dictionary of dictionaries. The first level keys\nare like \nClockSource\n and the second level keys are like \"EXT\", with the value\nbeing \n:ExternalClock\n. Undoubtedly\nthis nested dictionary is \"nasty\" (in the technical parlance) but the dictionary\nis only used for code\ncreation and is not used at run-time (if the code works as intended).\n\n\nThis function makes a lot of other functions. Given some response from an instrument,\nwe require a function to map that response back on to the appropiate logical state.\n\n\nClockSource(ins::AWG5014C, res::AbstractString)\n\nreturns an \nInternalClock\n or \nExternalClock\n type as appropriate,\nbased on the logical meaning of the response.\n\n\nWe also want a function to generate logical states without having to know the way\nthey are encoded by the instrument.\n\n\ncode(ins::AWG5014C, ::Type{InternalClock})\n returns \"INT\",\nwith \"INT\" encoding how to pass this logical state to the instrument \nins\n.\n\n\nsource:\n\n\nPainterQB\\src\\Metaprogramming.jl:213\n\n\n\n\n\n\ngenerate_inspect{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty},  ::Type{PainterQB.NoArgs}) \n\u00b6\n\n\ngenerate_inspect{S\n:Instrument,T\n:InstrumentProperty}(instype::Type{S},\n        command::ASCIIString, proptype::Type{T}, returntype...)\n\n\n\n\nThis command takes an \nInstrument\n subtype \ninstype\n, a VISA command, an\n\nInstrumentProperty\n subtype \nproptype\n, and possibly an argument. It will\ngenerate the following method in the module where \ngenerate_inspect\n is defined:\n\n\ninspect(ins::instype, ::Type{proptype}, infixes::Int...)\n\n\nThe \ninfixes\n variable argument allows for numbers to be inserted within the\ncommands, for instance in \nOUTP#:FILT:FREQ\n, where the \n#\n sign should be\nreplaced by an integer. The replacements are done in the order of the arguments.\nError checking is done on the number of arguments.\n\n\nFor a given property, \ninspect\n will return either an InstrumentProperty subtype,\na number, a boolean, or a string as appropriate.\n\n\nsource:\n\n\nPainterQB\\src\\Metaprogramming.jl:32\n\n\n\n\n\n\ngenerate_properties{S\n:PainterQB.InstrumentProperty}(subtype::Symbol,  supertype::Type{S\n:PainterQB.InstrumentProperty}) \n\u00b6\n\n\nMakes parametric subtypes and gives constructors. Also defines a code method.\n\n\nsource:\n\n\nPainterQB\\src\\Metaprogramming.jl:176", 
            "title": "E5071C"
        }, 
        {
            "location": "/api/E5071C/#painterqbe5071cmodule", 
            "text": "", 
            "title": "PainterQB.E5071CModule"
        }, 
        {
            "location": "/api/E5071C/#methods-internal", 
            "text": "generate_configure{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty})  \u00b6  generate_configure{S :Instrument,T :InstrumentProperty}(instype::Type{S},\n        command::ASCIIString, proptype::Type{T}, returntype...)  This command takes an  Instrument  subtype  InsType , a VISA command, an InstrumentProperty  type, and possibly an argument. It will generate one of the\nfollowing methods in the module where  generate_inspect  is defined:  configure(ins::InsType, PropertySubtype)\nconfigure(ins::InsType, Property, values..., infixes...)  source:  PainterQB\\src\\Metaprogramming.jl:93    generate_handlers{T :PainterQB.Instrument}(insType::Type{T :PainterQB.Instrument},  responseDict::Dict{K, V})  \u00b6  generate_handlers  generate_handlers{T :Instrument}(insType::Type{T}, responseDict::Dict)  Each instrument can have a  responseDict . For each setting of the instrument,\nfor instance the  ClockSource , we need to know the correspondence between a\nlogical state  ExternalClock  and how the instrument encodes that logical state\n(e.g. \"EXT\").\nThe  responseDict  is actually a dictionary of dictionaries. The first level keys\nare like  ClockSource  and the second level keys are like \"EXT\", with the value\nbeing  :ExternalClock . Undoubtedly\nthis nested dictionary is \"nasty\" (in the technical parlance) but the dictionary\nis only used for code\ncreation and is not used at run-time (if the code works as intended).  This function makes a lot of other functions. Given some response from an instrument,\nwe require a function to map that response back on to the appropiate logical state.  ClockSource(ins::AWG5014C, res::AbstractString) \nreturns an  InternalClock  or  ExternalClock  type as appropriate,\nbased on the logical meaning of the response.  We also want a function to generate logical states without having to know the way\nthey are encoded by the instrument.  code(ins::AWG5014C, ::Type{InternalClock})  returns \"INT\",\nwith \"INT\" encoding how to pass this logical state to the instrument  ins .  source:  PainterQB\\src\\Metaprogramming.jl:213    generate_inspect{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty},  ::Type{PainterQB.NoArgs})  \u00b6  generate_inspect{S :Instrument,T :InstrumentProperty}(instype::Type{S},\n        command::ASCIIString, proptype::Type{T}, returntype...)  This command takes an  Instrument  subtype  instype , a VISA command, an InstrumentProperty  subtype  proptype , and possibly an argument. It will\ngenerate the following method in the module where  generate_inspect  is defined:  inspect(ins::instype, ::Type{proptype}, infixes::Int...)  The  infixes  variable argument allows for numbers to be inserted within the\ncommands, for instance in  OUTP#:FILT:FREQ , where the  #  sign should be\nreplaced by an integer. The replacements are done in the order of the arguments.\nError checking is done on the number of arguments.  For a given property,  inspect  will return either an InstrumentProperty subtype,\na number, a boolean, or a string as appropriate.  source:  PainterQB\\src\\Metaprogramming.jl:32    generate_properties{S :PainterQB.InstrumentProperty}(subtype::Symbol,  supertype::Type{S :PainterQB.InstrumentProperty})  \u00b6  Makes parametric subtypes and gives constructors. Also defines a code method.  source:  PainterQB\\src\\Metaprogramming.jl:176", 
            "title": "Methods [Internal]"
        }, 
        {
            "location": "/api/AWG5014C/", 
            "text": "PainterQB.AWG5014CModule\n\n\nMethods [Exported]\n\n\n\n\n\n\npullfrom_awg(ins::PainterQB.AWG5014CModule.AWG5014C,  name::ASCIIString) \n\u00b6\n\n\nPull data from the AWG, performing checks and generating errors as appropriate.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:527\n\n\n\n\n\n\npushto_awg{T\n:PainterQB.AWG5014CModule.WaveformType}(ins::PainterQB.AWG5014CModule.AWG5014C,  name::ASCIIString,  awgData::PainterQB.AWG5014CModule.AWG5014CData,  wvType::Type{T\n:PainterQB.AWG5014CModule.WaveformType}) \n\u00b6\n\n\nPush data to the AWG, performing checks and generating errors as appropriate.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:441\n\n\n\n\n\n\npushto_awg{T\n:PainterQB.AWG5014CModule.WaveformType}(ins::PainterQB.AWG5014CModule.AWG5014C,  name::ASCIIString,  awgData::PainterQB.AWG5014CModule.AWG5014CData,  wvType::Type{T\n:PainterQB.AWG5014CModule.WaveformType},  resampleOk::Bool) \n\u00b6\n\n\nPush data to the AWG, performing checks and generating errors as appropriate.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:441\n\n\n\n\n\n\nrunapplication(ins::PainterQB.AWG5014CModule.AWG5014C,  app::ASCIIString) \n\u00b6\n\n\nRun an application, e.g. SerialXpress\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:368\n\n\n\n\n\n\nvalidate(awgData::PainterQB.AWG5014CModule.AWG5014CData,  wvType::Type{PainterQB.AWG5014CModule.WaveformType}) \n\u00b6\n\n\nValidates data to be pushed to the AWG to check for internal consistency and appropriate range.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:502\n\n\n\n\n\n\nwaveformname(ins::PainterQB.AWG5014CModule.AWG5014C,  num::Integer) \n\u00b6\n\n\nUses Julia style indexing (begins at 1) to retrieve the name of a waveform.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:427\n\n\n\n\n\n\nwaveformtype(ins::PainterQB.AWG5014CModule.AWG5014C,  name::ASCIIString) \n\u00b6\n\n\nReturns the type of the waveform. The AWG hardware ultimately uses an \nIntWaveform\n but \nRealWaveform\n is more convenient.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:436\n\n\nMacros [Exported]\n\n\n\n\n\n\n@allch(x::Expr) \n\u00b6\n\n\nMacro for performing an operation on every channel,\nprovided the channel is the last argument of the function to be called.\n\n\nExample: \n@allch setWaveform(awg,\"*Sine10\")\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:290\n\n\nMethods [Internal]\n\n\n\n\n\n\nconfigure(ins::PainterQB.AWG5014CModule.AWG5014C,  ::Type{PainterQB.Phase},  phase::Real,  ch::Integer) \n\u00b6\n\n\nSet the output phase in degrees for a given channel.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:309\n\n\n\n\n\n\nconfigure(ins::PainterQB.AWG5014CModule.AWG5014C,  ::Type{PainterQB.SampleRate},  rate::Real) \n\u00b6\n\n\nSet the sample rate in Hz between 10 MHz and 10 GHz. Output rate = sample rate / number of points.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:352\n\n\n\n\n\n\ngenerate_configure{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty}) \n\u00b6\n\n\ngenerate_configure{S\n:Instrument,T\n:InstrumentProperty}(instype::Type{S},\n        command::ASCIIString, proptype::Type{T}, returntype...)\n\n\n\n\nThis command takes an \nInstrument\n subtype \nInsType\n, a VISA command, an\n\nInstrumentProperty\n type, and possibly an argument. It will generate one of the\nfollowing methods in the module where \ngenerate_inspect\n is defined:\n\n\nconfigure(ins::InsType, PropertySubtype)\nconfigure(ins::InsType, Property, values..., infixes...)\n\n\n\n\nsource:\n\n\nPainterQB\\src\\Metaprogramming.jl:93\n\n\n\n\n\n\ngenerate_handlers{T\n:PainterQB.Instrument}(insType::Type{T\n:PainterQB.Instrument},  responseDict::Dict{K, V}) \n\u00b6\n\n\ngenerate_handlers\n\n\ngenerate_handlers{T\n:Instrument}(insType::Type{T}, responseDict::Dict)\n\n\nEach instrument can have a \nresponseDict\n. For each setting of the instrument,\nfor instance the \nClockSource\n, we need to know the correspondence between a\nlogical state \nExternalClock\n and how the instrument encodes that logical state\n(e.g. \"EXT\").\nThe \nresponseDict\n is actually a dictionary of dictionaries. The first level keys\nare like \nClockSource\n and the second level keys are like \"EXT\", with the value\nbeing \n:ExternalClock\n. Undoubtedly\nthis nested dictionary is \"nasty\" (in the technical parlance) but the dictionary\nis only used for code\ncreation and is not used at run-time (if the code works as intended).\n\n\nThis function makes a lot of other functions. Given some response from an instrument,\nwe require a function to map that response back on to the appropiate logical state.\n\n\nClockSource(ins::AWG5014C, res::AbstractString)\n\nreturns an \nInternalClock\n or \nExternalClock\n type as appropriate,\nbased on the logical meaning of the response.\n\n\nWe also want a function to generate logical states without having to know the way\nthey are encoded by the instrument.\n\n\ncode(ins::AWG5014C, ::Type{InternalClock})\n returns \"INT\",\nwith \"INT\" encoding how to pass this logical state to the instrument \nins\n.\n\n\nsource:\n\n\nPainterQB\\src\\Metaprogramming.jl:213\n\n\n\n\n\n\ngenerate_inspect{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty},  ::Type{PainterQB.NoArgs}) \n\u00b6\n\n\ngenerate_inspect{S\n:Instrument,T\n:InstrumentProperty}(instype::Type{S},\n        command::ASCIIString, proptype::Type{T}, returntype...)\n\n\n\n\nThis command takes an \nInstrument\n subtype \ninstype\n, a VISA command, an\n\nInstrumentProperty\n subtype \nproptype\n, and possibly an argument. It will\ngenerate the following method in the module where \ngenerate_inspect\n is defined:\n\n\ninspect(ins::instype, ::Type{proptype}, infixes::Int...)\n\n\nThe \ninfixes\n variable argument allows for numbers to be inserted within the\ncommands, for instance in \nOUTP#:FILT:FREQ\n, where the \n#\n sign should be\nreplaced by an integer. The replacements are done in the order of the arguments.\nError checking is done on the number of arguments.\n\n\nFor a given property, \ninspect\n will return either an InstrumentProperty subtype,\na number, a boolean, or a string as appropriate.\n\n\nsource:\n\n\nPainterQB\\src\\Metaprogramming.jl:32\n\n\n\n\n\n\ngenerate_properties{S\n:PainterQB.InstrumentProperty}(subtype::Symbol,  supertype::Type{S\n:PainterQB.InstrumentProperty}) \n\u00b6\n\n\nMakes parametric subtypes and gives constructors. Also defines a code method.\n\n\nsource:\n\n\nPainterQB\\src\\Metaprogramming.jl:176\n\n\n\n\n\n\ninspect(ins::PainterQB.AWG5014CModule.AWG5014C,  ::Type{PainterQB.AWG5014CModule.SequencerType}) \n\u00b6\n\n\nCurrent sequencer type\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:363\n\n\n\n\n\n\ninspect(ins::PainterQB.AWG5014CModule.AWG5014C,  ::Type{PainterQB.Phase},  ch::Integer) \n\u00b6\n\n\nGet the output phase in degrees for a given channel.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:303\n\n\n\n\n\n\ninspect(ins::PainterQB.AWG5014CModule.AWG5014C,  ::Type{PainterQB.SampleRate}) \n\u00b6\n\n\nGet the sample rate in Hz. Output rate = sample rate / number of points.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:358\n\n\n\n\n\n\npulllowlevel{T\n:PainterQB.AWG5014CModule.RealWaveform}(ins::PainterQB.AWG5014CModule.AWG5014C,  name::ASCIIString,  ::Type{T\n:PainterQB.AWG5014CModule.RealWaveform}) \n\u00b6\n\n\nTakes care of the dirty work in pulling data from the AWG.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:539\n\n\n\n\n\n\npushlowlevel{T\n:PainterQB.AWG5014CModule.RealWaveform}(ins::PainterQB.AWG5014CModule.AWG5014C,  name::ASCIIString,  awgData::PainterQB.AWG5014CModule.AWG5014CData,  wvType::Type{T\n:PainterQB.AWG5014CModule.RealWaveform}) \n\u00b6\n\n\nTakes care of the dirty work in pushing the data to the AWG.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\AWG5014C.jl:477", 
            "title": "AWG5014C"
        }, 
        {
            "location": "/api/AWG5014C/#painterqbawg5014cmodule", 
            "text": "", 
            "title": "PainterQB.AWG5014CModule"
        }, 
        {
            "location": "/api/AWG5014C/#methods-exported", 
            "text": "pullfrom_awg(ins::PainterQB.AWG5014CModule.AWG5014C,  name::ASCIIString)  \u00b6  Pull data from the AWG, performing checks and generating errors as appropriate.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:527    pushto_awg{T :PainterQB.AWG5014CModule.WaveformType}(ins::PainterQB.AWG5014CModule.AWG5014C,  name::ASCIIString,  awgData::PainterQB.AWG5014CModule.AWG5014CData,  wvType::Type{T :PainterQB.AWG5014CModule.WaveformType})  \u00b6  Push data to the AWG, performing checks and generating errors as appropriate.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:441    pushto_awg{T :PainterQB.AWG5014CModule.WaveformType}(ins::PainterQB.AWG5014CModule.AWG5014C,  name::ASCIIString,  awgData::PainterQB.AWG5014CModule.AWG5014CData,  wvType::Type{T :PainterQB.AWG5014CModule.WaveformType},  resampleOk::Bool)  \u00b6  Push data to the AWG, performing checks and generating errors as appropriate.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:441    runapplication(ins::PainterQB.AWG5014CModule.AWG5014C,  app::ASCIIString)  \u00b6  Run an application, e.g. SerialXpress  source:  PainterQB\\src\\instruments\\AWG5014C.jl:368    validate(awgData::PainterQB.AWG5014CModule.AWG5014CData,  wvType::Type{PainterQB.AWG5014CModule.WaveformType})  \u00b6  Validates data to be pushed to the AWG to check for internal consistency and appropriate range.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:502    waveformname(ins::PainterQB.AWG5014CModule.AWG5014C,  num::Integer)  \u00b6  Uses Julia style indexing (begins at 1) to retrieve the name of a waveform.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:427    waveformtype(ins::PainterQB.AWG5014CModule.AWG5014C,  name::ASCIIString)  \u00b6  Returns the type of the waveform. The AWG hardware ultimately uses an  IntWaveform  but  RealWaveform  is more convenient.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:436", 
            "title": "Methods [Exported]"
        }, 
        {
            "location": "/api/AWG5014C/#macros-exported", 
            "text": "@allch(x::Expr)  \u00b6  Macro for performing an operation on every channel,\nprovided the channel is the last argument of the function to be called.  Example:  @allch setWaveform(awg,\"*Sine10\")  source:  PainterQB\\src\\instruments\\AWG5014C.jl:290", 
            "title": "Macros [Exported]"
        }, 
        {
            "location": "/api/AWG5014C/#methods-internal", 
            "text": "configure(ins::PainterQB.AWG5014CModule.AWG5014C,  ::Type{PainterQB.Phase},  phase::Real,  ch::Integer)  \u00b6  Set the output phase in degrees for a given channel.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:309    configure(ins::PainterQB.AWG5014CModule.AWG5014C,  ::Type{PainterQB.SampleRate},  rate::Real)  \u00b6  Set the sample rate in Hz between 10 MHz and 10 GHz. Output rate = sample rate / number of points.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:352    generate_configure{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty})  \u00b6  generate_configure{S :Instrument,T :InstrumentProperty}(instype::Type{S},\n        command::ASCIIString, proptype::Type{T}, returntype...)  This command takes an  Instrument  subtype  InsType , a VISA command, an InstrumentProperty  type, and possibly an argument. It will generate one of the\nfollowing methods in the module where  generate_inspect  is defined:  configure(ins::InsType, PropertySubtype)\nconfigure(ins::InsType, Property, values..., infixes...)  source:  PainterQB\\src\\Metaprogramming.jl:93    generate_handlers{T :PainterQB.Instrument}(insType::Type{T :PainterQB.Instrument},  responseDict::Dict{K, V})  \u00b6  generate_handlers  generate_handlers{T :Instrument}(insType::Type{T}, responseDict::Dict)  Each instrument can have a  responseDict . For each setting of the instrument,\nfor instance the  ClockSource , we need to know the correspondence between a\nlogical state  ExternalClock  and how the instrument encodes that logical state\n(e.g. \"EXT\").\nThe  responseDict  is actually a dictionary of dictionaries. The first level keys\nare like  ClockSource  and the second level keys are like \"EXT\", with the value\nbeing  :ExternalClock . Undoubtedly\nthis nested dictionary is \"nasty\" (in the technical parlance) but the dictionary\nis only used for code\ncreation and is not used at run-time (if the code works as intended).  This function makes a lot of other functions. Given some response from an instrument,\nwe require a function to map that response back on to the appropiate logical state.  ClockSource(ins::AWG5014C, res::AbstractString) \nreturns an  InternalClock  or  ExternalClock  type as appropriate,\nbased on the logical meaning of the response.  We also want a function to generate logical states without having to know the way\nthey are encoded by the instrument.  code(ins::AWG5014C, ::Type{InternalClock})  returns \"INT\",\nwith \"INT\" encoding how to pass this logical state to the instrument  ins .  source:  PainterQB\\src\\Metaprogramming.jl:213    generate_inspect{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty},  ::Type{PainterQB.NoArgs})  \u00b6  generate_inspect{S :Instrument,T :InstrumentProperty}(instype::Type{S},\n        command::ASCIIString, proptype::Type{T}, returntype...)  This command takes an  Instrument  subtype  instype , a VISA command, an InstrumentProperty  subtype  proptype , and possibly an argument. It will\ngenerate the following method in the module where  generate_inspect  is defined:  inspect(ins::instype, ::Type{proptype}, infixes::Int...)  The  infixes  variable argument allows for numbers to be inserted within the\ncommands, for instance in  OUTP#:FILT:FREQ , where the  #  sign should be\nreplaced by an integer. The replacements are done in the order of the arguments.\nError checking is done on the number of arguments.  For a given property,  inspect  will return either an InstrumentProperty subtype,\na number, a boolean, or a string as appropriate.  source:  PainterQB\\src\\Metaprogramming.jl:32    generate_properties{S :PainterQB.InstrumentProperty}(subtype::Symbol,  supertype::Type{S :PainterQB.InstrumentProperty})  \u00b6  Makes parametric subtypes and gives constructors. Also defines a code method.  source:  PainterQB\\src\\Metaprogramming.jl:176    inspect(ins::PainterQB.AWG5014CModule.AWG5014C,  ::Type{PainterQB.AWG5014CModule.SequencerType})  \u00b6  Current sequencer type  source:  PainterQB\\src\\instruments\\AWG5014C.jl:363    inspect(ins::PainterQB.AWG5014CModule.AWG5014C,  ::Type{PainterQB.Phase},  ch::Integer)  \u00b6  Get the output phase in degrees for a given channel.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:303    inspect(ins::PainterQB.AWG5014CModule.AWG5014C,  ::Type{PainterQB.SampleRate})  \u00b6  Get the sample rate in Hz. Output rate = sample rate / number of points.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:358    pulllowlevel{T :PainterQB.AWG5014CModule.RealWaveform}(ins::PainterQB.AWG5014CModule.AWG5014C,  name::ASCIIString,  ::Type{T :PainterQB.AWG5014CModule.RealWaveform})  \u00b6  Takes care of the dirty work in pulling data from the AWG.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:539    pushlowlevel{T :PainterQB.AWG5014CModule.RealWaveform}(ins::PainterQB.AWG5014CModule.AWG5014C,  name::ASCIIString,  awgData::PainterQB.AWG5014CModule.AWG5014CData,  wvType::Type{T :PainterQB.AWG5014CModule.RealWaveform})  \u00b6  Takes care of the dirty work in pushing the data to the AWG.  source:  PainterQB\\src\\instruments\\AWG5014C.jl:477", 
            "title": "Methods [Internal]"
        }, 
        {
            "location": "/api/AlazarTech/", 
            "text": "PainterQB.AlazarModule\n\n\nTypes [Exported]\n\n\n\n\n\n\nPainterQB.AlazarModule.AlazarATS9360 \n\u00b6\n\n\nATS9360 is a concrete subtype of InstrumentAlazar.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\models\\ATS9360.jl:6\n\n\n\n\n\n\nPainterQB.AlazarModule.InstrumentAlazar \n\u00b6\n\n\nThe InstrumentAlazar types represent an AlazarTech device on the local\nsystem. It can be used to control configuration parameters, to\nstart acquisitions and to retrieve the acquired data.\n\n\nArgs:\n\n\nsystemId (int): The board system identifier of the target\n  board. Defaults to 1, which is suitable when there is only one\n  board in the system.\n\n\nboardId (int): The target's board identifier in it's\n  system. Defaults to 1, which is suitable when there is only one\n  board in the system.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\Alazar.jl:53\n\n\nMethods [Internal]\n\n\n\n\n\n\ncall(::Type{PainterQB.InstrumentException},  ins::PainterQB.AlazarModule.InstrumentAlazar,  r) \n\u00b6\n\n\nCreate descriptive exceptions.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\Errors.jl:2\n\n\n\n\n\n\ngenerate_configure{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty}) \n\u00b6\n\n\ngenerate_configure{S\n:Instrument,T\n:InstrumentProperty}(instype::Type{S},\n        command::ASCIIString, proptype::Type{T}, returntype...)\n\n\n\n\nThis command takes an \nInstrument\n subtype \nInsType\n, a VISA command, an\n\nInstrumentProperty\n type, and possibly an argument. It will generate one of the\nfollowing methods in the module where \ngenerate_inspect\n is defined:\n\n\nconfigure(ins::InsType, PropertySubtype)\nconfigure(ins::InsType, Property, values..., infixes...)\n\n\n\n\nsource:\n\n\nPainterQB\\src\\Metaprogramming.jl:93\n\n\n\n\n\n\ngenerate_handlers{T\n:PainterQB.Instrument}(insType::Type{T\n:PainterQB.Instrument},  responseDict::Dict{K, V}) \n\u00b6\n\n\ngenerate_handlers\n\n\ngenerate_handlers{T\n:Instrument}(insType::Type{T}, responseDict::Dict)\n\n\nEach instrument can have a \nresponseDict\n. For each setting of the instrument,\nfor instance the \nClockSource\n, we need to know the correspondence between a\nlogical state \nExternalClock\n and how the instrument encodes that logical state\n(e.g. \"EXT\").\nThe \nresponseDict\n is actually a dictionary of dictionaries. The first level keys\nare like \nClockSource\n and the second level keys are like \"EXT\", with the value\nbeing \n:ExternalClock\n. Undoubtedly\nthis nested dictionary is \"nasty\" (in the technical parlance) but the dictionary\nis only used for code\ncreation and is not used at run-time (if the code works as intended).\n\n\nThis function makes a lot of other functions. Given some response from an instrument,\nwe require a function to map that response back on to the appropiate logical state.\n\n\nClockSource(ins::AWG5014C, res::AbstractString)\n\nreturns an \nInternalClock\n or \nExternalClock\n type as appropriate,\nbased on the logical meaning of the response.\n\n\nWe also want a function to generate logical states without having to know the way\nthey are encoded by the instrument.\n\n\ncode(ins::AWG5014C, ::Type{InternalClock})\n returns \"INT\",\nwith \"INT\" encoding how to pass this logical state to the instrument \nins\n.\n\n\nsource:\n\n\nPainterQB\\src\\Metaprogramming.jl:213\n\n\n\n\n\n\ngenerate_inspect{S\n:PainterQB.Instrument, T\n:PainterQB.InstrumentProperty}(instype::Type{S\n:PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T\n:PainterQB.InstrumentProperty},  ::Type{PainterQB.NoArgs}) \n\u00b6\n\n\ngenerate_inspect{S\n:Instrument,T\n:InstrumentProperty}(instype::Type{S},\n        command::ASCIIString, proptype::Type{T}, returntype...)\n\n\n\n\nThis command takes an \nInstrument\n subtype \ninstype\n, a VISA command, an\n\nInstrumentProperty\n subtype \nproptype\n, and possibly an argument. It will\ngenerate the following method in the module where \ngenerate_inspect\n is defined:\n\n\ninspect(ins::instype, ::Type{proptype}, infixes::Int...)\n\n\nThe \ninfixes\n variable argument allows for numbers to be inserted within the\ncommands, for instance in \nOUTP#:FILT:FREQ\n, where the \n#\n sign should be\nreplaced by an integer. The replacements are done in the order of the arguments.\nError checking is done on the number of arguments.\n\n\nFor a given property, \ninspect\n will return either an InstrumentProperty subtype,\na number, a boolean, or a string as appropriate.\n\n\nsource:\n\n\nPainterQB\\src\\Metaprogramming.jl:32\n\n\n\n\n\n\ngenerate_properties{S\n:PainterQB.InstrumentProperty}(subtype::Symbol,  supertype::Type{S\n:PainterQB.InstrumentProperty}) \n\u00b6\n\n\nMakes parametric subtypes and gives constructors. Also defines a code method.\n\n\nsource:\n\n\nPainterQB\\src\\Metaprogramming.jl:176\n\n\nMacros [Internal]\n\n\n\n\n\n\n@eh2(expr) \n\u00b6\n\n\nTakes an Alazar API call and brackets it with some checking.\n\n\nsource:\n\n\nPainterQB\\src\\instruments\\Alazar\\Errors.jl:6", 
            "title": "AlazarTech"
        }, 
        {
            "location": "/api/AlazarTech/#painterqbalazarmodule", 
            "text": "", 
            "title": "PainterQB.AlazarModule"
        }, 
        {
            "location": "/api/AlazarTech/#types-exported", 
            "text": "PainterQB.AlazarModule.AlazarATS9360  \u00b6  ATS9360 is a concrete subtype of InstrumentAlazar.  source:  PainterQB\\src\\instruments\\Alazar\\models\\ATS9360.jl:6    PainterQB.AlazarModule.InstrumentAlazar  \u00b6  The InstrumentAlazar types represent an AlazarTech device on the local\nsystem. It can be used to control configuration parameters, to\nstart acquisitions and to retrieve the acquired data.  Args:  systemId (int): The board system identifier of the target\n  board. Defaults to 1, which is suitable when there is only one\n  board in the system.  boardId (int): The target's board identifier in it's\n  system. Defaults to 1, which is suitable when there is only one\n  board in the system.  source:  PainterQB\\src\\instruments\\Alazar\\Alazar.jl:53", 
            "title": "Types [Exported]"
        }, 
        {
            "location": "/api/AlazarTech/#methods-internal", 
            "text": "call(::Type{PainterQB.InstrumentException},  ins::PainterQB.AlazarModule.InstrumentAlazar,  r)  \u00b6  Create descriptive exceptions.  source:  PainterQB\\src\\instruments\\Alazar\\Errors.jl:2    generate_configure{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty})  \u00b6  generate_configure{S :Instrument,T :InstrumentProperty}(instype::Type{S},\n        command::ASCIIString, proptype::Type{T}, returntype...)  This command takes an  Instrument  subtype  InsType , a VISA command, an InstrumentProperty  type, and possibly an argument. It will generate one of the\nfollowing methods in the module where  generate_inspect  is defined:  configure(ins::InsType, PropertySubtype)\nconfigure(ins::InsType, Property, values..., infixes...)  source:  PainterQB\\src\\Metaprogramming.jl:93    generate_handlers{T :PainterQB.Instrument}(insType::Type{T :PainterQB.Instrument},  responseDict::Dict{K, V})  \u00b6  generate_handlers  generate_handlers{T :Instrument}(insType::Type{T}, responseDict::Dict)  Each instrument can have a  responseDict . For each setting of the instrument,\nfor instance the  ClockSource , we need to know the correspondence between a\nlogical state  ExternalClock  and how the instrument encodes that logical state\n(e.g. \"EXT\").\nThe  responseDict  is actually a dictionary of dictionaries. The first level keys\nare like  ClockSource  and the second level keys are like \"EXT\", with the value\nbeing  :ExternalClock . Undoubtedly\nthis nested dictionary is \"nasty\" (in the technical parlance) but the dictionary\nis only used for code\ncreation and is not used at run-time (if the code works as intended).  This function makes a lot of other functions. Given some response from an instrument,\nwe require a function to map that response back on to the appropiate logical state.  ClockSource(ins::AWG5014C, res::AbstractString) \nreturns an  InternalClock  or  ExternalClock  type as appropriate,\nbased on the logical meaning of the response.  We also want a function to generate logical states without having to know the way\nthey are encoded by the instrument.  code(ins::AWG5014C, ::Type{InternalClock})  returns \"INT\",\nwith \"INT\" encoding how to pass this logical state to the instrument  ins .  source:  PainterQB\\src\\Metaprogramming.jl:213    generate_inspect{S :PainterQB.Instrument, T :PainterQB.InstrumentProperty}(instype::Type{S :PainterQB.Instrument},  command::ASCIIString,  proptype::Type{T :PainterQB.InstrumentProperty},  ::Type{PainterQB.NoArgs})  \u00b6  generate_inspect{S :Instrument,T :InstrumentProperty}(instype::Type{S},\n        command::ASCIIString, proptype::Type{T}, returntype...)  This command takes an  Instrument  subtype  instype , a VISA command, an InstrumentProperty  subtype  proptype , and possibly an argument. It will\ngenerate the following method in the module where  generate_inspect  is defined:  inspect(ins::instype, ::Type{proptype}, infixes::Int...)  The  infixes  variable argument allows for numbers to be inserted within the\ncommands, for instance in  OUTP#:FILT:FREQ , where the  #  sign should be\nreplaced by an integer. The replacements are done in the order of the arguments.\nError checking is done on the number of arguments.  For a given property,  inspect  will return either an InstrumentProperty subtype,\na number, a boolean, or a string as appropriate.  source:  PainterQB\\src\\Metaprogramming.jl:32    generate_properties{S :PainterQB.InstrumentProperty}(subtype::Symbol,  supertype::Type{S :PainterQB.InstrumentProperty})  \u00b6  Makes parametric subtypes and gives constructors. Also defines a code method.  source:  PainterQB\\src\\Metaprogramming.jl:176", 
            "title": "Methods [Internal]"
        }, 
        {
            "location": "/api/AlazarTech/#macros-internal", 
            "text": "@eh2(expr)  \u00b6  Takes an Alazar API call and brackets it with some checking.  source:  PainterQB\\src\\instruments\\Alazar\\Errors.jl:6", 
            "title": "Macros [Internal]"
        }, 
        {
            "location": "/releases/", 
            "text": "Releases\n\n\nv0.0.1      Currently under development", 
            "title": "Release notes"
        }, 
        {
            "location": "/releases/#releases", 
            "text": "v0.0.1      Currently under development", 
            "title": "Releases"
        }, 
        {
            "location": "/LICENSE/", 
            "text": "License\n\n\nMost code:\n\n\n\n\nCopyright (c) 2015: Andrew Keller.\n\n\n\n\nRandom.jl, Time.jl, and a few other snippets here and there:\n\n\n\n\nCopyright (c) 2014: Menyoung Lee.\n\n\n\n\nLarge majority of code in VISA.jl package:\n\n\n\n\nCopyright (c) 2014: Colm Ryan.\n\n\n\n\nAll of the code is licensed under the MIT \"Expat\" License by the respective\ncopyright holders:\n\n\n\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.", 
            "title": "License"
        }, 
        {
            "location": "/LICENSE/#license", 
            "text": "Most code:   Copyright (c) 2015: Andrew Keller.   Random.jl, Time.jl, and a few other snippets here and there:   Copyright (c) 2014: Menyoung Lee.   Large majority of code in VISA.jl package:   Copyright (c) 2014: Colm Ryan.   All of the code is licensed under the MIT \"Expat\" License by the respective\ncopyright holders:   Permission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:  The above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.", 
            "title": "License"
        }
    ]
}