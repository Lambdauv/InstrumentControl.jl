{
    "docs": [
        {
            "location": "/", 
            "text": "PainterQB.jl\n\n\nA \nJulia\n package for qubit measurement and analysis.\n\n\nWork in development, not ready for implementation. The documentation may assume some familiarity\nwith Julia.\n\n\nInstallation\n\n\n\n\nInstall \nNational Instruments VISA libraries\n\n (tested with v15.0.1 on Windows 10)\n\n\nInstall \nAlazarTech\n digitizer drivers and shared libraries\n (may need to contact AlazarTech)\n\n\nInstall \nVISA.jl\n\n\nInstall \nAlazar.jl\n\n\nInstall this code and \ninclude\n it in a Julia environment\n\n\n\n\nQuick start\n\n\nusing PainterQB\nusing PainterQB.AlazarModule\nusing PainterQB.AWG5014CModule  # etc.\n\nawg = AWG5014C(tcpip_socket(\n1.2.3.4\n,5000))\nats = AlazarATS9360()\n\n# do something with awg and ats\n\n\n\n\n\nTo do\n\n\nGlobally\n\n\n\n\nUnits! A good starting point would be the\n\nSIUnits.jl\n package. It currently does\nnot support fractional units like V/sqrt(Hz) but support could be added.\n\n\nHow to save / load configurations for instruments? Maybe JSON files?\n\n\nHow to save / load data?\n\n\nPlotting ease-of-use features?\n\n\n\n\nAWG5014C\n\n\n\n\nWaveform methods could be made more Julian\n\n\nSequencer support needed\n\n\n\n\nAlazar\n\n\n\n\nSome properties seem to be overwritten when switching between measurement\nmodes. e.g. when measuring a ContinuousStreamResponse the trigger needs to be\nreconfigured before measuring a TriggeredStreamResponse.", 
            "title": "Home"
        }, 
        {
            "location": "/#painterqbjl", 
            "text": "A  Julia  package for qubit measurement and analysis.  Work in development, not ready for implementation. The documentation may assume some familiarity\nwith Julia.", 
            "title": "PainterQB.jl"
        }, 
        {
            "location": "/#installation", 
            "text": "Install  National Instruments VISA libraries \n (tested with v15.0.1 on Windows 10)  Install  AlazarTech  digitizer drivers and shared libraries\n (may need to contact AlazarTech)  Install  VISA.jl  Install  Alazar.jl  Install this code and  include  it in a Julia environment", 
            "title": "Installation"
        }, 
        {
            "location": "/#quick-start", 
            "text": "using PainterQB\nusing PainterQB.AlazarModule\nusing PainterQB.AWG5014CModule  # etc.\n\nawg = AWG5014C(tcpip_socket( 1.2.3.4 ,5000))\nats = AlazarATS9360()\n\n# do something with awg and ats", 
            "title": "Quick start"
        }, 
        {
            "location": "/#to-do", 
            "text": "Globally   Units! A good starting point would be the SIUnits.jl  package. It currently does\nnot support fractional units like V/sqrt(Hz) but support could be added.  How to save / load configurations for instruments? Maybe JSON files?  How to save / load data?  Plotting ease-of-use features?   AWG5014C   Waveform methods could be made more Julian  Sequencer support needed   Alazar   Some properties seem to be overwritten when switching between measurement\nmodes. e.g. when measuring a ContinuousStreamResponse the trigger needs to be\nreconfigured before measuring a TriggeredStreamResponse.", 
            "title": "To do"
        }, 
        {
            "location": "/design/", 
            "text": "Design overview\n\n\nWhat is an instrument?\n\n\nabstract Instrument\n\n\nFor the purposes of this package, an instrument is just something connected to the\ncomputer that we need to communicate with, and which can source or measure something.\nEvery instrument may connect to the computer by different hardware,\ncomms protocols, and command dialects.\n\n\nAll instruments are Julia objects, subtypes of the abstract type \nInstrument\n.\n\n\nInstrument types\n\n\nMany instruments share the same communications protocols. We subtype \nInstrument\n\nbased on these protocols.\n\n\nVISA\n\n\nabstract InstrumentVISA \n: Instrument\n\n\nMany instruments are able to be addressed using the\n\nVISA\n standard (Virtual\nInstrument Software Architecture), currently maintained by the IVI Foundation.\n\n\nTo talk to VISA instruments will require the Julia package \nVISA.jl\n\nas well as the \nNational Instruments VISA libraries\n.\nInstallation instructions are available at each link.\n\n\nAlazar digitizers\n\n\nabstract InstrumentAlazar \n: Instrument\n\n\nDigitizers made by \nAlazarTech\n are notably \nnot\n\ncompatible with the VISA standard. The VISA standard was probably not intended\nfor PCIe cards with extreme data throughput. All Alazar digitizers are addressable by an API\nsupplied by the company, which talks to the card through a shared library (think .dll on\nWindows or .so on Linux).\n\n\nThe shared library files and API documentation are only available from AlazarTech.\n\n\nHow do we configure instruments?\n\n\nProperties\n\n\nInstrument properties are configured and inspected using two functions,\n\nconfigure\n and \ninspect\n. Why not \nset\n and \nget\n? Ultimately these verbs are\npretty generic and often have implicit meanings in other programming languages.\nIn C, for instance, \nget\n often implies that the function will return an address\nin memory rather than a value.\n\n\nBoth \nconfigure\n and \ninspect\n have a lot of methods that take as one of their\narguments an \nInstrumentProperty\n subtype:\n\n\nabstract InstrumentProperty\nabstract NumericalProperty \n: InstrumentProperty\n\n\n\n\n\nOne subtypes \nInstrumentProperty\n for properties such as \nClockSource\n, the\nlogical states of which have no obvious consistent encoding. One should instead\nsubtype \nNumericalProperty\n for properties where a number suffices to describe\nthe property (up to units).\n\n\nProperties which may be shared by multiple instruments should be defined in\n\nsrc/InstrumentDefs.jl\n. Examples include \nFrequency\n, \nPower\n, \nSampleRate\n, etc.\nThey may be imported in each instrument's module as needed. Properties specific\nto a given instrument may of course be defined in that instrument's module.\n\n\nA design choice was for \nconfigure\n and \ninspect\n to take types rather than\nobjects. Two examples:\n\n\nconfigure(awg, RisingTrigger) # not RisingTrigger()\nconfigure(awg, SampleRate, 10e6) # not SampleRate() or SampleRate(10e6)\n\n\n\n\n\nHow do we take measurements?\n\n\nSource and measure\n\n\nTwo functions are provided to abstract away many kinds of measurements: \nsource\n\nand \nmeasure\n. In an experiment you source some stimulus and measure a response.\nTherefore \nsource\n takes as an argument an object matching type signature\n\nStimulus\n, which can have different fields for different types of stimuli, as\nwell as some value. \nmeasure\n takes as an argument an object matching type\nsignature \nResponse\n. The idea is to write new subtypes of \nStimulus\n and \nResponse\n\nto describe what you are doing, as well as new methods for \nsource\n and \nmeasure\n.\nThis will become clearer below when discussing measurement archetypes.\n\n\nStimuli\n\n\nabstract Stimulus\n\n\nAll stimuli are objects, subtyped from the abstract \nStimulus\n type.\nMany common stimuli are already provided. In fact, a great deal of functionality\nis provided by the \nPropertyStimulus\n type, which allows any \nNumericalProperty\n\nto act as a \nStimulus\n. Consider the following example, where we make a\n\nPropertyStimulus\n for sweeping the frequency of our E8257D signal generator:\n\n\nstim\n \n=\n \nPropertyStimulus\n(\nsiggen\n::\nE8257D\n,\n \nFrequency\n)\n\n\nfor\n \nfreq\n \nin\n \n1e9\n:\n1e8\n:\n5e9\n\n    \nsource\n(\nstim\n,\n \nfreq\n)\n\n    \n# measure(something)\n\n\nend\n\n\n\n\n\n\nStimuli need not be tied to a particular property. Rather, this is just one\nconvenient and easily generalized example.\n\n\nNot all stimuli are associated with a physical instrument. For instance, sourcing a\n\nDelayStimulus\n will cause the script to block until a specified time after\ncreation of the \nDelayStimulus\n object.\nPerhaps in this case the instrument is the computer itself, but in the\nimplementation, a \nDelayStimulus\n object has no field matching type signature\n\nInstrument\n.\n\n\nWe have seen that a stimulus need not even be associated with an \nInstrument\n. It\nstands to reason that in principle they could be associated with several \nInstrument\n\nobjects. Maybe a stimulus that makes sense for a particular experiment would be\nto change all gate voltages at once. If these gate voltages are sourced by several\nphysical instruments, then several \nInstrument\ns should be fields in a new\n\nStimulus\n subtype.\n\n\nResponses\n\n\nabstract Response{T}\n\n\nUnlike stimuli, all responses are subtypes of an abstract parametric type,\n\nResponse{T}\n. Although it may seem unduly abstract to have it be both abstract\nand parametric, we use this\nfunctionality to distinguish between desired return types of a measurement.\nSuppose an instrument provides data in some kind of awkward format, like 12-bit\nunsigned integers. For reasons of convenience we may want the measurement to\nreturn the data in a machine-native \nInt64\n format, or we may want to specify\na linear or 2D shape for the data, etc.\n\n\nAn important consideration in writing fast Julia code is to ensure type stability.\nIn other words, the type that is returned from a function should depend only on\nthe method signature and not depend on some value at run-time. By parameterizing\n\nResponse\n types with the return type, we can ensure that \nmeasure\n will be\ntype stable. If we instead had the desired return type as some field\nin a \nResponse\n object, then \nmeasure\n would not be type stable.\n\n\nAlazar digitizers\n\n\nA response type is given for each measurement mode:\ncontinuous streaming (\nContinuousStreamResponse\n), triggered streaming (\n\nTriggeredStreamResponse\n), NPT records (\nNPTRecordResponse\n),\nand FPGA-based FFT calculations (\nFFTHardwareResponse\n).\nTraditional record mode has not been implemented yet for lack of immediate need.\n\n\nLooking at the source code, it would\nseem that there is some redundancy in the types, for instance there is an\n\nNPTRecordMode\n and an \nNPTRecordResponse\n object. The difference is that the\nformer is used internally in the code to denote a particular method of configuring\nthe instrument, allocating buffers, etc., whereas the latter specifies what you\nactually want to do: retrieve NPT records from the digitizer, perhaps doing\nsome post-processing or processing during acquisition along the way. Perhaps\ndifferent responses would dictate different processing behavior, while the\ninstrument is ultimately configured the same way.\n\n\nMiscellaneous\n\n\nResponses need not come from instruments. For test purposes, suppose we want to\nmimic a measurement by generating random numbers. \nRandomResponse\n produces a\nrandom number in the unit interval when it is measured. A \nTimerResponse\n will\nmeasure the time since creation of the \nTimerResponse\n object.\n\n\nFeedback loops\n\n\nIn principle, asynchronous software feedback loops could be implemented\nwith the \nReactive.jl\n package. This\nwould probably only be suitable for slowly varying signals, e.g. PID temperature\ncontrol. Ultimately benchmarking needs to be done to determine how useful\nthis approach would be.\n\n\nMeasurement archetypes\n\n\nNow that we have abstracted \nsource\n and \nmeasure\n, we can think about archetypal\nmeasurement schemes. Often we want to do a 1D sweep:\n\n\n#\n \nJust\n \nan\n \nexample\n;\n \nnot\n \nnecessarily\n \nimplemented\n \nthis\n \nway\n...\n\n\nfunction\n \nsweep1d\n(\nstimulus\n::\nStimulus\n,\n \nresponse\n::\nResponse\n,\n \niterator\n)\n\n    \na\n \n=\n \nArray\n()\n\n    \nfor\n \nvalue\n \nin\n \niterator\n\n        \nsource\n(\nstimulus\n,\nvalue\n)\n\n        \nr\n \n=\n \nmeasure\n(\nresponse\n)\n\n        \npush\n!\n(\na\n,\nr\n)\n\n    \nend\n\n    \nreturn\n \na\n\n\nend\n\n\n\n\n\n\nIt is clear that in most cases this single 1D sweep function will suffice for\nany kind of 1D sweep we want to do. This is a compelling reason to write\nmeasurement code in a language that natively supports mulitple dispatch, such as\nJulia.", 
            "title": "Design"
        }, 
        {
            "location": "/design/#design-overview", 
            "text": "", 
            "title": "Design overview"
        }, 
        {
            "location": "/design/#what-is-an-instrument", 
            "text": "abstract Instrument  For the purposes of this package, an instrument is just something connected to the\ncomputer that we need to communicate with, and which can source or measure something.\nEvery instrument may connect to the computer by different hardware,\ncomms protocols, and command dialects.  All instruments are Julia objects, subtypes of the abstract type  Instrument .  Instrument types  Many instruments share the same communications protocols. We subtype  Instrument \nbased on these protocols.  VISA  abstract InstrumentVISA  : Instrument  Many instruments are able to be addressed using the VISA  standard (Virtual\nInstrument Software Architecture), currently maintained by the IVI Foundation.  To talk to VISA instruments will require the Julia package  VISA.jl \nas well as the  National Instruments VISA libraries .\nInstallation instructions are available at each link.  Alazar digitizers  abstract InstrumentAlazar  : Instrument  Digitizers made by  AlazarTech  are notably  not \ncompatible with the VISA standard. The VISA standard was probably not intended\nfor PCIe cards with extreme data throughput. All Alazar digitizers are addressable by an API\nsupplied by the company, which talks to the card through a shared library (think .dll on\nWindows or .so on Linux).  The shared library files and API documentation are only available from AlazarTech.", 
            "title": "What is an instrument?"
        }, 
        {
            "location": "/design/#how-do-we-configure-instruments", 
            "text": "Properties  Instrument properties are configured and inspected using two functions, configure  and  inspect . Why not  set  and  get ? Ultimately these verbs are\npretty generic and often have implicit meanings in other programming languages.\nIn C, for instance,  get  often implies that the function will return an address\nin memory rather than a value.  Both  configure  and  inspect  have a lot of methods that take as one of their\narguments an  InstrumentProperty  subtype:  abstract InstrumentProperty\nabstract NumericalProperty  : InstrumentProperty  One subtypes  InstrumentProperty  for properties such as  ClockSource , the\nlogical states of which have no obvious consistent encoding. One should instead\nsubtype  NumericalProperty  for properties where a number suffices to describe\nthe property (up to units).  Properties which may be shared by multiple instruments should be defined in src/InstrumentDefs.jl . Examples include  Frequency ,  Power ,  SampleRate , etc.\nThey may be imported in each instrument's module as needed. Properties specific\nto a given instrument may of course be defined in that instrument's module.  A design choice was for  configure  and  inspect  to take types rather than\nobjects. Two examples:  configure(awg, RisingTrigger) # not RisingTrigger()\nconfigure(awg, SampleRate, 10e6) # not SampleRate() or SampleRate(10e6)", 
            "title": "How do we configure instruments?"
        }, 
        {
            "location": "/design/#how-do-we-take-measurements", 
            "text": "Source and measure  Two functions are provided to abstract away many kinds of measurements:  source \nand  measure . In an experiment you source some stimulus and measure a response.\nTherefore  source  takes as an argument an object matching type signature Stimulus , which can have different fields for different types of stimuli, as\nwell as some value.  measure  takes as an argument an object matching type\nsignature  Response . The idea is to write new subtypes of  Stimulus  and  Response \nto describe what you are doing, as well as new methods for  source  and  measure .\nThis will become clearer below when discussing measurement archetypes.  Stimuli  abstract Stimulus  All stimuli are objects, subtyped from the abstract  Stimulus  type.\nMany common stimuli are already provided. In fact, a great deal of functionality\nis provided by the  PropertyStimulus  type, which allows any  NumericalProperty \nto act as a  Stimulus . Consider the following example, where we make a PropertyStimulus  for sweeping the frequency of our E8257D signal generator:  stim   =   PropertyStimulus ( siggen :: E8257D ,   Frequency )  for   freq   in   1e9 : 1e8 : 5e9 \n     source ( stim ,   freq ) \n     # measure(something)  end   Stimuli need not be tied to a particular property. Rather, this is just one\nconvenient and easily generalized example.  Not all stimuli are associated with a physical instrument. For instance, sourcing a DelayStimulus  will cause the script to block until a specified time after\ncreation of the  DelayStimulus  object.\nPerhaps in this case the instrument is the computer itself, but in the\nimplementation, a  DelayStimulus  object has no field matching type signature Instrument .  We have seen that a stimulus need not even be associated with an  Instrument . It\nstands to reason that in principle they could be associated with several  Instrument \nobjects. Maybe a stimulus that makes sense for a particular experiment would be\nto change all gate voltages at once. If these gate voltages are sourced by several\nphysical instruments, then several  Instrument s should be fields in a new Stimulus  subtype.  Responses  abstract Response{T}  Unlike stimuli, all responses are subtypes of an abstract parametric type, Response{T} . Although it may seem unduly abstract to have it be both abstract\nand parametric, we use this\nfunctionality to distinguish between desired return types of a measurement.\nSuppose an instrument provides data in some kind of awkward format, like 12-bit\nunsigned integers. For reasons of convenience we may want the measurement to\nreturn the data in a machine-native  Int64  format, or we may want to specify\na linear or 2D shape for the data, etc.  An important consideration in writing fast Julia code is to ensure type stability.\nIn other words, the type that is returned from a function should depend only on\nthe method signature and not depend on some value at run-time. By parameterizing Response  types with the return type, we can ensure that  measure  will be\ntype stable. If we instead had the desired return type as some field\nin a  Response  object, then  measure  would not be type stable.  Alazar digitizers  A response type is given for each measurement mode:\ncontinuous streaming ( ContinuousStreamResponse ), triggered streaming ( TriggeredStreamResponse ), NPT records ( NPTRecordResponse ),\nand FPGA-based FFT calculations ( FFTHardwareResponse ).\nTraditional record mode has not been implemented yet for lack of immediate need.  Looking at the source code, it would\nseem that there is some redundancy in the types, for instance there is an NPTRecordMode  and an  NPTRecordResponse  object. The difference is that the\nformer is used internally in the code to denote a particular method of configuring\nthe instrument, allocating buffers, etc., whereas the latter specifies what you\nactually want to do: retrieve NPT records from the digitizer, perhaps doing\nsome post-processing or processing during acquisition along the way. Perhaps\ndifferent responses would dictate different processing behavior, while the\ninstrument is ultimately configured the same way.  Miscellaneous  Responses need not come from instruments. For test purposes, suppose we want to\nmimic a measurement by generating random numbers.  RandomResponse  produces a\nrandom number in the unit interval when it is measured. A  TimerResponse  will\nmeasure the time since creation of the  TimerResponse  object.  Feedback loops  In principle, asynchronous software feedback loops could be implemented\nwith the  Reactive.jl  package. This\nwould probably only be suitable for slowly varying signals, e.g. PID temperature\ncontrol. Ultimately benchmarking needs to be done to determine how useful\nthis approach would be.", 
            "title": "How do we take measurements?"
        }, 
        {
            "location": "/design/#measurement-archetypes", 
            "text": "Now that we have abstracted  source  and  measure , we can think about archetypal\nmeasurement schemes. Often we want to do a 1D sweep:  #   Just   an   example ;   not   necessarily   implemented   this   way ...  function   sweep1d ( stimulus :: Stimulus ,   response :: Response ,   iterator ) \n     a   =   Array () \n     for   value   in   iterator \n         source ( stimulus , value ) \n         r   =   measure ( response ) \n         push ! ( a , r ) \n     end \n     return   a  end   It is clear that in most cases this single 1D sweep function will suffice for\nany kind of 1D sweep we want to do. This is a compelling reason to write\nmeasurement code in a language that natively supports mulitple dispatch, such as\nJulia.", 
            "title": "Measurement archetypes"
        }, 
        {
            "location": "/implementation/", 
            "text": "Implementation overview\n\n\nCode organization\n\n\nOrganizing the code into Julia modules is tricky and the organization may change\nin future releases. It would not be surprising if the way Julia implements modules\nchanges before Julia v1.0.\n\n\n\n\nWith few exceptions, all code is kept inside a single package. For now the\npackage is unregistered and must be retrieved from the repository with\n\nPkg.clone()\n rather than \nPkg.add()\n.\n\n\nLow-level wrappers for shared libraries are kept in their own packages\n(e.g. VISA and Alazar calls). This way, at least some code can be reused if\nsomeone else does not want to use our codebase.\n\n\n\n\n\n\nAll code is kept inside a \"main\" \nPainterQB\n module, defined inside \nsrc/PainterQB.jl\n.\n\n\nCommon instrument definitions and functions are defined in \nsrc/Definitions.jl\n.\n\n\nInstrumentVISA\n and associated functions are defined in \nsrc/VISA.jl\n.\n\n\nCode that should be loaded by Julia workers for parallel processing is\nactually kept outside the module to avoid loading the whole module unnecessarily.\nThese are typically functions that are focused on number crunching and don't\nneed to know much about the internals of PainterQB.\n\n\n\n\n\n\nEach instrument is defined within its own module, a submodule of \nPainterQB\n.\n\n\nEach instrument has a corresponding .jl file in \nsrc/instruments\n.\n\n\nInstrument model numbers are used for type definitions (e.g. \nAWG5014C\n),\nso module names have \"Module\" appended (e.g. \nAWG5014CModule\n). We put all\nAlazar digitizers in \nAlazarModule\n; the feature set and API is so similar\nfor the various models that just one module makes sense.\n\n\nexport\n statements from an instrument submodule are not currently exported\nfrom \nPainterQB\n. The statement \nusing PainterQB.AWG5014CModule\n\nmay be desired when using the AWG, for instance.\n\n\n\n\n\n\nTo test for possible namespace conflicts when adding new instruments,\nuncomment the \nimportall\n statements in \nsrc/PainterQB.jl\n.\n\n\nAs functions from different instrument modules are imported, any functions\nthat are defined in different modules will be printed and warned about. The\nsolution is to define the shared function name in \nsrc/Definitions.jl\n\n(\nglobal\n and \nexport\n) such that the submodules can both import the function.\n\n\n\n\n\n\n\n\nVISA instruments\n\n\nMany commercial instruments support a common communications protocol and command\nsyntax (VISA and SCPI respectively). For such instruments, many methods for\n\nconfigure\n and \ninspect\n can be generated with metaprogramming, rather than\ntyping them out explicitly. The implementation could and should be done\nmore elegantly, but it seems to work for now.\n\n\nThe file \nsrc/Metaprogramming.jl\n is included in each VISA\ninstrument's source file, and therefore in each instrument's own module.\nInitially this file was included directly in the PainterQB module, but it seems\nthere are subtleties regarding the use of the \n@eval\n macro between modules.\n\n\nMetaprogramming\n\n\ngenerate_inspect\n\n\ngenerate_inspect{S\n:Instrument,T\n:InstrumentProperty}(instype::Type{S},\n        command::ASCIIString, proptype::Type{T}, returntype...)\n\n\n\n\n\nThis command takes an \nInstrument\n subtype \ninstype\n, a VISA command, an\n\nInstrumentProperty\n subtype \nproptype\n, and possibly an argument. It will\ngenerate the following method in the module where \ngenerate_inspect\n is defined:\n\n\ninspect(ins::instype, ::Type{proptype}, infixes::Int...)\n\n\nThe \ninfixes\n variable argument allows for numbers to be inserted within the\ncommands, for instance in \nOUTP#:FILT:FREQ\n, where the \n#\n sign should be\nreplaced by an integer. The replacements are done in the order of the arguments.\nError checking is done on the number of arguments.\n\n\nFor a given property, \ninspect\n will return either an InstrumentProperty subtype,\na number, a boolean, or a string as appropriate.\n\n\ngenerate_configure\n\n\ngenerate_configure{S\n:Instrument,T\n:InstrumentProperty}(instype::Type{S},\n        command::ASCIIString, proptype::Type{T}, returntype...)\n\n\n\n\n\nThis command takes an \nInstrument\n subtype \nInsType\n, a VISA command, an\n\nInstrumentProperty\n type, and possibly an argument. It will generate one of the\nfollowing methods in the module where \ngenerate_inspect\n is defined:\n\n\nconfigure(ins::InsType, PropertySubtype)\nconfigure(ins::InsType, Property, values..., infixes...)\n\n\n\n\n\ngenerate_properties\n\n\ngenerate_properties{S\n:InstrumentProperty}(subtype::Symbol, supertype::Type{S})\n\n\n\n\n\nThis makes it easy to generate new \nInstrumentProperty\n subtypes. Typically\nthis function is called inside a for loop. Calling this function is equivalent\nto writing the following pseudocode:\n\n\nimmutable subtype{T} \n: supertype\nend\n\nexport subtype\n\n\n\n\n\ngenerate_handlers\n\n\ngenerate_handlers{T\n:Instrument}(insType::Type{T}, responseDict::Dict)\n\n\n\n\n\nEach instrument can have a \nresponseDict\n. For each setting of the instrument,\nfor instance the \nClockSource\n, we need to know the correspondence between a\nlogical state \nExternalClock\n and how the instrument encodes that logical state\n(e.g. \"EXT\").\nThe \nresponseDict\n is actually a dictionary of dictionaries. The first level keys\nare like \nClockSource\n and the second level keys are like \"EXT\", with the value\nbeing \n:ExternalClock\n. Undoubtedly\nthis nested dictionary is \"nasty\" (in the technical parlance) but the dictionary\nis only used for code\ncreation and is not used at run-time (if the code works as intended).\n\n\nThis function makes a lot of other functions. Given some response from an instrument,\nwe require a function to map that response back on to the appropiate logical state.\n\n\nClockSource(ins::AWG5014C, res::AbstractString)\n\nreturns an \nInternalClock\n or \nExternalClock\n type as appropriate,\nbased on the logical meaning of the response.\n\n\nWe also want a function to generate logical states without having to know the way\nthey are encoded by the instrument.\n\n\ncode(ins::AWG5014C, ::Type{InternalClock})\n returns \"INT\",\nwith \"INT\" encoding how to pass this logical state to the instrument \nins\n.\n\n\nAlazar instruments\n\n\nIn the following discussion, it is important to understand some Alazar terminology.\nNewer Alazar digitizers use direct memory access (DMA) to stream data into\na computer's RAM. A single \nacquisition\n uses one or many \nbuffers\n, which\nconstitute preallocated regions in the computer's physical memory. Each buffer\ncontains one or many \nrecords\n. Each \nrecord\n contains many \nsamples\n,\nwhich are the voltages measured by the digitizer.\n\n\nIn streaming mode, there is only one record per buffer, but in other modes there\ncan be many records per buffer.\n\n\nBuffer allocation\n\n\nDigitizer requirements\n\n\nThe Alazar digitizers expect buffers in physical memory which are page-aligned.\nThe size of each buffer should also be chosen appropriately.\n\n\nThe behavior of the digitizer is not specified when the buffer is made larger\nthan 64 MB. On our computer, it seems like an \nApiWaitTimeout\n error is thrown\nwhen the buffer is too large (for some unspecified definition of \"large\" greater\nthan 64 MB). The digitizer will then throw \nApiInsufficientResources\n errors\nwhenever another acquisition is attempted, until the computer is restarted.\nJust restarting the Julia kernel, forcing a reload of the Alazar DLLs,\ndoes not appear to be enough to reset the digitizer fully.\n\n\nFor performance reasons, a buffer should not be made much smaller than 1 MB if\nmulitple buffers are required.\nThere is also a minimum record size for each model of digitizer. For the ATS9360,\nif a record has fewer than 256 samples (could be 128 from channel A + 128 from channel B)\nthen the acquisition will proceed, but return garbage data. Allocating too small\nof a buffer is therefore still bad, but less fatal than allocating one that is too large.\n\n\n\n\n\nHow to allocate appropriate buffers in Julia\n\n\nIn Julia, just allocating a fixed-size array will not necessarily return a\npage-aligned block in memory. One approach would be to allocate our own page-aligned\nmemory using \nvalloc\n and \nvfree\n (or their Windows equivalents).\n\n\nfunction\n \nvirtualalloc\n{\nT\n:\nUnion\n{\nUInt8\n,\nUInt16\n}}(\nsize_bytes\n::\nInteger\n,\n \n::\nType\n{\nT\n})\n\n    \n@\nwindows\n?\n \nbegin\n\n        \nMEM_COMMIT\n \n=\n \nU32\n(\n0x1000\n)\n\n        \nPAGE_READWRITE\n \n=\n \nU32\n(\n0x4\n)\n\n        \naddr\n \n=\n \nccall\n((\n:\nVirtualAlloc\n,\n \nKernel32\n),\n \nPtr\n{\nT\n},\n\n                     \n(\nPtr\n{\nVoid\n},\n \nCulonglong\n,\n \nCulong\n,\n \nCulong\n),\n\n                     \nC_NULL\n,\n \nsize_bytes\n,\n \nMEM_COMMIT\n,\n \nPAGE_READWRITE\n)\n\n    \nend\n \n:\n \n(\n@\nlinux\n?\n \nbegin\n\n        \naddr\n \n=\n \nccall\n((\n:\nvalloc\n,\n \nlibc\n),\n \nPtr\n{\nT\n},\n \n(\nCulonglong\n,),\n \nsize_bytes\n)\n\n    \nend\n \n:\n \nthrow\n(\nSystemError\n()))\n\n\n    \naddr\n \n==\n \nC_NULL\n \n \nthrow\n(\nOutOfMemoryError\n())\n\n\n    \naddr\n::\nPtr\n{\nT\n}\n\n\nend\n\n\n\nfunction\n \nvirtualfree\n{\nT\n:\nUnion\n{\nUInt16\n,\nUInt8\n}}(\naddr\n::\nPtr\n{\nT\n})\n\n    \n@\nwindows\n?\n \nbegin\n\n        \nMEM_RELEASE\n \n=\n \n0x8000\n\n        \nccall\n((\n:\nVirtualFree\n,\n \nKernel32\n),\n \nCint\n,\n \n(\nPtr\n{\nVoid\n},\n \nCulonglong\n,\n \nCulong\n),\n\n            \naddr\n,\n \nCulonglong\n(\n0\n),\n \nMEM_RELEASE\n)\n\n    \nend\n \n:\n \n(\n@\nlinux\n?\n \nbegin\n\n        \nccall\n((\n:\nfree\n,\n \nlibc\n),\n \nVoid\n,\n \n(\nPtr\n{\nVoid\n},),\n \naddr\n)\n\n    \nend\n \n:\n \nthrow\n(\nSystemError\n()))\n\n    \nnothing\n\n\nend\n\n\n\n\n\n\nIn case it wasn't obvious, this was my original approach.\nNote that memory allocated in this way will not be visible to multiple processes\nwithout extra work, and moreover we will need to deallocate the memory ourselves\nat a later time, perhaps using \nfinalizer()\n if the memory is made to be part of\na Julia object.\n\n\nFortunately, there is a special kind of array in Julia called the \nSharedArray\n.\nIt can be viewed and modified from multiple processes, and the memory is page-aligned.\nHopefully this continues to be the case in future Julia releases.\nWe implement a type called the \nDMABufferArray\n whose definition is worth\nrepeating here:\n\n\ntype DMABufferArray{sample_type} \n:\n        AbstractArray{Ptr{sample_type},1}\n\n    bytes_buf::Int\n    n_buf::Int\n    backing::SharedArray{sample_type}\n\n    DMABufferArray(bytes_buf, n_buf) = begin\n        n_buf \n 1 \n bytes_buf % Base.Mmap.PAGESIZE != 0 \n\n            error(\nBytes per buffer must be a multiple of Base.Mmap.PAGESIZE when \n,\n                  \nthere is more than one buffer.\n)\n\n        backing = SharedArray(sample_type,\n                        Int((bytes_buf * n_buf) / sizeof(sample_type)))\n\n        dmabuf = new(bytes_buf,\n                     n_buf,\n                     backing)\n\n        return dmabuf\n    end\n\nend\n\nBase.size(dma::DMABufferArray) = (dma.n_buf,)\nBase.linearindexing(::Type{DMABufferArray}) = Base.LinearFast()\nBase.getindex(dma::DMABufferArray, i::Int) =\n    pointer(dma.backing) + (i-1) * dma.bytes_buf\nBase.length(dma::DMABufferArray) = dma.n_buf\n\nbytespersample{T}(buf_array::DMABufferArray{T}) = sizeof(T)\nsampletype{T}(buf_array::DMABufferArray{T}) = T\n\n\n\n\n\nSome comments:\n\n\n\n\nA single SharedArray is used to back \nall\n DMA buffers. Memory is therefore\ncontiguous and page-aligned.\n\n\nThe memory for each DMA buffer is required to be a multiple of the page size\nwhen there is more than one buffer.\n\n\nThe memory can be accessed by multiple processes.\n\n\nThe elements of a \nDMABufferArray\n are pointers to the the different\nlocations in memory which act as DMA buffers. The array is iterable and indexable\nas usual.", 
            "title": "Implementation"
        }, 
        {
            "location": "/implementation/#implementation-overview", 
            "text": "", 
            "title": "Implementation overview"
        }, 
        {
            "location": "/implementation/#code-organization", 
            "text": "Organizing the code into Julia modules is tricky and the organization may change\nin future releases. It would not be surprising if the way Julia implements modules\nchanges before Julia v1.0.   With few exceptions, all code is kept inside a single package. For now the\npackage is unregistered and must be retrieved from the repository with Pkg.clone()  rather than  Pkg.add() .  Low-level wrappers for shared libraries are kept in their own packages\n(e.g. VISA and Alazar calls). This way, at least some code can be reused if\nsomeone else does not want to use our codebase.    All code is kept inside a \"main\"  PainterQB  module, defined inside  src/PainterQB.jl .  Common instrument definitions and functions are defined in  src/Definitions.jl .  InstrumentVISA  and associated functions are defined in  src/VISA.jl .  Code that should be loaded by Julia workers for parallel processing is\nactually kept outside the module to avoid loading the whole module unnecessarily.\nThese are typically functions that are focused on number crunching and don't\nneed to know much about the internals of PainterQB.    Each instrument is defined within its own module, a submodule of  PainterQB .  Each instrument has a corresponding .jl file in  src/instruments .  Instrument model numbers are used for type definitions (e.g.  AWG5014C ),\nso module names have \"Module\" appended (e.g.  AWG5014CModule ). We put all\nAlazar digitizers in  AlazarModule ; the feature set and API is so similar\nfor the various models that just one module makes sense.  export  statements from an instrument submodule are not currently exported\nfrom  PainterQB . The statement  using PainterQB.AWG5014CModule \nmay be desired when using the AWG, for instance.    To test for possible namespace conflicts when adding new instruments,\nuncomment the  importall  statements in  src/PainterQB.jl .  As functions from different instrument modules are imported, any functions\nthat are defined in different modules will be printed and warned about. The\nsolution is to define the shared function name in  src/Definitions.jl \n( global  and  export ) such that the submodules can both import the function.", 
            "title": "Code organization"
        }, 
        {
            "location": "/implementation/#visa-instruments", 
            "text": "Many commercial instruments support a common communications protocol and command\nsyntax (VISA and SCPI respectively). For such instruments, many methods for configure  and  inspect  can be generated with metaprogramming, rather than\ntyping them out explicitly. The implementation could and should be done\nmore elegantly, but it seems to work for now.  The file  src/Metaprogramming.jl  is included in each VISA\ninstrument's source file, and therefore in each instrument's own module.\nInitially this file was included directly in the PainterQB module, but it seems\nthere are subtleties regarding the use of the  @eval  macro between modules.  Metaprogramming  generate_inspect  generate_inspect{S :Instrument,T :InstrumentProperty}(instype::Type{S},\n        command::ASCIIString, proptype::Type{T}, returntype...)  This command takes an  Instrument  subtype  instype , a VISA command, an InstrumentProperty  subtype  proptype , and possibly an argument. It will\ngenerate the following method in the module where  generate_inspect  is defined:  inspect(ins::instype, ::Type{proptype}, infixes::Int...)  The  infixes  variable argument allows for numbers to be inserted within the\ncommands, for instance in  OUTP#:FILT:FREQ , where the  #  sign should be\nreplaced by an integer. The replacements are done in the order of the arguments.\nError checking is done on the number of arguments.  For a given property,  inspect  will return either an InstrumentProperty subtype,\na number, a boolean, or a string as appropriate.  generate_configure  generate_configure{S :Instrument,T :InstrumentProperty}(instype::Type{S},\n        command::ASCIIString, proptype::Type{T}, returntype...)  This command takes an  Instrument  subtype  InsType , a VISA command, an InstrumentProperty  type, and possibly an argument. It will generate one of the\nfollowing methods in the module where  generate_inspect  is defined:  configure(ins::InsType, PropertySubtype)\nconfigure(ins::InsType, Property, values..., infixes...)  generate_properties  generate_properties{S :InstrumentProperty}(subtype::Symbol, supertype::Type{S})  This makes it easy to generate new  InstrumentProperty  subtypes. Typically\nthis function is called inside a for loop. Calling this function is equivalent\nto writing the following pseudocode:  immutable subtype{T}  : supertype\nend\n\nexport subtype  generate_handlers  generate_handlers{T :Instrument}(insType::Type{T}, responseDict::Dict)  Each instrument can have a  responseDict . For each setting of the instrument,\nfor instance the  ClockSource , we need to know the correspondence between a\nlogical state  ExternalClock  and how the instrument encodes that logical state\n(e.g. \"EXT\").\nThe  responseDict  is actually a dictionary of dictionaries. The first level keys\nare like  ClockSource  and the second level keys are like \"EXT\", with the value\nbeing  :ExternalClock . Undoubtedly\nthis nested dictionary is \"nasty\" (in the technical parlance) but the dictionary\nis only used for code\ncreation and is not used at run-time (if the code works as intended).  This function makes a lot of other functions. Given some response from an instrument,\nwe require a function to map that response back on to the appropiate logical state.  ClockSource(ins::AWG5014C, res::AbstractString) \nreturns an  InternalClock  or  ExternalClock  type as appropriate,\nbased on the logical meaning of the response.  We also want a function to generate logical states without having to know the way\nthey are encoded by the instrument.  code(ins::AWG5014C, ::Type{InternalClock})  returns \"INT\",\nwith \"INT\" encoding how to pass this logical state to the instrument  ins .", 
            "title": "VISA instruments"
        }, 
        {
            "location": "/implementation/#alazar-instruments", 
            "text": "In the following discussion, it is important to understand some Alazar terminology.\nNewer Alazar digitizers use direct memory access (DMA) to stream data into\na computer's RAM. A single  acquisition  uses one or many  buffers , which\nconstitute preallocated regions in the computer's physical memory. Each buffer\ncontains one or many  records . Each  record  contains many  samples ,\nwhich are the voltages measured by the digitizer.  In streaming mode, there is only one record per buffer, but in other modes there\ncan be many records per buffer.  Buffer allocation  Digitizer requirements  The Alazar digitizers expect buffers in physical memory which are page-aligned.\nThe size of each buffer should also be chosen appropriately.  The behavior of the digitizer is not specified when the buffer is made larger\nthan 64 MB. On our computer, it seems like an  ApiWaitTimeout  error is thrown\nwhen the buffer is too large (for some unspecified definition of \"large\" greater\nthan 64 MB). The digitizer will then throw  ApiInsufficientResources  errors\nwhenever another acquisition is attempted, until the computer is restarted.\nJust restarting the Julia kernel, forcing a reload of the Alazar DLLs,\ndoes not appear to be enough to reset the digitizer fully.  For performance reasons, a buffer should not be made much smaller than 1 MB if\nmulitple buffers are required.\nThere is also a minimum record size for each model of digitizer. For the ATS9360,\nif a record has fewer than 256 samples (could be 128 from channel A + 128 from channel B)\nthen the acquisition will proceed, but return garbage data. Allocating too small\nof a buffer is therefore still bad, but less fatal than allocating one that is too large.   How to allocate appropriate buffers in Julia  In Julia, just allocating a fixed-size array will not necessarily return a\npage-aligned block in memory. One approach would be to allocate our own page-aligned\nmemory using  valloc  and  vfree  (or their Windows equivalents).  function   virtualalloc { T : Union { UInt8 , UInt16 }}( size_bytes :: Integer ,   :: Type { T }) \n     @ windows ?   begin \n         MEM_COMMIT   =   U32 ( 0x1000 ) \n         PAGE_READWRITE   =   U32 ( 0x4 ) \n         addr   =   ccall (( : VirtualAlloc ,   Kernel32 ),   Ptr { T }, \n                      ( Ptr { Void },   Culonglong ,   Culong ,   Culong ), \n                      C_NULL ,   size_bytes ,   MEM_COMMIT ,   PAGE_READWRITE ) \n     end   :   ( @ linux ?   begin \n         addr   =   ccall (( : valloc ,   libc ),   Ptr { T },   ( Culonglong ,),   size_bytes ) \n     end   :   throw ( SystemError ())) \n\n     addr   ==   C_NULL     throw ( OutOfMemoryError ()) \n\n     addr :: Ptr { T }  end  function   virtualfree { T : Union { UInt16 , UInt8 }}( addr :: Ptr { T }) \n     @ windows ?   begin \n         MEM_RELEASE   =   0x8000 \n         ccall (( : VirtualFree ,   Kernel32 ),   Cint ,   ( Ptr { Void },   Culonglong ,   Culong ), \n             addr ,   Culonglong ( 0 ),   MEM_RELEASE ) \n     end   :   ( @ linux ?   begin \n         ccall (( : free ,   libc ),   Void ,   ( Ptr { Void },),   addr ) \n     end   :   throw ( SystemError ())) \n     nothing  end   In case it wasn't obvious, this was my original approach.\nNote that memory allocated in this way will not be visible to multiple processes\nwithout extra work, and moreover we will need to deallocate the memory ourselves\nat a later time, perhaps using  finalizer()  if the memory is made to be part of\na Julia object.  Fortunately, there is a special kind of array in Julia called the  SharedArray .\nIt can be viewed and modified from multiple processes, and the memory is page-aligned.\nHopefully this continues to be the case in future Julia releases.\nWe implement a type called the  DMABufferArray  whose definition is worth\nrepeating here:  type DMABufferArray{sample_type}  :\n        AbstractArray{Ptr{sample_type},1}\n\n    bytes_buf::Int\n    n_buf::Int\n    backing::SharedArray{sample_type}\n\n    DMABufferArray(bytes_buf, n_buf) = begin\n        n_buf   1   bytes_buf % Base.Mmap.PAGESIZE != 0  \n            error( Bytes per buffer must be a multiple of Base.Mmap.PAGESIZE when  ,\n                   there is more than one buffer. )\n\n        backing = SharedArray(sample_type,\n                        Int((bytes_buf * n_buf) / sizeof(sample_type)))\n\n        dmabuf = new(bytes_buf,\n                     n_buf,\n                     backing)\n\n        return dmabuf\n    end\n\nend\n\nBase.size(dma::DMABufferArray) = (dma.n_buf,)\nBase.linearindexing(::Type{DMABufferArray}) = Base.LinearFast()\nBase.getindex(dma::DMABufferArray, i::Int) =\n    pointer(dma.backing) + (i-1) * dma.bytes_buf\nBase.length(dma::DMABufferArray) = dma.n_buf\n\nbytespersample{T}(buf_array::DMABufferArray{T}) = sizeof(T)\nsampletype{T}(buf_array::DMABufferArray{T}) = T  Some comments:   A single SharedArray is used to back  all  DMA buffers. Memory is therefore\ncontiguous and page-aligned.  The memory for each DMA buffer is required to be a multiple of the page size\nwhen there is more than one buffer.  The memory can be accessed by multiple processes.  The elements of a  DMABufferArray  are pointers to the the different\nlocations in memory which act as DMA buffers. The array is iterable and indexable\nas usual.", 
            "title": "Alazar instruments"
        }, 
        {
            "location": "/releases/", 
            "text": "Releases\n\n\nv0.0.1      Currently under development", 
            "title": "Release notes"
        }, 
        {
            "location": "/releases/#releases", 
            "text": "v0.0.1      Currently under development", 
            "title": "Releases"
        }, 
        {
            "location": "/LICENSE/", 
            "text": "License\n\n\nMost code:\n\n\n\n\nCopyright (c) 2015: Andrew Keller.\n\n\n\n\nRandom.jl, Time.jl, and a few other snippets here and there:\n\n\n\n\nCopyright (c) 2014: Menyoung Lee.\n\n\n\n\nLarge majority of code in VISA.jl package:\n\n\n\n\nCopyright (c) 2014: Colm Ryan.\n\n\n\n\nAll of the code is licensed under the MIT \"Expat\" License by the respective\ncopyright holders:\n\n\n\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.", 
            "title": "License"
        }, 
        {
            "location": "/LICENSE/#license", 
            "text": "Most code:   Copyright (c) 2015: Andrew Keller.   Random.jl, Time.jl, and a few other snippets here and there:   Copyright (c) 2014: Menyoung Lee.   Large majority of code in VISA.jl package:   Copyright (c) 2014: Colm Ryan.   All of the code is licensed under the MIT \"Expat\" License by the respective\ncopyright holders:   Permission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:  The above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.", 
            "title": "License"
        }
    ]
}