{
    "docs": [
        {
            "location": "/", 
            "text": "PainterQB.jl\n\n\nA \nJulia\n package for qubit measurement and analysis.\n\n\nWork in development, not ready for implementation. The documentation may assume some familiarity\nwith Julia.\n\n\nInstallation\n\n\n\n\nInstall \nNational Instruments VISA libraries\n\n (tested with v15.0.1 on Windows 10)\n\n\nInstall \nAlazarTech\n digitizer drivers and shared libraries\n (may need to contact AlazarTech)\n\n\nInstall \nVISA.jl\n\n\nInstall \nAlazar.jl\n\n\nInstall this code and \ninclude\n it in a Julia environment\n\n\n\n\nQuick start\n\n\nusing PainterQB\nusing PainterQB.AlazarModule\nusing PainterQB.AWG5014CModule  # etc.\n\nawg = AWG5014C(tcpip_socket(1.2.3.4),5000)\nats = AlazarATS9360()\n\n# do something with awg and ats\n\n\n\n\n\nTo do\n\n\nGlobally\n\n\n\n\n\n\nUnits! A good starting point would be the\n\nSIUnits.jl\n package. It currently does\nnot support fractional units like V/sqrt(Hz) but support could be added.\n\n\n\n\n\n\nHow to save / load configurations for instruments? Maybe JSON files?\n\n\n\n\n\n\nAWG5014C\n\n\n\n\nWaveform methods could be made more Julian", 
            "title": "Home"
        }, 
        {
            "location": "/#painterqbjl", 
            "text": "A  Julia  package for qubit measurement and analysis.  Work in development, not ready for implementation. The documentation may assume some familiarity\nwith Julia.", 
            "title": "PainterQB.jl"
        }, 
        {
            "location": "/#installation", 
            "text": "Install  National Instruments VISA libraries \n (tested with v15.0.1 on Windows 10)  Install  AlazarTech  digitizer drivers and shared libraries\n (may need to contact AlazarTech)  Install  VISA.jl  Install  Alazar.jl  Install this code and  include  it in a Julia environment", 
            "title": "Installation"
        }, 
        {
            "location": "/#quick-start", 
            "text": "using PainterQB\nusing PainterQB.AlazarModule\nusing PainterQB.AWG5014CModule  # etc.\n\nawg = AWG5014C(tcpip_socket(1.2.3.4),5000)\nats = AlazarATS9360()\n\n# do something with awg and ats", 
            "title": "Quick start"
        }, 
        {
            "location": "/#to-do", 
            "text": "Globally    Units! A good starting point would be the SIUnits.jl  package. It currently does\nnot support fractional units like V/sqrt(Hz) but support could be added.    How to save / load configurations for instruments? Maybe JSON files?    AWG5014C   Waveform methods could be made more Julian", 
            "title": "To do"
        }, 
        {
            "location": "/design/", 
            "text": "Design overview\n\n\nWhat is an instrument?\n\n\nabstract Instrument\n\n\nFor the purposes of this package, an instrument is just something connected to the\ncomputer that we need to communicate with, and which can source or measure something.\nEvery instrument may connect to the computer by different hardware,\ncomms protocols, and command dialects.\n\n\nAll instruments are Julia objects, subtypes of the abstract type \nInstrument\n.\n\n\nInstrument types\n\n\nMany instruments share the same communications protocols. We subtype \nInstrument\n\nbased on these protocols.\n\n\nVISA\n\n\nabstract InstrumentVISA \n: Instrument\n\n\nMany instruments are able to be addressed using the\n\nVISA\n standard (Virtual\nInstrument Software Architecture), currently maintained by the IVI Foundation.\n\n\nTo talk to VISA instruments will require the Julia package \nVISA.jl\n\nas well as the \nNational Instruments VISA libraries\n.\nInstallation instructions are available at each link.\n\n\nAlazar digitizers\n\n\nabstract InstrumentAlazar \n: Instrument\n\n\nDigitizers made by \nAlazarTech\n are notably \nnot\n\ncompatible with the VISA standard. The VISA standard was probably not intended\nfor PCIe cards with extreme data throughput. All Alazar digitizers are addressable by an API\nsupplied by the company, which talks to the card through a shared library (think .dll on\nWindows or .so on Linux).\n\n\nThe shared library files and API documentation are only available from AlazarTech.\n\n\nInstrument interface\n\n\nProperties\n\n\nInstrument properties are configured and inspected using two functions,\n\nconfigure\n and \ninspect\n. Why not \nset\n and \nget\n? Ultimately these verbs are\npretty generic and often have implicit meanings in other programming languages.\nIn C, for instance, \nget\n often implies that the function will return an address\nin memory rather than a value.\n\n\n\"configure\"\n:\n\"to arrange or prepare (something) so that it can be used.\"\n\n\n\"inspect\"\n:\n\"to look at (something) carefully in order to learn more about it, to find problems, etc.\"\n\n\nSource and measure\n\n\nTwo functions are provided to abstract away many kinds of measurements: \nsource\n\nand \nmeasure\n. In an experiment you source some stimulus and measure a response.\nTherefore \nsource\n takes as an argument an object matching type signature\n\nStimulus\n, which can have different fields for different types of stimuli.\n\nmeasure\n takes as an argument an object matching type signature \nResponse\n. The\nidea is to write new subtypes of \nStimulus\n and \nResponse\n to describe what you\nare doing, as well as new methods for \nsource\n and \nmeasure\n.\n\n\nStimuli\n\n\nMany common stimuli are already provided. For example, a signal generator may\nhave \nFrequencyStimulus\n objects, with fields \nsiggen::SignalGenerator\n\nand \nfrequency::AbstractFloat\n. To source this stimulus (change the frequency),\na method \nsource(freqstim::FrequencyStimulus)\n is defined, which would change\nthe frequency of the signal sourced by the generator as specified.\n\n\nNot all stimuli are associated with a physical instrument. For instance, a\n\nDelayStimulus\n will cause the script to block until a specified time after\ncreation of the \nDelayStimulus\n object before proceeding with a measurement.\nPerhaps in this case the instrument is the computer itself, but in the\nimplementation, a \nDelayStimulus\n object has no field matching type signature\n\nInstrument\n.\n\n\nWe have seen that a stimulus need not even be associated with an \nInstrument\n. It\nstands to reason that in principle they could be associated with several \nInstrument\n\nobjects. Maybe a stimulus in a particular experiment is to change all gate voltages\nat once. If these are gate voltages are sourced by several physical instruments,\nthen for example, perhaps several \nInstrument\ns should be a field in a new\n\nStimulus\n object.\n\n\nResponses\n\n\nResponses need not come from instruments. For test purposes, suppose we want to\nmimic a measurement by generating random numbers. \nRandomResponse\n produces a\nrandom number in the unit interval when it is measured. A \nTimerResponse\n will\nmeasure the time since creation of the \nTimerResponse\n object.\n\n\nFeedback loops\n\n\nIn principle, software feedback loops could be implemented\nwith the \nReactive.jl\n package. This\nwould probably only be suitable for slowly varying signals, e.g. PID temperature control.\n\n\nMeasurement archetypes\n\n\nNow that we have abstracted \nsource\n and \nmeasure\n, we can think about archetypal\nmeasurement schemes. Often we want to do a 1D sweep:\n\n\nfunction\n \nsweep1d\n(\nstimulus\n::\nStimulus\n,\n \nresponse\n::\nResponse\n)\n\n    \nfor\n \nvalue\n \nin\n \niterator\n\n        \nsource\n(\nstimulus\n,\nvalue\n)\n\n        \nmeasure\n(\nresponse\n)\n\n    \nend\n\n\nend\n\n\n\n\n\n\nIt is clear that in most cases this single 1D sweep function will suffice for\nany kind of 1D sweep we want to do. This is a compelling reason to write\nmeasurement code in a language that natively supports mulitple dispatch, such as\nJulia.", 
            "title": "Design"
        }, 
        {
            "location": "/design/#design-overview", 
            "text": "", 
            "title": "Design overview"
        }, 
        {
            "location": "/design/#what-is-an-instrument", 
            "text": "abstract Instrument  For the purposes of this package, an instrument is just something connected to the\ncomputer that we need to communicate with, and which can source or measure something.\nEvery instrument may connect to the computer by different hardware,\ncomms protocols, and command dialects.  All instruments are Julia objects, subtypes of the abstract type  Instrument .", 
            "title": "What is an instrument?"
        }, 
        {
            "location": "/design/#instrument-types", 
            "text": "Many instruments share the same communications protocols. We subtype  Instrument \nbased on these protocols.  VISA  abstract InstrumentVISA  : Instrument  Many instruments are able to be addressed using the VISA  standard (Virtual\nInstrument Software Architecture), currently maintained by the IVI Foundation.  To talk to VISA instruments will require the Julia package  VISA.jl \nas well as the  National Instruments VISA libraries .\nInstallation instructions are available at each link.  Alazar digitizers  abstract InstrumentAlazar  : Instrument  Digitizers made by  AlazarTech  are notably  not \ncompatible with the VISA standard. The VISA standard was probably not intended\nfor PCIe cards with extreme data throughput. All Alazar digitizers are addressable by an API\nsupplied by the company, which talks to the card through a shared library (think .dll on\nWindows or .so on Linux).  The shared library files and API documentation are only available from AlazarTech.", 
            "title": "Instrument types"
        }, 
        {
            "location": "/design/#instrument-interface", 
            "text": "Properties  Instrument properties are configured and inspected using two functions, configure  and  inspect . Why not  set  and  get ? Ultimately these verbs are\npretty generic and often have implicit meanings in other programming languages.\nIn C, for instance,  get  often implies that the function will return an address\nin memory rather than a value.  \"configure\" :\n\"to arrange or prepare (something) so that it can be used.\"  \"inspect\" :\n\"to look at (something) carefully in order to learn more about it, to find problems, etc.\"  Source and measure  Two functions are provided to abstract away many kinds of measurements:  source \nand  measure . In an experiment you source some stimulus and measure a response.\nTherefore  source  takes as an argument an object matching type signature Stimulus , which can have different fields for different types of stimuli. measure  takes as an argument an object matching type signature  Response . The\nidea is to write new subtypes of  Stimulus  and  Response  to describe what you\nare doing, as well as new methods for  source  and  measure .  Stimuli  Many common stimuli are already provided. For example, a signal generator may\nhave  FrequencyStimulus  objects, with fields  siggen::SignalGenerator \nand  frequency::AbstractFloat . To source this stimulus (change the frequency),\na method  source(freqstim::FrequencyStimulus)  is defined, which would change\nthe frequency of the signal sourced by the generator as specified.  Not all stimuli are associated with a physical instrument. For instance, a DelayStimulus  will cause the script to block until a specified time after\ncreation of the  DelayStimulus  object before proceeding with a measurement.\nPerhaps in this case the instrument is the computer itself, but in the\nimplementation, a  DelayStimulus  object has no field matching type signature Instrument .  We have seen that a stimulus need not even be associated with an  Instrument . It\nstands to reason that in principle they could be associated with several  Instrument \nobjects. Maybe a stimulus in a particular experiment is to change all gate voltages\nat once. If these are gate voltages are sourced by several physical instruments,\nthen for example, perhaps several  Instrument s should be a field in a new Stimulus  object.  Responses  Responses need not come from instruments. For test purposes, suppose we want to\nmimic a measurement by generating random numbers.  RandomResponse  produces a\nrandom number in the unit interval when it is measured. A  TimerResponse  will\nmeasure the time since creation of the  TimerResponse  object.  Feedback loops  In principle, software feedback loops could be implemented\nwith the  Reactive.jl  package. This\nwould probably only be suitable for slowly varying signals, e.g. PID temperature control.  Measurement archetypes  Now that we have abstracted  source  and  measure , we can think about archetypal\nmeasurement schemes. Often we want to do a 1D sweep:  function   sweep1d ( stimulus :: Stimulus ,   response :: Response ) \n     for   value   in   iterator \n         source ( stimulus , value ) \n         measure ( response ) \n     end  end   It is clear that in most cases this single 1D sweep function will suffice for\nany kind of 1D sweep we want to do. This is a compelling reason to write\nmeasurement code in a language that natively supports mulitple dispatch, such as\nJulia.", 
            "title": "Instrument interface"
        }, 
        {
            "location": "/implementation/", 
            "text": "Implementation overview\n\n\nCode organization\n\n\nOrganizing the code into Julia modules is tricky and the organization may change\nin future releases. It would not be surprising if the way Julia implements modules\nchanges before Julia v1.0.\n\n\n\n\nWith few exceptions, all code is kept inside a single package. For now the\npackage is unregistered and must be retrieved from the repository with\n\nPkg.clone()\n rather than \nPkg.add()\n.\n\n\nLow-level wrappers for shared libraries are kept in their own packages\n(e.g. VISA and Alazar calls). This way, at least some code can be reused if\nsomeone else does not want to use our codebase.\n\n\n\n\n\n\nAll code is kept inside a \"main\" \nPainterQB\n module, defined inside \nsrc/PainterQB.jl\n.\n\n\nCommon instrument definitions and functions are defined in \nsrc/InstrumentDefs.jl\n.\n\n\nInstrumentVISA\n and associated functions are defined in \nsrc/InstrumentVISA.jl\n.\n\n\n\n\n\n\nEach instrument is defined within its own module, a submodule of \nPainterQB\n.\n\n\nEach instrument has a corresponding .jl file in \nsrc/hardware\n.\n\n\nInstrument model numbers are used for type definitions (e.g. \nAWG5014C\n),\nso module names have \"Module\" appended (e.g. \nAWG5014CModule\n).\n\n\nexport\n statements from an instrument submodule are not currently exported\nfrom \nPainterQB\n. The statement \nusing PainterQB.AWG5014CModule\n\nmay be desired when using the AWG, for instance.\n\n\n\n\n\n\nTo test for possible namespace conflicts when adding new instruments,\nuncomment the \nimportall\n statements in \nsrc/PainterQB.jl\n.\n\n\nAs functions from different instrument modules are imported, any functions\nthat are defined in different modules will be printed and warned about. The\nsolution is to define the shared function name in \nsrc/InstrumentDefs.jl\n\n(\nglobal\n and \nexport\n) such that the submodules can both import the function.\n\n\n\n\n\n\n\n\nVISA Instruments\n\n\nMany commercial instruments support a common communications protocol and command\nsyntax (VISA and SCPI respectively). For such instruments, many methods for\n\nconfigure\n and \ninspect\n can be generated with metaprogramming, rather than\ntyping them out explicitly.\n\n\nTechnical note: The file \nsrc/Metaprogramming.jl\n is included in each VISA\ninstrument's source file, and therefore in each instrument's own module.\nInitially this file was included directly in the PainterQB module, but it seems\nthere are subtleties regarding the use of the \n@eval\n macro between modules.\n\n\nMetaprogramming\n\n\ngenerate_inspect\n\n\ngenerate_inspect{S\n:Instrument,T\n:InstrumentProperty}(instype::Type{S},\n        command::ASCIIString, proptype::Type{T}, returntype...)\n\n\n\n\n\nThis command takes an \nInstrument\n subtype \ninstype\n, a VISA command, an\n\nInstrumentProperty\n subtype \nproptype\n, and possibly an argument. It will\ngenerate the following method in the module where \ngenerate_inspect\n is defined:\n\n\ninspect(ins::instype, ::Type{proptype}, infixes::Int...)\n\n\nThe \ninfixes\n variable argument allows for numbers to be inserted within the\ncommands, for instance in \nOUTP#:FILT:FREQ\n, where the \n#\n sign should be\nreplaced by an integer. The replacements are done in the order of the arguments.\nError checking is done on the number of arguments.\n\n\nFor a given property, \ninspect\n will return either an InstrumentProperty object,\na number, a boolean, or a string as appropriate.\n\n\ngenerate_configure\n\n\ngenerate_configure{S\n:Instrument,T\n:InstrumentProperty}(instype::Type{S},\n        command::ASCIIString, proptype::Type{T}, returntype...)\n\n\n\n\n\nThis command takes an \nInstrument\n subtype \nInsType\n, a VISA command, an\n\nInstrumentProperty\n type, and possibly an argument. It will generate one of the\nfollowing methods in the module where \ngenerate_inspect\n is defined:\n\n\nconfigure(ins::InsType, PropertySubtype)\nconfigure(ins::InsType, Property, values..., infixes...)\n\n\n\n\n\ngenerate_properties\n\n\ngenerate_properties{S\n:InstrumentProperty}(subtype::Symbol, supertype::Type{S})\n\n\n\n\n\nThis makes it easy to generate new \nInstrumentProperty\n subtypes. Typically\nthis function is called inside a for loop. Calling this function is equivalent\nto writing the following pseudocode:\n\n\nimmutable (subtype){T} \n: supertype\n    ins::Instrument\n    code::T\n    logicalname::AbstractString\n\n    (subtype)(a,b) = new(a,b,string(subtype))\nend\n\n(subtype){T}(a::Instrument,b::T) = (subtype){T}(a,b)\n\nexport subtype\n\ncode{T}(inscode::subtype{T}) = inscode.code::T\n\n\n\n\n\nAccess to the \ncode\n field is given through a method to allow for a little\nflexibility in case implementation details change.\n\n\ngenerate_handlers", 
            "title": "Implementation"
        }, 
        {
            "location": "/implementation/#implementation-overview", 
            "text": "", 
            "title": "Implementation overview"
        }, 
        {
            "location": "/implementation/#code-organization", 
            "text": "Organizing the code into Julia modules is tricky and the organization may change\nin future releases. It would not be surprising if the way Julia implements modules\nchanges before Julia v1.0.   With few exceptions, all code is kept inside a single package. For now the\npackage is unregistered and must be retrieved from the repository with Pkg.clone()  rather than  Pkg.add() .  Low-level wrappers for shared libraries are kept in their own packages\n(e.g. VISA and Alazar calls). This way, at least some code can be reused if\nsomeone else does not want to use our codebase.    All code is kept inside a \"main\"  PainterQB  module, defined inside  src/PainterQB.jl .  Common instrument definitions and functions are defined in  src/InstrumentDefs.jl .  InstrumentVISA  and associated functions are defined in  src/InstrumentVISA.jl .    Each instrument is defined within its own module, a submodule of  PainterQB .  Each instrument has a corresponding .jl file in  src/hardware .  Instrument model numbers are used for type definitions (e.g.  AWG5014C ),\nso module names have \"Module\" appended (e.g.  AWG5014CModule ).  export  statements from an instrument submodule are not currently exported\nfrom  PainterQB . The statement  using PainterQB.AWG5014CModule \nmay be desired when using the AWG, for instance.    To test for possible namespace conflicts when adding new instruments,\nuncomment the  importall  statements in  src/PainterQB.jl .  As functions from different instrument modules are imported, any functions\nthat are defined in different modules will be printed and warned about. The\nsolution is to define the shared function name in  src/InstrumentDefs.jl \n( global  and  export ) such that the submodules can both import the function.", 
            "title": "Code organization"
        }, 
        {
            "location": "/implementation/#visa-instruments", 
            "text": "Many commercial instruments support a common communications protocol and command\nsyntax (VISA and SCPI respectively). For such instruments, many methods for configure  and  inspect  can be generated with metaprogramming, rather than\ntyping them out explicitly.  Technical note: The file  src/Metaprogramming.jl  is included in each VISA\ninstrument's source file, and therefore in each instrument's own module.\nInitially this file was included directly in the PainterQB module, but it seems\nthere are subtleties regarding the use of the  @eval  macro between modules.  Metaprogramming  generate_inspect  generate_inspect{S :Instrument,T :InstrumentProperty}(instype::Type{S},\n        command::ASCIIString, proptype::Type{T}, returntype...)  This command takes an  Instrument  subtype  instype , a VISA command, an InstrumentProperty  subtype  proptype , and possibly an argument. It will\ngenerate the following method in the module where  generate_inspect  is defined:  inspect(ins::instype, ::Type{proptype}, infixes::Int...)  The  infixes  variable argument allows for numbers to be inserted within the\ncommands, for instance in  OUTP#:FILT:FREQ , where the  #  sign should be\nreplaced by an integer. The replacements are done in the order of the arguments.\nError checking is done on the number of arguments.  For a given property,  inspect  will return either an InstrumentProperty object,\na number, a boolean, or a string as appropriate.  generate_configure  generate_configure{S :Instrument,T :InstrumentProperty}(instype::Type{S},\n        command::ASCIIString, proptype::Type{T}, returntype...)  This command takes an  Instrument  subtype  InsType , a VISA command, an InstrumentProperty  type, and possibly an argument. It will generate one of the\nfollowing methods in the module where  generate_inspect  is defined:  configure(ins::InsType, PropertySubtype)\nconfigure(ins::InsType, Property, values..., infixes...)  generate_properties  generate_properties{S :InstrumentProperty}(subtype::Symbol, supertype::Type{S})  This makes it easy to generate new  InstrumentProperty  subtypes. Typically\nthis function is called inside a for loop. Calling this function is equivalent\nto writing the following pseudocode:  immutable (subtype){T}  : supertype\n    ins::Instrument\n    code::T\n    logicalname::AbstractString\n\n    (subtype)(a,b) = new(a,b,string(subtype))\nend\n\n(subtype){T}(a::Instrument,b::T) = (subtype){T}(a,b)\n\nexport subtype\n\ncode{T}(inscode::subtype{T}) = inscode.code::T  Access to the  code  field is given through a method to allow for a little\nflexibility in case implementation details change.  generate_handlers", 
            "title": "VISA Instruments"
        }, 
        {
            "location": "/releases/", 
            "text": "Releases\n\n\nv0.0.1      Currently under development", 
            "title": "Release notes"
        }, 
        {
            "location": "/releases/#releases", 
            "text": "v0.0.1      Currently under development", 
            "title": "Releases"
        }, 
        {
            "location": "/../LICENSE/", 
            "text": "Most everything in the visa folder:\n\n\n\n\nCopyright (c) 2014: Colm Ryan.\n\n\n\n\nRandom.jl, Time.jl, and a few other snippets here and there:\n\n\n\n\nCopyright (c) 2014: Menyoung Lee.\n\n\n\n\nEverything else:\n\n\n\n\nCopyright (c) 2015: Andrew Keller.\n\n\n\n\nAll of the code is licensed under the MIT \"Expat\" License by the respective\ncopyright holders:\n\n\n\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.", 
            "title": "License"
        }
    ]
}